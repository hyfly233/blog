import{_ as l,c as n,f as a,o as e}from"./app-chPKMbRn.js";const i={};function p(r,s){return e(),n("div",null,s[0]||(s[0]=[a(`<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h1><h2 id="redis实现原理" tabindex="-1"><a class="header-anchor" href="#redis实现原理"><span>Redis实现原理</span></a></h2><ul><li>纯内存操作</li><li>单线程操作，避免频繁的上下文切换</li><li>采用非阻塞I/O多路复用机制</li><li>纯ANSI C编写</li></ul><div class="language-plain line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="plain" data-title="plain"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-plain;"><code><span class="line"><span class="line"><span>redis的工作原理是什么</span></span></span>
<span class="line"><span class="line"><span></span></span></span>
<span class="line"><span class="line"><span>Redis 是一个高性能的 key-value 存储系统，支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等。它的工作原理可以概括为：</span></span></span>
<span class="line"><span class="line"><span></span></span></span>
<span class="line"><span class="line"><span>内存存储：Redis 将数据存储在内存中，以实现快速读写操作。同时，Redis 也支持数据持久化到磁盘中，以保证数据在断电等情况下不会丢失。</span></span></span>
<span class="line"><span class="line"><span></span></span></span>
<span class="line"><span class="line"><span>单线程执行：Redis 使用单线程模型来避免多线程之间的竞争和锁等问题，从而提高系统的并发处理能力。同时，Redis 也使用了一些异步 IO 技术，以实现高效的网络 IO 操作。</span></span></span>
<span class="line"><span class="line"><span></span></span></span>
<span class="line"><span class="line"><span>事件驱动模型：Redis 采用事件驱动模型，通过监听网络套接字上的事件，如可读事件、可写事件等，来触发对应的事件处理函数，从而实现对客户端请求的响应。这种模型避免了传统的轮询方式带来的性能问题。</span></span></span>
<span class="line"><span class="line"><span></span></span></span>
<span class="line"><span class="line"><span>数据结构的支持：Redis 支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等。这些数据结构都有自己的特点和适用场景，可以满足不同应用的需求。</span></span></span>
<span class="line"><span class="line"><span></span></span></span>
<span class="line"><span class="line"><span>原子性操作：Redis 支持多种原子性操作，如事务、乐观锁、悲观锁等。这些操作可以保证数据的一致性和正确性，同时也提高了系统的并发性能。</span></span></span>
<span class="line"><span class="line"><span></span></span></span>
<span class="line"><span class="line"><span>总之，Redis 的工作原理非常灵活和高效，可以满足各种应用场景的需求。</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="使用redis有哪些好处" tabindex="-1"><a class="header-anchor" href="#使用redis有哪些好处"><span>使用redis有哪些好处</span></a></h2><ol><li><strong>速度快</strong>，因为数据存在内存中</li><li><strong>支持丰富数据类型</strong>，支持 string，list，set，sorted set，hash</li><li><strong>支持事务</strong>，操作都是原子性（与关系型数据库的事务不是同一个东西）</li><li><strong>丰富的特性</strong>：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ol><h2 id="redis相比memcached有哪些优势" tabindex="-1"><a class="header-anchor" href="#redis相比memcached有哪些优势"><span>redis相比memcached有哪些优势？</span></a></h2><ol><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>redis的速度比memcached快很多</li><li>redis可以持久化其数据</li></ol><h2 id="redis-最适合的场景" tabindex="-1"><a class="header-anchor" href="#redis-最适合的场景"><span>redis 最适合的场景</span></a></h2><ul><li>会话缓存（Session Cache）</li><li>全页缓存（FPC）</li><li>队列</li><li>排行榜/计数器</li><li>发布/订阅</li></ul><h2 id="redis是单线程还是多线程" tabindex="-1"><a class="header-anchor" href="#redis是单线程还是多线程"><span>redis是单线程还是多线程</span></a></h2><ul><li>无论什么版本，工作线程就是一个</li><li>6.x高版本出现了IO多线程</li><li>单线程，满足redis的串行原子，只不过IO多线程后，把输入/输出放到更多的线程里去并行，好处如下：1、执行时间缩短，更快；2、更好的压榨系统及硬件的资源(网卡能够高效的使用)；</li></ul><h2 id="redis的一些其他特点" tabindex="-1"><a class="header-anchor" href="#redis的一些其他特点"><span>redis的一些其他特点</span></a></h2><ul><li><p>Redis是单进程单线程的，利用队列技术将并发访问变为串行访问</p></li><li><p>读写分离模型，整个集群的读和写的可用性都非常高</p></li><li><p>数据分片模型，可以将每个节点看成都是独立的master，然后通过业务实现数据分片</p></li><li><p>Redis的回收策略</p></li><li><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据 使用策略规则：</li></ul></li></ul><ol><li><ol><li><ol><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</li><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</li></ol></li></ol></li></ol><h2 id="mysql里有2000w数据-redis中只存20w的数据-如何保证redis中的数据都是热点数据" tabindex="-1"><a class="header-anchor" href="#mysql里有2000w数据-redis中只存20w的数据-如何保证redis中的数据都是热点数据"><span>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据</span></a></h2><p>Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略，可以通过淘汰策略保证热点数据</p><h2 id="假如redis里面有1亿个key-其中有10w个key是以某个固定的已知的前缀开头的-如果将它们全部找出来" tabindex="-1"><a class="header-anchor" href="#假如redis里面有1亿个key-其中有10w个key是以某个固定的已知的前缀开头的-如果将它们全部找出来"><span>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a></h2><p>使用<code>scan</code>指令查找，使用<code>keys</code>指令会阻塞</p><h2 id="redis-常见的性能问题都有哪些-如何解决" tabindex="-1"><a class="header-anchor" href="#redis-常见的性能问题都有哪些-如何解决"><span>Redis 常见的性能问题都有哪些？如何解决？</span></a></h2><ol><li>Master最好不要写内存快照，Master 写内存快照，save命令调度rdbSave函数，<strong>会阻塞主线程的工作</strong>，当快照比较大时对性能影响是非常大的，会间断性暂停服务。</li><li>Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件。Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，<strong>AOF文件过大</strong>会影响Master重启的恢复速度。<strong>Master最好不要做任何持久化工作</strong>，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li><li>Master调用<code>BGREWRITEAOF</code>重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li><li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在<code>同一个局域网</code>内</li><li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>尽量避免在压力很大的主库上增加从库</li><li>主从复制不要用图状结构，用<strong>单向链表结构</strong>更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- …</code></li></ol><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h2><ul><li><p>**缓存穿透：**查询某个 Key 对应的数据，<strong>数据库和reids中没有该数据</strong>，查了redis再查数据库，没有查出数据返回空（相当于进行了两次无用的查询），redis 也不会缓存空结果，这就造成每次通过这样的 Key 去查询数据都会直接到数据库中查询，这也是缓存命中率问题。</p></li><li><p><strong>解决方法：</strong></p></li><li><ul><li>让有效地请求到达数据库，即便放大前置环节的复杂度和成本</li></ul></li><li><ul><li><ul><li>布隆过滤器。布隆过滤器可以针对大数据量的、有规律的键值进行处理。一条记录是不是存在，本质上是一个 Bool 值，只需要使用 1bit 就可以存储。使用布隆过滤器将这种表示是、否等操作，压缩到一个数据结构中。比如，用户性别这种数据，就非常适合使用布隆过滤器来处理</li><li>将数据库查询的空结果缓存到 redis 中，设置合理的过期时间（可能浪费空间）</li></ul></li></ul></li></ul><div class="language-java line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-java;"><code><span class="line"><span class="line"><span style="color:#81A1C1;">public</span><span style="color:#D8DEE9FF;"> object </span><span style="color:#88C0D0;">getProductList</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    int</span><span style="color:#D8DEE9;"> cacheTime</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 30</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> cacheKey</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">product_list</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> cacheValue</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">Get</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheKey</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    if</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9FF;">cacheValue </span><span style="color:#81A1C1;">!=</span><span style="color:#81A1C1;"> null</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        return</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">        //数据库查询不到，为空</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">        cacheValue </span><span style="color:#81A1C1;">=</span><span style="color:#88C0D0;"> getProductListFromDB</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        if</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9FF;">cacheValue </span><span style="color:#81A1C1;">==</span><span style="color:#81A1C1;"> null</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">            //如果发现为空，设置个默认值，也缓存起来</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">            cacheValue </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9;"> string</span><span style="color:#ECEFF4;">.</span><span style="color:#D8DEE9;">Empty</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">        }</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9;">        CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">Add</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheKey</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> cacheTime</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        return</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">    }</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">}</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h2><ul><li><p>**缓存击穿：**如果缓存中的数据在某个时刻批量过期（相同的过期时间），导致大部分用户的请求都会直接落在数据库上，这种现象就叫作缓存击穿</p></li><li><p><strong>解决方法：</strong></p></li><li><ul><li>对于不变的比较热点的数据可以设置为永不过期</li><li>在访问数据的时候，更新其过期时间</li><li>对于批量入库的缓存项，分配比较合理的过期时间，避免同一时刻失效</li><li>使用分布式锁，保证对于每个 key 同时只有一个线程去查询后端服务，其他线程进入等待（性能大大降低）</li></ul></li><li><ul><li><ul><li>步骤：</li></ul></li></ul></li></ul><ol><li><ol><li><ol><li><ol><li>请求 redis，肯定没有</li><li>大家抢锁，redis取不到数据时</li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li><ol><li>抢上的查数据库，O(1)</li><li>没抢上的 sleep（sleep线程不会占用cpu）</li></ol></li></ol></li></ol></li></ol></li><li><ol><li><ol><li><ol><li>数据库查询，更新redis，O(1)</li><li>sleep的线程回到第一步</li></ol></li></ol></li></ol></li></ol><div class="language-java line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-java;"><code><span class="line"><span class="line"><span style="color:#81A1C1;">public</span><span style="color:#D8DEE9FF;"> object </span><span style="color:#88C0D0;">getProductList</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    int</span><span style="color:#D8DEE9;"> cacheTime</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 30</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> cacheKey</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">product_list</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> lockKey</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9FF;"> cacheKey</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> cacheValue</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">get</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheKey</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    </span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    if</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9FF;">cacheValue </span><span style="color:#81A1C1;">!=</span><span style="color:#81A1C1;"> null</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        return</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;">    </span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        synchronized</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">lockKey</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">            cacheValue </span><span style="color:#81A1C1;">=</span><span style="color:#D8DEE9;"> CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">get</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheKey</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">            if</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9FF;">cacheValue </span><span style="color:#81A1C1;">!=</span><span style="color:#81A1C1;"> null</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">                return</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">            }</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span><span style="color:#D8DEE9FF;">                </span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">                //这里一般是sql查询数据</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">                cacheValue </span><span style="color:#81A1C1;">=</span><span style="color:#88C0D0;"> getProductListFromDB</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9;">                CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">Add</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheKey</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> cacheTime</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">            }</span><span style="color:#D8DEE9FF;">        </span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">        }</span><span style="color:#D8DEE9FF;">        </span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        return</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">    }</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">}</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><ul><li>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存</li></ul></li><li><ul><li><ul><li>缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存</li><li>缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存</li></ul></li></ul></li></ul><div class="language-java line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-java;"><code><span class="line"><span class="line"><span style="color:#81A1C1;">public</span><span style="color:#D8DEE9FF;"> object </span><span style="color:#88C0D0;">getProductList</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    int</span><span style="color:#D8DEE9;"> cacheTime</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 30</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> cacheKey</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">product_list</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;">    </span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    //缓存标记</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> cacheSign</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9FF;"> cacheKey </span><span style="color:#81A1C1;">+</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">_sign</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;">  </span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    </span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> sign</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">Get</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheSign</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">    //获取缓存值</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">    String</span><span style="color:#D8DEE9;"> cacheValue</span><span style="color:#81A1C1;"> =</span><span style="color:#D8DEE9;"> CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">Get</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheKey</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    </span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    if</span><span style="color:#ECEFF4;"> (</span><span style="color:#D8DEE9FF;">sign </span><span style="color:#81A1C1;">!=</span><span style="color:#81A1C1;"> null</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        return</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#81A1C1;">;</span><span style="color:#616E88;"> //未过期，直接返回</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">    }</span><span style="color:#81A1C1;"> else</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9;">        CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">Add</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheSign</span><span style="color:#ECEFF4;">,</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">1</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> cacheTime</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span><span style="color:#D8DEE9FF;">       </span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9;">        ThreadPool</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">QueueUserWorkItem</span><span style="color:#ECEFF4;">((</span><span style="color:#D8DEE9FF;">arg</span><span style="color:#ECEFF4;">)</span><span style="color:#8FBCBB;"> -&gt;</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">            //这里一般是 sql查询数据</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">            cacheValue </span><span style="color:#81A1C1;">=</span><span style="color:#88C0D0;"> getProductListFromDB</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">            //日期设缓存时间的2倍，用于脏读</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9;">            CacheHelper</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">Add</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">cacheKey</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> cacheTime </span><span style="color:#81A1C1;">*</span><span style="color:#B48EAD;"> 2</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">        })</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        return</span><span style="color:#D8DEE9FF;"> cacheValue</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">    }</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">}</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h2><ul><li><p>**缓存雪崩：**如果在某一时刻缓存集中失效（缓存击穿 * N），或者缓存系统出现故障，所有的并发流量就会直接到达数据库。数据存储层的调用量就会暴增，用不了多长时间，数据库就会被大流量压垮，这种级联式的服务故障，就叫作缓存雪崩。</p></li><li><p><strong>解决方法：</strong></p></li><li><ul><li>保证 Redis 的高可用，将 Redis 缓存部署成高可用集群，有效的防止缓存雪崩问题的发生</li><li>缓解大并发流量，使用限流降级的方式防止缓存雪崩</li><li>通过数据预热的方式将可能大量访问的数据加载到缓存，在即将发生大并发访问的时候，提前手动触发加载不同的数据到缓存中，并为数据设置不同的过期时间，让缓存失效的时间点尽量均匀，不至于在同一时刻全部失效</li></ul></li></ul><h2 id="redis是怎么删除过期key的、缓存如何回收的" tabindex="-1"><a class="header-anchor" href="#redis是怎么删除过期key的、缓存如何回收的"><span>Redis是怎么删除过期key的、缓存如何回收的？</span></a></h2><ul><li><p>被动清理</p></li><li><ul><li>当用户主动访问一个过期的key时，redis会将其直接从内存中删除</li></ul></li><li><p>主动清理</p></li><li><ul><li>redis后台轮询，分段分批的删除过期的key</li></ul></li></ul><h2 id="redis的淘汰回收策略" tabindex="-1"><a class="header-anchor" href="#redis的淘汰回收策略"><span>Redis的淘汰回收策略</span></a></h2><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据 使用策略规则：</li></ul><ol><li><ol><li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</li><li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</li></ol></li></ol><h2 id="缓存预热" tabindex="-1"><a class="header-anchor" href="#缓存预热"><span>缓存预热</span></a></h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p><p>解决思路：</p><ol><li>写个缓存刷新页面，上线时手工操作；</li><li>数据量不大，可以在项目启动的时候自动进行加载；</li><li>定时刷新缓存；</li></ol><h2 id="主从不一致" tabindex="-1"><a class="header-anchor" href="#主从不一致"><span>主从不一致</span></a></h2><ul><li>redis的确默认是弱一致性，异步的同步</li><li>锁不能用主从、(可用单实例/分片集群/redlock)==&gt;redisson</li><li>在配置中提供了必须有多少个Client连接能同步，可以配置同步因子，趋向于强制一性</li></ul><h2 id="数据库与缓存不一致如何解决" tabindex="-1"><a class="header-anchor" href="#数据库与缓存不一致如何解决"><span>数据库与缓存不一致如何解决？</span></a></h2><ul><li><p>分布式事务（读多，写稀有情况下）</p></li><li><p>不强求一致</p></li><li><ul><li>redis是缓存，更倾向于稍微的有时差，默认是弱一致性，异步的同步</li><li>减少DB的操作</li></ul></li><li><p>完全异步化，使用<code>MQ</code></p></li><li><p>使用<code>canal binlog</code></p></li></ul><h2 id="描述一下redis持久化原理" tabindex="-1"><a class="header-anchor" href="#描述一下redis持久化原理"><span>描述一下redis持久化原理？</span></a></h2><p>当前线程阻塞服务 异步后台进程完成持久，fork + cow</p><h2 id="redis实现分布式锁的指令" tabindex="-1"><a class="header-anchor" href="#redis实现分布式锁的指令"><span>redis实现分布式锁的指令</span></a></h2><div class="language-text line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-text;"><code><span class="line"><span class="line"><span>set k v nx ex</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="缓存降级" tabindex="-1"><a class="header-anchor" href="#缓存降级"><span>缓存降级</span></a></h2><p>缓存降级是指当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，即使是有损部分其他服务，仍然需要保证主服务可用。可以将其他次要服务的数据进行缓存降级，从而提升主服务的稳定性。</p><h2 id="使用过redis分布式锁么-它是什么回事" tabindex="-1"><a class="header-anchor" href="#使用过redis分布式锁么-它是什么回事"><span>使用过Redis分布式锁么，它是什么回事？</span></a></h2><p><code>setnx + expire</code>的原子操作枪锁，也可以防止锁一直占用</p><h2 id="redis做异步队列" tabindex="-1"><a class="header-anchor" href="#redis做异步队列"><span>Redis做异步队列</span></a></h2><ul><li>一般使用list结构作为队列，<code>rpush</code>生产消息，<code>blpop</code>消费消息，<code>blpop</code>没有消息的时候，它会阻塞住直到消息到来</li><li>使用pub/sub主题订阅者模式，可以实现1:N的消息队列，在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等</li></ul><h2 id="如果有大量的key需要设置同一时间过期-一般需要注意什么" tabindex="-1"><a class="header-anchor" href="#如果有大量的key需要设置同一时间过期-一般需要注意什么"><span>如果有大量的key需要设置同一时间过期，一般需要注意什么？</span></a></h2><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的<strong>卡顿现象</strong>。一般需要在时间上加一个随机值，使得<strong>过期时间分散</strong>一些。</p><h2 id="为什么redis需要把所有数据放到内存中" tabindex="-1"><a class="header-anchor" href="#为什么redis需要把所有数据放到内存中"><span>为什么Redis需要把所有数据放到内存中？</span></a></h2><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值</p><h2 id="pipeline有什么好处-为什么要用pipeline" tabindex="-1"><a class="header-anchor" href="#pipeline有什么好处-为什么要用pipeline"><span>Pipeline有什么好处，为什么要用pipeline？</span></a></h2><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性</p><h2 id="redis-集群方案与实现" tabindex="-1"><a class="header-anchor" href="#redis-集群方案与实现"><span>Redis 集群方案与实现</span></a></h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务</p><p>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储</p><h2 id="redis持久化数据和缓存怎么做扩容" tabindex="-1"><a class="header-anchor" href="#redis持久化数据和缓存怎么做扩容"><span>Redis持久化数据和缓存怎么做扩容？</span></a></h2><ul><li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li><li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li></ul><h2 id="缓存脏读" tabindex="-1"><a class="header-anchor" href="#缓存脏读"><span>缓存脏读</span></a></h2><p>缓存的数据与数据库中不一样</p><h2 id="多级缓存" tabindex="-1"><a class="header-anchor" href="#多级缓存"><span>多级缓存</span></a></h2><ul><li>前台</li><li>中台</li><li>后台</li></ul>`,70)]))}const o=l(i,[["render",p],["__file","Redis.html.vue"]]),d=JSON.parse('{"path":"/md/interview/middleware/cache/Redis.html","title":"Redis","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Redis实现原理","slug":"redis实现原理","link":"#redis实现原理","children":[]},{"level":2,"title":"使用redis有哪些好处","slug":"使用redis有哪些好处","link":"#使用redis有哪些好处","children":[]},{"level":2,"title":"redis相比memcached有哪些优势？","slug":"redis相比memcached有哪些优势","link":"#redis相比memcached有哪些优势","children":[]},{"level":2,"title":"redis 最适合的场景","slug":"redis-最适合的场景","link":"#redis-最适合的场景","children":[]},{"level":2,"title":"redis是单线程还是多线程","slug":"redis是单线程还是多线程","link":"#redis是单线程还是多线程","children":[]},{"level":2,"title":"redis的一些其他特点","slug":"redis的一些其他特点","link":"#redis的一些其他特点","children":[]},{"level":2,"title":"MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据","slug":"mysql里有2000w数据-redis中只存20w的数据-如何保证redis中的数据都是热点数据","link":"#mysql里有2000w数据-redis中只存20w的数据-如何保证redis中的数据都是热点数据","children":[]},{"level":2,"title":"假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？","slug":"假如redis里面有1亿个key-其中有10w个key是以某个固定的已知的前缀开头的-如果将它们全部找出来","link":"#假如redis里面有1亿个key-其中有10w个key是以某个固定的已知的前缀开头的-如果将它们全部找出来","children":[]},{"level":2,"title":"Redis 常见的性能问题都有哪些？如何解决？","slug":"redis-常见的性能问题都有哪些-如何解决","link":"#redis-常见的性能问题都有哪些-如何解决","children":[]},{"level":2,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[]},{"level":2,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[]},{"level":2,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[]},{"level":2,"title":"Redis是怎么删除过期key的、缓存如何回收的？","slug":"redis是怎么删除过期key的、缓存如何回收的","link":"#redis是怎么删除过期key的、缓存如何回收的","children":[]},{"level":2,"title":"Redis的淘汰回收策略","slug":"redis的淘汰回收策略","link":"#redis的淘汰回收策略","children":[]},{"level":2,"title":"缓存预热","slug":"缓存预热","link":"#缓存预热","children":[]},{"level":2,"title":"主从不一致","slug":"主从不一致","link":"#主从不一致","children":[]},{"level":2,"title":"数据库与缓存不一致如何解决？","slug":"数据库与缓存不一致如何解决","link":"#数据库与缓存不一致如何解决","children":[]},{"level":2,"title":"描述一下redis持久化原理？","slug":"描述一下redis持久化原理","link":"#描述一下redis持久化原理","children":[]},{"level":2,"title":"redis实现分布式锁的指令","slug":"redis实现分布式锁的指令","link":"#redis实现分布式锁的指令","children":[]},{"level":2,"title":"缓存降级","slug":"缓存降级","link":"#缓存降级","children":[]},{"level":2,"title":"使用过Redis分布式锁么，它是什么回事？","slug":"使用过redis分布式锁么-它是什么回事","link":"#使用过redis分布式锁么-它是什么回事","children":[]},{"level":2,"title":"Redis做异步队列","slug":"redis做异步队列","link":"#redis做异步队列","children":[]},{"level":2,"title":"如果有大量的key需要设置同一时间过期，一般需要注意什么？","slug":"如果有大量的key需要设置同一时间过期-一般需要注意什么","link":"#如果有大量的key需要设置同一时间过期-一般需要注意什么","children":[]},{"level":2,"title":"为什么Redis需要把所有数据放到内存中？","slug":"为什么redis需要把所有数据放到内存中","link":"#为什么redis需要把所有数据放到内存中","children":[]},{"level":2,"title":"Pipeline有什么好处，为什么要用pipeline？","slug":"pipeline有什么好处-为什么要用pipeline","link":"#pipeline有什么好处-为什么要用pipeline","children":[]},{"level":2,"title":"Redis 集群方案与实现","slug":"redis-集群方案与实现","link":"#redis-集群方案与实现","children":[]},{"level":2,"title":"Redis持久化数据和缓存怎么做扩容？","slug":"redis持久化数据和缓存怎么做扩容","link":"#redis持久化数据和缓存怎么做扩容","children":[]},{"level":2,"title":"缓存脏读","slug":"缓存脏读","link":"#缓存脏读","children":[]},{"level":2,"title":"多级缓存","slug":"多级缓存","link":"#多级缓存","children":[]}],"git":{"updatedTime":1711074643000,"contributors":[{"name":"hyfly233","username":"hyfly233","email":"hyfly233@outlook.com","commits":4,"url":"https://github.com/hyfly233"}]},"filePathRelative":"md/interview/middleware/cache/Redis.md"}');export{o as comp,d as data};
