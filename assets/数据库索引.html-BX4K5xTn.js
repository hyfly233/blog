import{_ as i,c as e,f as a,o as n}from"./app-chPKMbRn.js";const s={};function h(r,l){return n(),e("div",null,l[0]||(l[0]=[a('<h1 id="数据库索引" tabindex="-1"><a class="header-anchor" href="#数据库索引"><span>数据库索引</span></a></h1><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h2><h3 id="索引的优缺点" tabindex="-1"><a class="header-anchor" href="#索引的优缺点"><span>索引的优缺点</span></a></h3><ul><li><p>优点：</p><ul><li>大大加快数据的检索速度，这也是创建索引的最主要的原因；</li><li>加速表和表之间的连接；</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li></ul></li><li><p>缺点：</p><ul><li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；</li><li>空间方面：索引需要占物理空间。</li></ul></li></ul><h3 id="索引的数据结构" tabindex="-1"><a class="header-anchor" href="#索引的数据结构"><span>索引的数据结构</span></a></h3><ul><li><p>二分查找树</p></li><li><ul><li>缺点：</li></ul></li><li><ul><li><ul><li>二分查找树进行二分查找时可能变成线性的链表结构，导致时间复杂度从 O(logN) 变为 O(N)</li></ul></li></ul></li><li><p>B- Tree结构</p></li><li><ul><li>根节点至少包括两个子节点</li><li>树中每个节点最多包含m个子节点（m &gt;= 2）</li><li>除根节点和叶子节点外，其他每个节点至少有 ceil(m/2) 个子节点（ceil 向上取整）</li><li>所有叶子节点都位于同一层</li><li>每个非终端节点中包含 n 个关键字信息，关键字按升序排序</li></ul></li><li><p>B+ Tree结构</p></li><li><ul><li>B+ Tree 是 B-Tree 的变体</li><li>非叶子节点的子树指针与关键字个数相同</li><li>非叶子节点仅用来做索引，数据全保存在叶子节点中</li></ul></li><li><p>Hash结构</p></li><li><ul><li>缺点：</li></ul></li><li><ul><li><ul><li>仅仅满足“=”、“IN”不能使用范围查询</li><li>无法被用来避免数据的排序操作</li><li>不能利用组合索引的部分索引键查询</li><li>不能避免全表扫描</li><li>遇到大量Hash值相同的情况后性能并不一定就会比B-Tree索引高</li></ul></li></ul></li><li><p>BitMap索引</p></li><li><ul><li>只有Oracle支持</li></ul></li></ul><h3 id="索引的分类" tabindex="-1"><a class="header-anchor" href="#索引的分类"><span>索引的分类</span></a></h3><ul><li><p>索引列的值的唯一性</p></li><li><ul><li>普通索引</li><li>唯一性索引</li></ul></li><li><p>索引列所包含的列数</p></li><li><ul><li>单个索引</li><li>复合索引</li></ul></li><li><p>根据叶子节点的内容</p></li><li><ul><li>主键索引：主键索引的叶子节点存的整行数据，在InnoDB里也被称为聚簇索引</li><li>非主键索引：非主键索引叶子节点存的主键的值，在InnoDB里也被称为二级索引</li></ul></li><li><p>引按照数据的物理存储进行划分</p></li><li><ul><li>聚簇索引：对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚簇索引必须是唯一的。聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了</li><li>非聚簇索引：非聚集索引是把一个很大的范围，转换成一个小的地图，然后需要在这个小地图中寻找的信息的位置，最后通过这个位置，再去找你所需要的记录</li></ul></li><li><p>密集索引、稀疏索引</p></li><li><ul><li>密集索引文件中的每个搜索码值都对应一个索引值</li><li>稀疏索引文件只为索引码的某些值建立索引项</li></ul></li></ul><h3 id="什么样的字段适合创建索引" tabindex="-1"><a class="header-anchor" href="#什么样的字段适合创建索引"><span>什么样的字段适合创建索引</span></a></h3><ul><li>经常作查询选择的字段</li><li>经常作表连接的字段</li><li>经常出现在 order by、group by、distinct 后面的字段</li></ul><h3 id="myisam-和-innodb-实现-b-树索引方式的区别是什么" tabindex="-1"><a class="header-anchor" href="#myisam-和-innodb-实现-b-树索引方式的区别是什么"><span>MyISAM 和 InnoDB 实现 B 树索引方式的区别是什么？</span></a></h3><ul><li>InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身，其数据文件本身就是索引文件</li><li>MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址，叶节点的 data 域存放的是数据记录的地址，索引文件和数据文件是分离的</li></ul><h3 id="innodb-为什么设计-b-树索引" tabindex="-1"><a class="header-anchor" href="#innodb-为什么设计-b-树索引"><span>InnoDB 为什么设计 B+ 树索引？</span></a></h3><ul><li><p>两个考虑因素：</p></li><li><ul><li>InnoDB 需要执行的场景和功能需要在特定查询上拥有较强的性能</li><li>CPU 将磁盘上的数据加载到内存中需要花费大量时间</li></ul></li><li><p>为什么选择 B+ 树：</p></li><li><ul><li>哈希索引虽然能提供O（1）复杂度查询，但对范围查询和排序却无法很好的支持，最终会导致全表扫描</li><li>B 树能够在非叶子节点存储数据，但会导致在查询连续数据可能带来更多的随机 IO</li><li>而 B+ 树的所有叶节点可以通过指针来相互连接，减少顺序遍历带来的随机 IO</li></ul></li></ul><h3 id="普通索引还是唯一索引" tabindex="-1"><a class="header-anchor" href="#普通索引还是唯一索引"><span>普通索引还是唯一索引？</span></a></h3><p>由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发建议你优先考虑非唯一索引</p><h3 id="联合索引最左匹配原则的成因" tabindex="-1"><a class="header-anchor" href="#联合索引最左匹配原则的成因"><span>联合索引最左匹配原则的成因</span></a></h3><ul><li><p>最左前缀匹配原则</p></li><li><ul><li>mysql会一直从左向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配，比如<code>a = 3 and b = 4 and c &gt; 5 and d = 6</code>，如过建立的索引顺序为<code>a、b、c、d</code>，则 d 用不到索引，若索引顺序为<code>a、b、d、c</code>则可以用到索引</li><li>= 和 in 可以乱序，索引列写的顺序可以任意</li></ul></li><li><p>mysql会对复合索引的第一个索引进行排序，然后再根据第一个索引列对第二个索引列进行排序，所以这个第二列是无序的，因此在直接对第二个索引列进行条件判断的时候，是不会使用到复合索引的</p></li></ul><h3 id="什么是覆盖索引和索引下推" tabindex="-1"><a class="header-anchor" href="#什么是覆盖索引和索引下推"><span>什么是覆盖索引和索引下推？</span></a></h3><ul><li><p>覆盖索引</p></li><li><ul><li>在某个查询里面，索引 k 已经“覆盖了”我们的查询需求，称为覆盖索引</li><li>覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</li></ul></li><li><p>索引下推</p></li><li><ul><li>MySQL 5.6 引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li></ul></li></ul><h3 id="哪些操作会导致索引失效" tabindex="-1"><a class="header-anchor" href="#哪些操作会导致索引失效"><span>哪些操作会导致索引失效？</span></a></h3><ul><li>对索引列使用左或者左右模糊匹配：也就是 <strong>like %xx</strong> 或者 <strong>like %xx%</strong> 这两种方式都会造成索引失效。原因在于查询的结果可能是多个，不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。</li><li>对索引列进行函数或表达式计算：因为索引保持的是索引字段的原始值，而不是经过函数计算的值，自然就没办法走索引。</li><li>对索引列进行隐式转换：如varchar不加单引号的话可能会自动转换为int型，相当于使用了新函数</li><li>WHERE子句的OR语句中，只要有条件列不是索引列，就会进行全表扫描</li><li>多列索引没有满足最左匹配原则</li></ul><h3 id="字符串加索引问题" tabindex="-1"><a class="header-anchor" href="#字符串加索引问题"><span>字符串加索引问题</span></a></h3><ul><li>直接创建完整索引，这样可能会比较占用空间</li><li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引</li><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题</li><li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描</li></ul><h3 id="创建索引时需要注意什么" tabindex="-1"><a class="header-anchor" href="#创建索引时需要注意什么"><span>创建索引时需要注意什么？</span></a></h3><ul><li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替空值；</li><li>取值离散大的字段：变量各个取值之间的差异程度大的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li><li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li></ul><h3 id="主键、自增主键、主键索引与唯一索引概念区别" tabindex="-1"><a class="header-anchor" href="#主键、自增主键、主键索引与唯一索引概念区别"><span>主键、自增主键、主键索引与唯一索引概念区别</span></a></h3><ul><li>主键：指字段唯一、不为空值的列；</li><li>主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；</li><li>自增主键：字段类型为数字、自增、并且是主键；</li><li>唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，但唯一索引不是主键，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。</li></ul><h3 id="主键就是聚集索引吗-主键和索引有什么区别" tabindex="-1"><a class="header-anchor" href="#主键就是聚集索引吗-主键和索引有什么区别"><span>主键就是聚集索引吗？主键和索引有什么区别？</span></a></h3><p>主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。</p><p>在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。</p><p>InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。</p><h3 id="文件索引和数据库索引为什么使用b-树" tabindex="-1"><a class="header-anchor" href="#文件索引和数据库索引为什么使用b-树"><span>文件索引和数据库索引为什么使用B+树？</span></a></h3><p>文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。</p><p>数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。</p>',35)]))}const t=i(s,[["render",h],["__file","数据库索引.html.vue"]]),u=JSON.parse('{"path":"/md/interview/database/basic/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95.html","title":"数据库索引","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"基础","slug":"基础","link":"#基础","children":[{"level":3,"title":"索引的优缺点","slug":"索引的优缺点","link":"#索引的优缺点","children":[]},{"level":3,"title":"索引的数据结构","slug":"索引的数据结构","link":"#索引的数据结构","children":[]},{"level":3,"title":"索引的分类","slug":"索引的分类","link":"#索引的分类","children":[]},{"level":3,"title":"什么样的字段适合创建索引","slug":"什么样的字段适合创建索引","link":"#什么样的字段适合创建索引","children":[]},{"level":3,"title":"MyISAM 和 InnoDB 实现 B 树索引方式的区别是什么？","slug":"myisam-和-innodb-实现-b-树索引方式的区别是什么","link":"#myisam-和-innodb-实现-b-树索引方式的区别是什么","children":[]},{"level":3,"title":"InnoDB 为什么设计 B+ 树索引？","slug":"innodb-为什么设计-b-树索引","link":"#innodb-为什么设计-b-树索引","children":[]},{"level":3,"title":"普通索引还是唯一索引？","slug":"普通索引还是唯一索引","link":"#普通索引还是唯一索引","children":[]},{"level":3,"title":"联合索引最左匹配原则的成因","slug":"联合索引最左匹配原则的成因","link":"#联合索引最左匹配原则的成因","children":[]},{"level":3,"title":"什么是覆盖索引和索引下推？","slug":"什么是覆盖索引和索引下推","link":"#什么是覆盖索引和索引下推","children":[]},{"level":3,"title":"哪些操作会导致索引失效？","slug":"哪些操作会导致索引失效","link":"#哪些操作会导致索引失效","children":[]},{"level":3,"title":"字符串加索引问题","slug":"字符串加索引问题","link":"#字符串加索引问题","children":[]},{"level":3,"title":"创建索引时需要注意什么？","slug":"创建索引时需要注意什么","link":"#创建索引时需要注意什么","children":[]},{"level":3,"title":"主键、自增主键、主键索引与唯一索引概念区别","slug":"主键、自增主键、主键索引与唯一索引概念区别","link":"#主键、自增主键、主键索引与唯一索引概念区别","children":[]},{"level":3,"title":"主键就是聚集索引吗？主键和索引有什么区别？","slug":"主键就是聚集索引吗-主键和索引有什么区别","link":"#主键就是聚集索引吗-主键和索引有什么区别","children":[]},{"level":3,"title":"文件索引和数据库索引为什么使用B+树？","slug":"文件索引和数据库索引为什么使用b-树","link":"#文件索引和数据库索引为什么使用b-树","children":[]}]}],"git":{"updatedTime":1711074643000,"contributors":[{"name":"hyfly233","username":"hyfly233","email":"hyfly233@outlook.com","commits":5,"url":"https://github.com/hyfly233"}]},"filePathRelative":"md/interview/database/basic/数据库索引.md"}');export{t as comp,u as data};
