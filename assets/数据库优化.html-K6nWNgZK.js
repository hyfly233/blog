import{_ as e,c as s,f as a,o as i}from"./app-chPKMbRn.js";const n={};function r(d,l){return i(),s("div",null,l[0]||(l[0]=[a(`<h1 id="数据库优化" tabindex="-1"><a class="header-anchor" href="#数据库优化"><span>数据库优化</span></a></h1><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h2><h3 id="sql优化" tabindex="-1"><a class="header-anchor" href="#sql优化"><span>SQL优化</span></a></h3><ul><li><p>查询优化</p></li><li><ul><li>主键查询，千万条记录，1 - 10 ms</li><li>唯一索引，千万条记录，10 - 100 ms</li><li>非唯一索引，千万条记录，100 - 1000 ms</li><li>无索引，百万条记录，1000 ms+</li></ul></li><li><p>批量写</p></li><li><ul><li>for each {insert into table values (1)}</li><li>Execute once insert into table values (1), (2), (3)</li></ul></li><li><p>索引优化</p></li><li><p><code>innodb</code>相关优化</p></li></ul><h3 id="索引优化" tabindex="-1"><a class="header-anchor" href="#索引优化"><span>索引优化</span></a></h3><ul><li>经常被查询的区分度高的列做索引</li><li>最左原则</li><li>回盘排序</li><li>覆盖索引</li><li>小表驱动大表</li></ul><h3 id="读写分离" tabindex="-1"><a class="header-anchor" href="#读写分离"><span>读写分离</span></a></h3><ul><li>一主多从</li><li>读库延迟问题处理</li><li>主从切换处理</li></ul><h3 id="分库分表" tabindex="-1"><a class="header-anchor" href="#分库分表"><span>分库分表</span></a></h3><ul><li>垂直拆分</li><li>水平拆分</li><li>多主多从</li></ul><h2 id="慢查询相关" tabindex="-1"><a class="header-anchor" href="#慢查询相关"><span>慢查询相关</span></a></h2><h3 id="如何定位并优化慢查询sql" tabindex="-1"><a class="header-anchor" href="#如何定位并优化慢查询sql"><span>如何定位并优化慢查询SQL</span></a></h3><ul><li><p>根据慢查询日志定位慢查询sql</p></li><li><ul><li>在数据库工具中查找慢日志是否打开</li></ul></li></ul><div class="language-sql line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-sql;"><code><span class="line"><span class="line"><span style="color:#D8DEE9FF;">show variables </span><span style="color:#81A1C1;">like</span><span style="color:#ECEFF4;"> &#39;</span><span style="color:#A3BE8C;">%quer%</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">;</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">//</span><span style="color:#D8DEE9FF;"> long_query_time 查询时间，超过则记录慢日志</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">//</span><span style="color:#D8DEE9FF;"> show_query_log 开启慢日志</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">//</span><span style="color:#D8DEE9FF;"> show_query_log_file 日志地址</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">show </span><span style="color:#81A1C1;">status</span><span style="color:#81A1C1;"> like</span><span style="color:#ECEFF4;"> &#39;</span><span style="color:#A3BE8C;">%slow_queries%</span><span style="color:#ECEFF4;">&#39;</span><span style="color:#D8DEE9FF;">; </span><span style="color:#81A1C1;">//</span><span style="color:#D8DEE9FF;"> 慢日志条数</span></span></span>
<span class="line"><span class="line"></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">set</span><span style="color:#81A1C1;"> global</span><span style="color:#D8DEE9FF;"> show_query_log </span><span style="color:#81A1C1;">=</span><span style="color:#81A1C1;"> on</span><span style="color:#D8DEE9FF;">; </span><span style="color:#81A1C1;">//</span><span style="color:#D8DEE9FF;"> 开启</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">set</span><span style="color:#81A1C1;"> global</span><span style="color:#D8DEE9FF;"> long_query_time </span><span style="color:#81A1C1;">=</span><span style="color:#B48EAD;"> 1</span><span style="color:#D8DEE9FF;">; </span><span style="color:#81A1C1;">//</span><span style="color:#D8DEE9FF;"> 设置查询时间，再重新连接数据库</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>使用<code>explain</code>等工具分析sql</li></ul><div class="language-sql line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-sql;"><code><span class="line"><span class="line"><span style="color:#D8DEE9FF;">explain </span><span style="color:#81A1C1;">select</span><span style="color:#D8DEE9FF;"> t1.</span><span style="color:#81A1C1;">*</span><span style="color:#81A1C1;"> from</span><span style="color:#D8DEE9FF;"> t1;</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p>explain查询的字段</p></li><li><ul><li>type：值为 index、all 就需要优化</li><li>extra：filesort、temporary 表示无法用到索引，就需要优化</li></ul></li><li><p>修改sql或者尽量让sql走索引</p></li></ul><div class="language-sql line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sql" data-title="sql"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-sql;"><code><span class="line"><span class="line"><span style="color:#81A1C1;">alter</span><span style="color:#81A1C1;"> table</span><span style="color:#D8DEE9FF;"> t1 </span><span style="color:#81A1C1;">add</span><span style="color:#81A1C1;"> index</span><span style="color:#D8DEE9FF;"> idx_name(col1); </span><span style="color:#81A1C1;">//</span><span style="color:#D8DEE9FF;"> 加索引</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>使用<code>force index</code>测试最优索引</li></ul><h2 id="性能相关" tabindex="-1"><a class="header-anchor" href="#性能相关"><span>性能相关</span></a></h2><h3 id="短时间提高-mysql-性能的方法" tabindex="-1"><a class="header-anchor" href="#短时间提高-mysql-性能的方法"><span>短时间提高 MySQL 性能的方法</span></a></h3><ul><li>第一种：先处理掉那些占着连接但是不工作的线程。或者再考虑断开事务内空闲太久的连接</li></ul><div class="language-text line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-text;"><code><span class="line"><span class="line"><span>show processlist; # 查询数据库中正在执行的线程 kill query pid; # 断开当前线程中正在执行的语句，而不断开线程连接 kill connection pid; # connection可以省略，断开该线程的连接，如果线程中有正在执行的语句，那么也会停止这个语句</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>第二种：减少连接过程的消耗，解决慢查询性能问题在 MySQL 中，慢查询大体有以下三种可能：索引没有设计好；SQL 语句没写好；MySQL选错了索引（force index）。</li></ul><h3 id="为什么-mysql-自增主键-id-不连续" tabindex="-1"><a class="header-anchor" href="#为什么-mysql-自增主键-id-不连续"><span>为什么 MySQL 自增主键 ID 不连续？</span></a></h3><ul><li>唯一键冲突</li><li>事务回滚</li><li>自增主键的批量申请</li><li>深层次原因是：MySQL 不判断自增主键是否存在，从而减少加锁的时间范围和粒度，这样能保持更高的性能，确保自增主键不能回退，所以才有自增主键不连续</li></ul><h3 id="自增主键怎么做到唯一性" tabindex="-1"><a class="header-anchor" href="#自增主键怎么做到唯一性"><span>自增主键怎么做到唯一性？</span></a></h3><p>自增值加1来通过自增锁控制并发</p><h3 id="innodb-为什么要用自增-id-作为主键" tabindex="-1"><a class="header-anchor" href="#innodb-为什么要用自增-id-作为主键"><span>InnoDB 为什么要用自增 ID 作为主键？</span></a></h3><ul><li>自增主键的插入模式，符合递增插入，每次都是追加操作，不涉及挪动记录，也不会触发叶子节点的分裂</li><li>每次插入新的记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</li><li>有业务逻辑的字段做主键，不容易保证有序插入，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置，频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，写数据成本较高</li></ul><h3 id="如何最快的复制一张表" tabindex="-1"><a class="header-anchor" href="#如何最快的复制一张表"><span>如何最快的复制一张表？</span></a></h3><p>为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表</p><ul><li>方法一：使用 mysqldump 命令将数据导出成一组 INSERT 语句</li><li>方法二：直接将结果导出成.csv 文件。MySQL 提供语法，用来将查询结果导出到服务端本地目录：<code>select * from db1.t where a&gt;900 into outfile &#39;/server_tmp/t.csv&#39;</code>，得到 .csv 导出文件后，可以用 load data 命令将数据导入到目标表 db2.t 中：<code>load data infile &#39;/server_tmp/t.csv&#39; into table db2.t;</code></li><li>方法三：物理拷贝，在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出导入表空间的方式，实现物理拷贝表的功能。</li></ul><h3 id="grant-和-flush-privileges语句" tabindex="-1"><a class="header-anchor" href="#grant-和-flush-privileges语句"><span>grant 和 flush privileges语句</span></a></h3><ul><li>grant语句会同时修改数据表和内存，判断权限的时候使用的内存数据，因此，规范使用是不需要加上 flush privileges 语句</li><li>flush privileges 语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用</li></ul><h3 id="要不要使用分区表" tabindex="-1"><a class="header-anchor" href="#要不要使用分区表"><span>要不要使用分区表？</span></a></h3><ul><li>分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。</li><li>分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的 12 个新分区创建上即可。对于没有数据的历史分区，要及时的 drop 掉。</li></ul><h3 id="join-用法" tabindex="-1"><a class="header-anchor" href="#join-用法"><span>join 用法</span></a></h3><ul><li>使用 left join 左边的表不一定是驱动表</li><li>如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面</li></ul><h3 id="mysql-有哪些自增id-各自场景是什么" tabindex="-1"><a class="header-anchor" href="#mysql-有哪些自增id-各自场景是什么"><span>MySQL 有哪些自增ID？各自场景是什么？</span></a></h3><ul><li>表的自增 ID 达到上限之后，再申请值不会变化，进而导致联系插入数据的时候报主键冲突错误。</li><li>row_id 达到上限之后，归 0 再重新递增，如果出现相同的 row_id 后写的数据会覆盖之前的数据。</li><li>Xid 只需要不在同一个 binlog 文件出现重复值即可，理论上会出现重复值，但概率极小可忽略不计。</li><li>InnoDB 的 max_trx_id 递增值每次 MySQL 重启会保存起来。</li><li>Xid 是由 server 层维护的。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。</li><li>thread_id 是使用中最常见的，而且也是处理得最好的一个自增 id 逻辑了。使用了insert_unique 算法</li></ul><h3 id="xid-在-mysql-内部是怎么生成的呢" tabindex="-1"><a class="header-anchor" href="#xid-在-mysql-内部是怎么生成的呢"><span>Xid 在 MySQL 内部是怎么生成的呢？</span></a></h3><p>MySQL 内部维护了一个全局变量 global_query_id，每次执行语句（包括select语句）的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。而 global_query_id 是一个纯内存变量，重启之后就清零了。所以在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是惟一的。</p><h3 id="什么是幻读" tabindex="-1"><a class="header-anchor" href="#什么是幻读"><span>什么是幻读？</span></a></h3><p>值在同一个事务中，存在前后两次查询同一个范围的数据，第二次看到了第一次没有查询到的数据。</p><p>幻读出现的场景：</p><ul><li>事务的隔离级别是可重复读，且是当前读。</li><li>幻读指新插入的行。</li></ul><p>幻读带来的问题：</p><ul><li>对行锁语义的破坏</li><li>破坏了数据一致性</li></ul><p>解决：</p><ul><li>加间隙锁，锁住行与行之间的间隙，阻塞新插入的操作，带来的问题：降低并发度，可能导致死锁。</li></ul><h2 id="扩容" tabindex="-1"><a class="header-anchor" href="#扩容"><span>扩容</span></a></h2><h3 id="数据库集群" tabindex="-1"><a class="header-anchor" href="#数据库集群"><span>数据库集群</span></a></h3><h3 id="水平扩容" tabindex="-1"><a class="header-anchor" href="#水平扩容"><span>水平扩容</span></a></h3><h3 id="垂直扩容" tabindex="-1"><a class="header-anchor" href="#垂直扩容"><span>垂直扩容</span></a></h3><h3 id="主主备份" tabindex="-1"><a class="header-anchor" href="#主主备份"><span>主主备份</span></a></h3><h3 id="主从备份" tabindex="-1"><a class="header-anchor" href="#主从备份"><span>主从备份</span></a></h3><h4 id="mysql-是如何保证主备同步" tabindex="-1"><a class="header-anchor" href="#mysql-是如何保证主备同步"><span>MySQL 是如何保证主备同步</span></a></h4><p>主备关系的建立：</p><ul><li>一开始创建主备关系的时候，是由备库指定的，比如基于位点的主备关系，备库说“我要从binlog文件A的位置P”开始同步，主库就从这个指定的位置开始往后发。</li><li>而主备关系搭建之后，是主库决定要发给数据给备库的，所以主库有新的日志也会发给备库。</li></ul><h4 id="todo-mysql-主备切换流程" tabindex="-1"><a class="header-anchor" href="#todo-mysql-主备切换流程"><span>todo MySQL 主备切换流程：</span></a></h4><ul><li>客户端读写都是直接访问A，而节点B是备库，只要将A的更新都同步过来，到本地执行就可以保证数据是相同的。</li><li>当需要切换的时候就把节点换一下，节点A为备库，节点B为主库</li></ul><h4 id="一个事务完整的同步过程" tabindex="-1"><a class="header-anchor" href="#一个事务完整的同步过程"><span>一个事务完整的同步过程：</span></a></h4><ul><li>备库B和主库A建立来了长链接，主库A内部专门线程用于维护了这个长链接。</li><li>在备库B上通过 changemaster 命令设置主库A的IP端口用户名密码以及从哪个位置开始请求binlog包括文件名和日志偏移量</li><li>在备库B上执行start-slave命令备库会启动两个线程：io_thread 和 sql_thread 分别负责建立连接和读取中转日志进行解析执行</li><li>备库读取主库传过来的binlog文件备库收到文件写到本地成为中转日志</li><li>后来由于多线程复制方案的引入，sql_thread演化成了多个线程。</li></ul><h4 id="什么是主备延迟" tabindex="-1"><a class="header-anchor" href="#什么是主备延迟"><span>什么是主备延迟</span></a></h4><p>主库和备库在执行同一个事务的时候出现时间差的问题，主要原因有：</p><ul><li>有些部署条件下，备库所在机器的性能要比主库性能差。</li><li>备库的压力较大。</li><li>大事务，一个主库上语句执行10分钟，那么这个事务可能会导致从库延迟10分钟。</li></ul><h4 id="为什么要有多线程复制策略" tabindex="-1"><a class="header-anchor" href="#为什么要有多线程复制策略"><span>为什么要有多线程复制策略？</span></a></h4><ul><li>因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库可能是一直追不上主库的，带来的现象就是备库上 seconds_behind_master 值越来越大。</li><li>在实际应用中，建议使用可靠性优先策略，减少主备延迟，提升系统可用性，尽量减少大事务操作，把大事务拆分小事务。</li></ul><h4 id="mysql-的并行策略有哪些" tabindex="-1"><a class="header-anchor" href="#mysql-的并行策略有哪些"><span>MySQL 的并行策略有哪些？</span></a></h4><ul><li>**按表分发策略：**如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。缺点：如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。</li><li><strong>按行分发策略：<strong>如果两个事务没有更新相同的行，它们</strong>在备库上</strong>可以并行。显然，这个模式要求 binlog 格式必须是 row。缺点：相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。</li></ul><h4 id="mysql的一主一备和一主多从有什么区别" tabindex="-1"><a class="header-anchor" href="#mysql的一主一备和一主多从有什么区别"><span>MySQL的一主一备和一主多从有什么区别？</span></a></h4><p>在一主一备的双 M 架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。</p><h4 id="主库出问题如何解决" tabindex="-1"><a class="header-anchor" href="#主库出问题如何解决"><span>主库出问题如何解决?</span></a></h4><ul><li>基于位点的主备切换：存在找同步位点这个问题，MySQL 5.6 版本引入了 GTID，彻底解决了这个困难</li><li>GTID：全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识；它由两部分组成，格式是：GTID = server_uuid:gno</li><li>每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”</li><li>在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例 B 需要的日志已经不存在，A 就拒绝把日志发给 B</li></ul><h4 id="mysql-读写分离涉及到过期读问题的几种解决方案" tabindex="-1"><a class="header-anchor" href="#mysql-读写分离涉及到过期读问题的几种解决方案"><span>MySQL 读写分离涉及到过期读问题的几种解决方案?</span></a></h4><ul><li>强制走主库方案</li><li>sleep 方案</li><li>判断主备无延迟方案</li><li>配合 semi-sync 方案</li><li>等主库位点方案</li><li>GTID 方案</li><li>实际生产中，先客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等 GTID 或等位点的方案。</li></ul><h3 id="mysql的并发链接和并发查询有什么区别" tabindex="-1"><a class="header-anchor" href="#mysql的并发链接和并发查询有什么区别"><span>MySQL的并发链接和并发查询有什么区别？</span></a></h3><ul><li>在执行show processlist的结果里，看到了几千个连接，指的是并发连接。而&quot;当前正在执行&quot;的语句，才是并发查询</li><li>并发连接数多影响的是内存，并发查询太高对CPU不利。一个机器的CPU核数有限，线程全冲进来，上下文切换的成本就会太高</li><li>所以需要设置参数 innodb_thread_concurrency 用来限制线程数，当线程数达到该参数，InnoDB 就会认为线程数用完了，会阻止其他语句进入引擎执行</li></ul><h2 id="优化相关" tabindex="-1"><a class="header-anchor" href="#优化相关"><span>优化相关</span></a></h2><h3 id="数据库表结构的优化" tabindex="-1"><a class="header-anchor" href="#数据库表结构的优化"><span>数据库表结构的优化</span></a></h3><p>数据库表结构的优化包括选择合适数据类型、表的范式的优化、表的垂直拆分和表的水平拆分等手段</p><h4 id="选择合适数据类型" tabindex="-1"><a class="header-anchor" href="#选择合适数据类型"><span>选择合适数据类型</span></a></h4><ul><li>使用较小的数据类型解决问题；</li><li>使用简单的数据类型(mysql处理int要比varchar容易)；</li><li>尽可能的使用not null 定义字段；</li><li>尽量避免使用text类型，非用不可时最好考虑分表；</li></ul><h4 id="表的范式的优化" tabindex="-1"><a class="header-anchor" href="#表的范式的优化"><span>表的范式的优化</span></a></h4><p>一般情况下，表的设计应该遵循三大范式</p><h4 id="表的垂直拆分" tabindex="-1"><a class="header-anchor" href="#表的垂直拆分"><span>表的垂直拆分</span></a></h4><p>把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段：</p><ul><li>把不常用的字段单独放在同一个表中；</li><li>把大字段独立放入一个表中；</li><li>把经常使用的字段放在一起；</li><li>这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单；</li></ul><h4 id="表的水平拆分" tabindex="-1"><a class="header-anchor" href="#表的水平拆分"><span>表的水平拆分</span></a></h4><p>表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种：</p><ul><li><p>对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值；</p></li><li><p>针对不同的hashID将数据存入不同的表中；</p></li><li><p>表的水平拆分会带来一些问题和挑战，包括跨分区表的数据查询、统计及后台报表的操作等问题，但也带来了一些切实的好处：</p></li><li><ul><li>表分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度；</li><li>表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</li></ul></li><li><p>需要把数据存放到多个数据库中，提高系统的总体可用性(分库，鸡蛋不能放在同一个篮子里)</p></li></ul><h3 id="系统配置的优化" tabindex="-1"><a class="header-anchor" href="#系统配置的优化"><span>系统配置的优化</span></a></h3><p>操作系统配置的优化：增加TCP支持的队列数</p><p>mysql配置文件优化：Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数（innodb_buffer_pool_instances）</p><h3 id="硬件的优化" tabindex="-1"><a class="header-anchor" href="#硬件的优化"><span>硬件的优化</span></a></h3><p>CPU：核心数多并且主频高的 内存：增大内存 磁盘配置和选择：磁盘性能</p>`,97)]))}const t=e(n,[["render",r],["__file","数据库优化.html.vue"]]),o=JSON.parse('{"path":"/md/interview/database/basic/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96.html","title":"数据库优化","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"优化","slug":"优化","link":"#优化","children":[{"level":3,"title":"SQL优化","slug":"sql优化","link":"#sql优化","children":[]},{"level":3,"title":"索引优化","slug":"索引优化","link":"#索引优化","children":[]},{"level":3,"title":"读写分离","slug":"读写分离","link":"#读写分离","children":[]},{"level":3,"title":"分库分表","slug":"分库分表","link":"#分库分表","children":[]}]},{"level":2,"title":"慢查询相关","slug":"慢查询相关","link":"#慢查询相关","children":[{"level":3,"title":"如何定位并优化慢查询SQL","slug":"如何定位并优化慢查询sql","link":"#如何定位并优化慢查询sql","children":[]}]},{"level":2,"title":"性能相关","slug":"性能相关","link":"#性能相关","children":[{"level":3,"title":"短时间提高 MySQL 性能的方法","slug":"短时间提高-mysql-性能的方法","link":"#短时间提高-mysql-性能的方法","children":[]},{"level":3,"title":"为什么 MySQL 自增主键 ID 不连续？","slug":"为什么-mysql-自增主键-id-不连续","link":"#为什么-mysql-自增主键-id-不连续","children":[]},{"level":3,"title":"自增主键怎么做到唯一性？","slug":"自增主键怎么做到唯一性","link":"#自增主键怎么做到唯一性","children":[]},{"level":3,"title":"InnoDB 为什么要用自增 ID 作为主键？","slug":"innodb-为什么要用自增-id-作为主键","link":"#innodb-为什么要用自增-id-作为主键","children":[]},{"level":3,"title":"如何最快的复制一张表？","slug":"如何最快的复制一张表","link":"#如何最快的复制一张表","children":[]},{"level":3,"title":"grant 和 flush privileges语句","slug":"grant-和-flush-privileges语句","link":"#grant-和-flush-privileges语句","children":[]},{"level":3,"title":"要不要使用分区表？","slug":"要不要使用分区表","link":"#要不要使用分区表","children":[]},{"level":3,"title":"join 用法","slug":"join-用法","link":"#join-用法","children":[]},{"level":3,"title":"MySQL 有哪些自增ID？各自场景是什么？","slug":"mysql-有哪些自增id-各自场景是什么","link":"#mysql-有哪些自增id-各自场景是什么","children":[]},{"level":3,"title":"Xid 在 MySQL 内部是怎么生成的呢？","slug":"xid-在-mysql-内部是怎么生成的呢","link":"#xid-在-mysql-内部是怎么生成的呢","children":[]},{"level":3,"title":"什么是幻读？","slug":"什么是幻读","link":"#什么是幻读","children":[]}]},{"level":2,"title":"扩容","slug":"扩容","link":"#扩容","children":[{"level":3,"title":"数据库集群","slug":"数据库集群","link":"#数据库集群","children":[]},{"level":3,"title":"水平扩容","slug":"水平扩容","link":"#水平扩容","children":[]},{"level":3,"title":"垂直扩容","slug":"垂直扩容","link":"#垂直扩容","children":[]},{"level":3,"title":"主主备份","slug":"主主备份","link":"#主主备份","children":[]},{"level":3,"title":"主从备份","slug":"主从备份","link":"#主从备份","children":[]},{"level":3,"title":"MySQL的并发链接和并发查询有什么区别？","slug":"mysql的并发链接和并发查询有什么区别","link":"#mysql的并发链接和并发查询有什么区别","children":[]}]},{"level":2,"title":"优化相关","slug":"优化相关","link":"#优化相关","children":[{"level":3,"title":"数据库表结构的优化","slug":"数据库表结构的优化","link":"#数据库表结构的优化","children":[]},{"level":3,"title":"系统配置的优化","slug":"系统配置的优化","link":"#系统配置的优化","children":[]},{"level":3,"title":"硬件的优化","slug":"硬件的优化","link":"#硬件的优化","children":[]}]}],"git":{"updatedTime":1711074643000,"contributors":[{"name":"hyfly233","username":"hyfly233","email":"hyfly233@outlook.com","commits":4,"url":"https://github.com/hyfly233"}]},"filePathRelative":"md/interview/database/basic/数据库优化.md"}');export{t as comp,o as data};
