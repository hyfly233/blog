import{_ as e,c as l,f as n,o as i}from"./app-chPKMbRn.js";const s={};function r(t,a){return i(),l("div",null,a[0]||(a[0]=[n(`<h2 id="锁相关" tabindex="-1"><a class="header-anchor" href="#锁相关"><span>锁相关</span></a></h2><h3 id="什么是乐观锁和悲观锁" tabindex="-1"><a class="header-anchor" href="#什么是乐观锁和悲观锁"><span>什么是乐观锁和悲观锁</span></a></h3><p>乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。</p><h3 id="聊聊-reentrantlock-吧" tabindex="-1"><a class="header-anchor" href="#聊聊-reentrantlock-吧"><span>聊聊 ReentrantLock 吧</span></a></h3><p>ReentrantLock 意为可重入锁，说起 ReentrantLock 就不得不说 AQS ，因为其底层就是使用 AQS 去实现的。 ReentrantLock有两种模式，一种是公平锁，一种是非公平锁。</p><ul><li>公平模式下等待线程入队列后会严格按照队列顺序去执行</li><li>非公平模式下等待线程入队列后有可能会出现插队情况</li></ul><p>公平锁 <img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687052025-2bf96a70-b543-496a-9fbc-2a6a8fbab5dc.png#averageHue=%23f2f2f2&amp;clientId=u00400ee8-e274-4&amp;from=paste&amp;id=u95b6a12d&amp;originHeight=822&amp;originWidth=1138&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=369367&amp;status=done&amp;style=none&amp;taskId=u5bf59363-75e7-4c56-b3cc-d24229613f5&amp;title=" alt="image.png"></p><ul><li>第一步：获取状态的 state 的值 <ul><li>如果 state=0 即代表锁没有被其它线程占用，执行第二步。</li><li>如果 state!=0 则代表锁正在被其它线程占用，执行第三步。</li></ul></li><li>第二步：判断队列中是否有线程在排队等待 <ul><li>如果不存在则直接将锁的所有者设置成当前线程，且更新状态 state 。</li><li>如果存在就入队。</li></ul></li><li>第三步：判断锁的所有者是不是当前线程 <ul><li>如果是则更新状态 state 的值。</li><li>如果不是，线程进入队列排队等待。</li></ul></li></ul><p>非公平锁 <img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051916-02b67ed2-b1b3-4391-9200-9f9f7d1c5836.png#averageHue=%23eeeeeb&amp;clientId=u00400ee8-e274-4&amp;from=paste&amp;id=ufcbce09a&amp;originHeight=1264&amp;originWidth=1148&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=209415&amp;status=done&amp;style=none&amp;taskId=u9aa5c2d5-3552-44bc-9ae8-5cc38c335d7&amp;title=" alt="image.png"></p><ul><li>获取状态的 state 的值 <ul><li>如果 state=0 即代表锁没有被其它线程占用，则设置当前锁的持有者为当前线程，该操作用 CAS 完成。</li><li>如果不为0或者设置失败，代表锁被占用进行下一步。</li></ul></li><li>此时获取 state 的值 <ul><li>如果是，则给state+1，获取锁</li><li>如果不是，则进入队列等待</li><li>如果是0，代表刚好线程释放了锁，此时将锁的持有者设为自己</li><li>如果不是0，则查看线程持有者是不是自己</li></ul></li></ul><h3 id="_24-synchronized-锁升级的过程" tabindex="-1"><a class="header-anchor" href="#_24-synchronized-锁升级的过程"><span>24.synchronized 锁升级的过程</span></a></h3><p>在 Java1.6 之前的版本中，synchronized 属于重量级锁，效率低下，锁是 cpu 一个总量级的资源，每次获取锁都要和 cpu 申请，非常消耗性能。 在 jdk1.6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Jdk1.6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁，增加了锁升级的过程，由无锁-&gt;偏向锁-&gt;自旋锁-&gt;重量级锁 <img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687052049-ef2ad665-a5b2-4845-9565-4e19613f7568.png#averageHue=%23f9f9f9&amp;clientId=u00400ee8-e274-4&amp;from=paste&amp;id=ucbace034&amp;originHeight=650&amp;originWidth=1188&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=361660&amp;status=done&amp;style=none&amp;taskId=u83be01ee-cd90-4b67-a772-95453bd41c7&amp;title=" alt="image.png"> 增加锁升级的过程主要是减少用户态到核心态的切换，提高锁的效率，从 jvm 层面优化锁</p><h3 id="synchronized关键字的用法" tabindex="-1"><a class="header-anchor" href="#synchronized关键字的用法"><span>synchronized关键字的用法？</span></a></h3><p>synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。</p><h3 id="简述synchronized-和java-util-concurrent-locks-lock的异同" tabindex="-1"><a class="header-anchor" href="#简述synchronized-和java-util-concurrent-locks-lock的异同"><span>简述synchronized 和java.util.concurrent.locks.Lock的异同？</span></a></h3><p>Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。</p><h3 id="当一个线程进入一个对象的synchronized方法a之后-其它线程是否可进入此对象的synchronized方法b" tabindex="-1"><a class="header-anchor" href="#当一个线程进入一个对象的synchronized方法a之后-其它线程是否可进入此对象的synchronized方法b"><span>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</span></a></h3><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p><h3 id="synchronized和reentrantlock的区别" tabindex="-1"><a class="header-anchor" href="#synchronized和reentrantlock的区别"><span>synchronized和ReentrantLock的区别</span></a></h3><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><ol><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知</li></ol><p>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.</p><h3 id="synchronized关键字加在静态方法和实例方法的区别" tabindex="-1"><a class="header-anchor" href="#synchronized关键字加在静态方法和实例方法的区别"><span>synchronized关键字加在静态方法和实例方法的区别?</span></a></h3><p>修饰静态方法，是对类进行加锁，如果该类中有methodA 和methodB都是被synchronized修饰的静态 方法，此时有两个线程T1、T2分别调用methodA()和methodB()，则T2会阻塞等待直到T1执行完成之后 才能执行。 修饰实例方法时，是对实例进行加锁，锁的是实例对象的对象头，如果调用同一个对象的两个不同的被 synchronized修饰的实例方法时，看到的效果和上面的一样，如果调用不同对象的两个不同的被 synchronized修饰的实例方法时，则不会阻塞。</p><h3 id="_18-countdownlatch的用法" tabindex="-1"><a class="header-anchor" href="#_18-countdownlatch的用法"><span>18.countdownlatch的用法？</span></a></h3><p>两种用法： 1、让主线程await，业务线程进行业务处理，处理完成时调用countdownLatch.countDown()， CountDownLatch实例化的时候需要根据业务去选择CountDownLatch的count; 2、让业务线程await，主线程处理完数据之后进行countdownLatch.countDown()，此时业务线程被唤 醒，然后去主线程拿数据，或者执行自己的业务逻辑。</p><h3 id="synchronize-实现原理" tabindex="-1"><a class="header-anchor" href="#synchronize-实现原理"><span>synchronize 实现原理</span></a></h3><p><a href="https://github.com/crossoverJie/Java-Interview/blob/master/MD/Synchronize.md" target="_blank" rel="noopener noreferrer">以下资源来源</a> 众所周知 Synchronize 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p><ul><li>同步普通方法，锁的是当前对象。</li><li>同步静态方法，锁的是当前 Class 对象。</li><li>同步块，锁的是 {} 中的对象。</li></ul><p>实现原理： JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。 具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。 其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。 而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。 流程图如下: <img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051874-faa73eb9-9a6a-4678-bbea-e0b517629b14.png#averageHue=%23f7f7f7&amp;clientId=u00400ee8-e274-4&amp;from=paste&amp;id=uaa1c338b&amp;originHeight=646&amp;originWidth=1808&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=185410&amp;status=done&amp;style=none&amp;taskId=u13b68d7b-3637-491c-bff0-46ad3237caa&amp;title=" alt="image.png"> synchronize 很多都称之为重量锁，JDK1.6 中对 synchronize 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁。 轻量锁 当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。 如果更新成功，当前线程就获得了锁。 如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。 如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。 不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，轻量锁就会膨胀为重量锁。 解锁 轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁) 轻量锁能提升性能的原因是： 认为大多数锁在整个同步周期都不存在竞争，所以使用 CAS 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，甚至比重量锁更慢。 偏向锁 为了进一步的降低获取锁的代价，JDK1.6 之后还引入了偏向锁。 偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。 当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。 释放锁 当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。 偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 -XX:-userBiasedLocking=false 来关闭偏向锁，并默认进入轻量锁。</p><h3 id="_23-sychornized是否是公平锁" tabindex="-1"><a class="header-anchor" href="#_23-sychornized是否是公平锁"><span>23.Sychornized是否是公平锁？</span></a></h3><p>不是公平锁 26.描述一下锁的四种状态及升级过程？ 以下是32位的对象头描述 public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } synchronized锁的膨胀过程： 当线程访问同步代码块。首先查看当前锁状态是否是偏向锁(可偏向状态) 1、如果是偏向锁： 1.1、检查当前mark word中记录是否是当前线程id，如果是当前线程id，则获得偏向锁执行同步代码 块。 1.2、如果不是当前线程id，cas操作替换线程id，替换成功获得偏向锁(线程复用)，替换失败锁撤销升 级轻量锁(同一类对象多次撤销升级达到阈值20，则批量重偏向,这个点可以稍微提一下,详见下面的注意) 2、升级轻量锁</p><h3 id="如何预防死锁" tabindex="-1"><a class="header-anchor" href="#如何预防死锁"><span>如何预防死锁</span></a></h3><ol><li>首先需要将死锁发生的是个必要条件讲出来： <ol><li>互斥条件：同一时间只能有一个线程获取资源</li><li>不可剥夺条件：一个线程已经占有的资源，在释放之前不会被其它线程抢占</li><li>请求和保持条件：线程等待过程中不会释放已占有的资源</li><li>循环等待条件：多个线程互相等待对方释放资源</li></ol></li><li>预防死锁，就是需要破坏这四个必要条件 <ol><li>由于资源互斥是资源使用的固有特性，无法改变，不讨论</li><li>破坏不可剥夺条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将 被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进 程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行</li><li>破坏请求与保持条件： <ol><li>第一种方法是，静态分配即每个进程在开始执行时就申请他所需要的全部资源</li><li>第二种是，动态分配即每个进程在申请所需要的资源时，他本身不占用系统资源</li></ol></li><li>破坏循环等待条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的 采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小 编号的进程才能申请较大编号的进程</li></ol></li></ol><h3 id="产生死锁的条件" tabindex="-1"><a class="header-anchor" href="#产生死锁的条件"><span>产生死锁的条件</span></a></h3><ol><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li><li>不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="java当中有哪几种锁" tabindex="-1"><a class="header-anchor" href="#java当中有哪几种锁"><span>Java当中有哪几种锁</span></a></h3><p>自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定 偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。 轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁</p><h3 id="简述java偏向锁" tabindex="-1"><a class="header-anchor" href="#简述java偏向锁"><span>简述Java偏向锁</span></a></h3><p>JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。 其申请流程为：</p><ul><li>首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；</li><li>判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4；</li><li>判断是否需要重偏向。如果不用的话，直接获得偏向锁；</li><li>利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。</li></ul><h3 id="简述轻量级锁" tabindex="-1"><a class="header-anchor" href="#简述轻量级锁"><span>简述轻量级锁</span></a></h3><p>轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。 其申请流程为：</p><ul><li>如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。</li><li>虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针</li><li>如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。</li><li>如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧</li><li>如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行</li><li>如果不是则说明锁对象已经被其他线程抢占。</li><li>如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。</li></ul><h3 id="简述锁优化策略" tabindex="-1"><a class="header-anchor" href="#简述锁优化策略"><span>简述锁优化策略</span></a></h3><p>即自适应自旋、锁消除、锁粗化、锁升级等策略偏。</p><h3 id="简述java的自旋锁" tabindex="-1"><a class="header-anchor" href="#简述java的自旋锁"><span>简述Java的自旋锁</span></a></h3><p>线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。</p><h3 id="简述自适应自旋锁" tabindex="-1"><a class="header-anchor" href="#简述自适应自旋锁"><span>简述自适应自旋锁</span></a></h3><p>自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。</p><h3 id="简述锁粗化" tabindex="-1"><a class="header-anchor" href="#简述锁粗化"><span>简述锁粗化</span></a></h3><p>锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。</p><h3 id="简述锁消除" tabindex="-1"><a class="header-anchor" href="#简述锁消除"><span>简述锁消除</span></a></h3><p>锁消除是一种更为彻底的优化，在编译时，Java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。</p><h3 id="简述lock与reentrantlock" tabindex="-1"><a class="header-anchor" href="#简述lock与reentrantlock"><span>简述Lock与ReentrantLock</span></a></h3><p>Lock接口是 Java并发包的顶层接口。 可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。</p><h1 id="变量的线程安全问题" tabindex="-1"><a class="header-anchor" href="#变量的线程安全问题"><span>变量的线程安全问题</span></a></h1><h2 id="成员变量和静态变量" tabindex="-1"><a class="header-anchor" href="#成员变量和静态变量"><span>成员变量和静态变量</span></a></h2><ul><li>没有共享，线程安全</li><li>被共享，分两种情况： <ul><li>只读，线程安全</li><li>有写操作，该变量是临界区，则需要考虑线程安全</li></ul></li></ul><h2 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量"><span>局部变量</span></a></h2><ul><li>局部变量本身是线程安全的</li><li>局部变量引用的对象不一定是线程安全的 <ul><li>如果该引用的对象只存在于该函数的作用域中，则是线程安全</li></ul></li></ul><div class="language-java line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-java;"><code><span class="line"><span class="line"><span style="color:#81A1C1;">public</span><span style="color:#81A1C1;"> static</span><span style="color:#81A1C1;"> void</span><span style="color:#88C0D0;"> test1</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    int</span><span style="color:#D8DEE9;"> i</span><span style="color:#81A1C1;"> =</span><span style="color:#B48EAD;"> 10</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9FF;">    i</span><span style="color:#81A1C1;">++;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">}</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>如果使用<code>return 语句</code>返回该引用对象，则需要考虑线程安全问题</li></ul><h3 id="简述as-if-serial" tabindex="-1"><a class="header-anchor" href="#简述as-if-serial"><span>简述as-if-serial</span></a></h3><p>编译器会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致</p><h3 id="简述happens-before八大规则" tabindex="-1"><a class="header-anchor" href="#简述happens-before八大规则"><span>简述happens-before八大规则</span></a></h3><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li></ul><h3 id="as-if-serial-和-happens-before-的区别" tabindex="-1"><a class="header-anchor" href="#as-if-serial-和-happens-before-的区别"><span>as-if-serial 和 happens-before 的区别</span></a></h3><p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。</p><h3 id="简述原子性操作" tabindex="-1"><a class="header-anchor" href="#简述原子性操作"><span>简述原子性操作</span></a></h3><p>一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。</p><h3 id="简述线程的可见性" tabindex="-1"><a class="header-anchor" href="#简述线程的可见性"><span>简述线程的可见性</span></a></h3><p>可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile、synchronized、final 关键字都能保证可见性。</p><h3 id="简述有序性" tabindex="-1"><a class="header-anchor" href="#简述有序性"><span>简述有序性</span></a></h3><p>虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。</p><h3 id="简述java中volatile关键字作用" tabindex="-1"><a class="header-anchor" href="#简述java中volatile关键字作用"><span>简述Java中volatile关键字作用</span></a></h3><ul><li>保证变量对所有线程的可见性。当一个线程修改了变量值，新值对于其他线程来说是立即可以得知的。</li><li>禁止指令重排。使用 volatile 变量进行写操作，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器进行重排序。</li></ul><h3 id="java线程的实现方式" tabindex="-1"><a class="header-anchor" href="#java线程的实现方式"><span>Java线程的实现方式</span></a></h3><ul><li>实现Runnable接口</li><li>继承Thread类</li><li>实现Callable接口</li></ul><h3 id="简述java线程的状态" tabindex="-1"><a class="header-anchor" href="#简述java线程的状态"><span>简述Java线程的状态</span></a></h3><p>线程状态有 NEW、RUNNABLE、BLOCK、WAITING、TIMED_WAITING、THERMINATED</p><ul><li>NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。</li><li>RUNNABLE：运行状态。表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU。</li><li>BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。</li><li>WAITING：等待状态。线程内run方法执行完Object.wait()/Thread.join()进入该状态。</li><li>TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。</li><li>TERMINATED：结束状态。线程调用完run方法进入该状态。</li></ul><h3 id="简述线程通信的方式" tabindex="-1"><a class="header-anchor" href="#简述线程通信的方式"><span>简述线程通信的方式</span></a></h3><ul><li>volatile 关键词修饰变量，保证所有线程对变量访问的可见性。</li><li>synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。</li><li>wait/notify方法</li><li>IO通信</li></ul><h3 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h3><h3 id="-1" tabindex="-1"><a class="header-anchor" href="#-1"><span></span></a></h3><h3 id="聊聊你对java并发包下unsafe类的理解" tabindex="-1"><a class="header-anchor" href="#聊聊你对java并发包下unsafe类的理解"><span>聊聊你对Java并发包下unsafe类的理解</span></a></h3><p>对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。 Java 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。</p><h3 id="java中的乐观锁与cas算法" tabindex="-1"><a class="header-anchor" href="#java中的乐观锁与cas算法"><span>Java中的乐观锁与CAS算法</span></a></h3><p>乐观锁认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。 到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。 乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。 CAS 算法的思路如下：</p><ul><li>该算法认为不同线程对变量的操作时产生竞争的情况比较少。</li><li>该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。</li><li>如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。</li><li>如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。</li></ul><h3 id="-2" tabindex="-1"><a class="header-anchor" href="#-2"><span></span></a></h3><h3 id="-3" tabindex="-1"><a class="header-anchor" href="#-3"><span></span></a></h3><h3 id="-4" tabindex="-1"><a class="header-anchor" href="#-4"><span></span></a></h3><h3 id="-5" tabindex="-1"><a class="header-anchor" href="#-5"><span></span></a></h3><h3 id="synchronized底层实现原理" tabindex="-1"><a class="header-anchor" href="#synchronized底层实现原理"><span>synchronized底层实现原理</span></a></h3><p>Java 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。 synchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。 执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。</p><h3 id="synchronized关键词使用方法" tabindex="-1"><a class="header-anchor" href="#synchronized关键词使用方法"><span>synchronized关键词使用方法</span></a></h3><ul><li>直接修饰某个实例方法</li><li>直接修饰某个静态方法</li><li>修饰代码块</li></ul><h3 id="-6" tabindex="-1"><a class="header-anchor" href="#-6"><span></span></a></h3><h3 id="-7" tabindex="-1"><a class="header-anchor" href="#-7"><span></span></a></h3><h3 id="导致java的线程池被瞬间占满的原因是什么" tabindex="-1"><a class="header-anchor" href="#导致java的线程池被瞬间占满的原因是什么"><span>导致Java的线程池被瞬间占满的原因是什么</span></a></h3><p>导致Java线程池被瞬间占满的原因有很多，以下是一些常见的原因： 1.任务队列满了：当任务队列中的任务数量超过了线程池的最大容量，新提交的任务将会被拒绝执行。这时如果不进行适当的处理，就会导致线程池被瞬间占满。 2.任务执行时间过长：当某个任务执行的时间过长时，该任务会一直占用一个线程，这会导致该线程无法执行其他任务，从而使线程池中的其他线程都处于等待状态，最终导致线程池被占满。 3.线程池配置不当：如果线程池的核心线程数和最大线程数都设置得过小，当有大量任务提交时，线程池就会被瞬间占满。 4.线程阻塞：当线程在执行任务时被阻塞，例如等待I/O操作或者等待某个锁时，该线程会一直占用一个线程资源，如果这种情况发生在多个线程上，就会导致线程池被占满。 5.资源不足：如果系统中的资源不足，例如内存不足或者文件句柄数达到了上限，就可能导致线程池被占满。 为了避免线程池被瞬间占满，可以通过合理的线程池配置、任务队列大小的调整、任务执行时间的优化等方式进行处理。同时，应该对任务的性质和系统资源的状况进行充分的了解和评估，以便对线程池的配置进行合理的调整。</p><h3 id="在spring-boot的web项目中-通过controller调用service操作数据库-需要考虑多线程问题吗" tabindex="-1"><a class="header-anchor" href="#在spring-boot的web项目中-通过controller调用service操作数据库-需要考虑多线程问题吗"><span>在Spring Boot的Web项目中，通过controller调用service操作数据库，需要考虑多线程问题吗</span></a></h3><p>在Spring Boot的Web项目中，如果在controller中调用service操作数据库，一般不需要考虑多线程问题，因为Spring框架本身就是线程安全的。 Spring框架使用了一种称为&quot;Dependency Injection（依赖注入）&quot;的技术，这种技术可以确保在同一时间只有一个线程访问每个Bean实例，避免了多线程并发访问时可能会出现的数据不一致或线程安全问题。 当然，如果在service层中有共享变量或全局变量等需要被多个线程访问的情况下，就需要考虑线程安全问题了，可以使用synchronized关键字或Lock接口来保证线程安全。 总之，在Spring Boot的Web项目中，如果使用了Spring框架的依赖注入功能，通常不需要过多考虑多线程问题，但是对于一些需要跨线程共享变量或全局状态的场景，需要考虑线程安全问题。</p><h2 id="cas-是什么" tabindex="-1"><a class="header-anchor" href="#cas-是什么"><span>cas 是什么</span></a></h2><p>cas 叫做 CompareAndSwap，比较并交换，很多地方使用到了它，比如锁升级中自旋锁就有用到，主要是通过处理器的指令来保证操作的原子性，它主要包含三个变量：</p><ul><li>1.变量内存地址</li><li>2.旧的预期值 A</li><li>3.准备设置的新值 B</li></ul><p>当一个线程需要修改一个共享变量的值，完成这个操作需要先取出共享变量的值，赋给 A，基于 A 进行计算，得到新值 B，在用预期原值 A 和内存中的共享变量值进行比较，如果相同就认为其他线程没有进行修改，而将新值写入内存 <img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1677824948632-47e0c41c-3cb4-4408-8ff8-3ae459bbe756.png#averageHue=%23f4f3f4&amp;clientId=ubefa1022-28d2-4&amp;id=wxBpv&amp;originHeight=288&amp;originWidth=774&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=18065&amp;status=done&amp;style=none&amp;taskId=ucfb5e705-fae9-4633-aa31-20b488eec84&amp;title=" alt="image.png"></p><p>CAS的缺点</p><ul><li>CPU开销比较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，又因为自旋的时候会一直占用CPU，如果CAS一直更新不成功就会一直占用，造成CPU的浪费。</li><li>ABA 问题：比如线程 A 去修改 1 这个值，修改成功了，但是中间 线程 B 也修改了这个值，但是修改后的结果还是 1，所以不影响 A 的操作，这就会有问题。可以用版本号来解决这个问题。</li><li>只能保证一个共享变量的原子性</li></ul>`,111)]))}const c=e(s,[["render",r],["__file","锁.html.vue"]]),h=JSON.parse('{"path":"/md/interview/java/multithread/%E9%94%81.html","title":"变量的线程安全问题","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"锁相关","slug":"锁相关","link":"#锁相关","children":[{"level":3,"title":"什么是乐观锁和悲观锁","slug":"什么是乐观锁和悲观锁","link":"#什么是乐观锁和悲观锁","children":[]},{"level":3,"title":"聊聊 ReentrantLock 吧","slug":"聊聊-reentrantlock-吧","link":"#聊聊-reentrantlock-吧","children":[]},{"level":3,"title":"24.synchronized 锁升级的过程","slug":"_24-synchronized-锁升级的过程","link":"#_24-synchronized-锁升级的过程","children":[]},{"level":3,"title":"synchronized关键字的用法？","slug":"synchronized关键字的用法","link":"#synchronized关键字的用法","children":[]},{"level":3,"title":"简述synchronized 和java.util.concurrent.locks.Lock的异同？","slug":"简述synchronized-和java-util-concurrent-locks-lock的异同","link":"#简述synchronized-和java-util-concurrent-locks-lock的异同","children":[]},{"level":3,"title":"当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？","slug":"当一个线程进入一个对象的synchronized方法a之后-其它线程是否可进入此对象的synchronized方法b","link":"#当一个线程进入一个对象的synchronized方法a之后-其它线程是否可进入此对象的synchronized方法b","children":[]},{"level":3,"title":"synchronized和ReentrantLock的区别","slug":"synchronized和reentrantlock的区别","link":"#synchronized和reentrantlock的区别","children":[]},{"level":3,"title":"synchronized关键字加在静态方法和实例方法的区别?","slug":"synchronized关键字加在静态方法和实例方法的区别","link":"#synchronized关键字加在静态方法和实例方法的区别","children":[]},{"level":3,"title":"18.countdownlatch的用法？","slug":"_18-countdownlatch的用法","link":"#_18-countdownlatch的用法","children":[]},{"level":3,"title":"synchronize 实现原理","slug":"synchronize-实现原理","link":"#synchronize-实现原理","children":[]},{"level":3,"title":"23.Sychornized是否是公平锁？","slug":"_23-sychornized是否是公平锁","link":"#_23-sychornized是否是公平锁","children":[]},{"level":3,"title":"如何预防死锁","slug":"如何预防死锁","link":"#如何预防死锁","children":[]},{"level":3,"title":"产生死锁的条件","slug":"产生死锁的条件","link":"#产生死锁的条件","children":[]},{"level":3,"title":"Java当中有哪几种锁","slug":"java当中有哪几种锁","link":"#java当中有哪几种锁","children":[]},{"level":3,"title":"简述Java偏向锁","slug":"简述java偏向锁","link":"#简述java偏向锁","children":[]},{"level":3,"title":"简述轻量级锁","slug":"简述轻量级锁","link":"#简述轻量级锁","children":[]},{"level":3,"title":"简述锁优化策略","slug":"简述锁优化策略","link":"#简述锁优化策略","children":[]},{"level":3,"title":"简述Java的自旋锁","slug":"简述java的自旋锁","link":"#简述java的自旋锁","children":[]},{"level":3,"title":"简述自适应自旋锁","slug":"简述自适应自旋锁","link":"#简述自适应自旋锁","children":[]},{"level":3,"title":"简述锁粗化","slug":"简述锁粗化","link":"#简述锁粗化","children":[]},{"level":3,"title":"简述锁消除","slug":"简述锁消除","link":"#简述锁消除","children":[]},{"level":3,"title":"简述Lock与ReentrantLock","slug":"简述lock与reentrantlock","link":"#简述lock与reentrantlock","children":[]}]},{"level":2,"title":"成员变量和静态变量","slug":"成员变量和静态变量","link":"#成员变量和静态变量","children":[]},{"level":2,"title":"局部变量","slug":"局部变量","link":"#局部变量","children":[{"level":3,"title":"简述as-if-serial","slug":"简述as-if-serial","link":"#简述as-if-serial","children":[]},{"level":3,"title":"简述happens-before八大规则","slug":"简述happens-before八大规则","link":"#简述happens-before八大规则","children":[]},{"level":3,"title":"as-if-serial 和 happens-before 的区别","slug":"as-if-serial-和-happens-before-的区别","link":"#as-if-serial-和-happens-before-的区别","children":[]},{"level":3,"title":"简述原子性操作","slug":"简述原子性操作","link":"#简述原子性操作","children":[]},{"level":3,"title":"简述线程的可见性","slug":"简述线程的可见性","link":"#简述线程的可见性","children":[]},{"level":3,"title":"简述有序性","slug":"简述有序性","link":"#简述有序性","children":[]},{"level":3,"title":"简述Java中volatile关键字作用","slug":"简述java中volatile关键字作用","link":"#简述java中volatile关键字作用","children":[]},{"level":3,"title":"Java线程的实现方式","slug":"java线程的实现方式","link":"#java线程的实现方式","children":[]},{"level":3,"title":"简述Java线程的状态","slug":"简述java线程的状态","link":"#简述java线程的状态","children":[]},{"level":3,"title":"简述线程通信的方式","slug":"简述线程通信的方式","link":"#简述线程通信的方式","children":[]},{"level":3,"title":"","slug":"","link":"#","children":[]},{"level":3,"title":"","slug":"-1","link":"#-1","children":[]},{"level":3,"title":"聊聊你对Java并发包下unsafe类的理解","slug":"聊聊你对java并发包下unsafe类的理解","link":"#聊聊你对java并发包下unsafe类的理解","children":[]},{"level":3,"title":"Java中的乐观锁与CAS算法","slug":"java中的乐观锁与cas算法","link":"#java中的乐观锁与cas算法","children":[]},{"level":3,"title":"","slug":"-2","link":"#-2","children":[]},{"level":3,"title":"","slug":"-3","link":"#-3","children":[]},{"level":3,"title":"","slug":"-4","link":"#-4","children":[]},{"level":3,"title":"","slug":"-5","link":"#-5","children":[]},{"level":3,"title":"synchronized底层实现原理","slug":"synchronized底层实现原理","link":"#synchronized底层实现原理","children":[]},{"level":3,"title":"synchronized关键词使用方法","slug":"synchronized关键词使用方法","link":"#synchronized关键词使用方法","children":[]},{"level":3,"title":"","slug":"-6","link":"#-6","children":[]},{"level":3,"title":"","slug":"-7","link":"#-7","children":[]},{"level":3,"title":"导致Java的线程池被瞬间占满的原因是什么","slug":"导致java的线程池被瞬间占满的原因是什么","link":"#导致java的线程池被瞬间占满的原因是什么","children":[]},{"level":3,"title":"在Spring Boot的Web项目中，通过controller调用service操作数据库，需要考虑多线程问题吗","slug":"在spring-boot的web项目中-通过controller调用service操作数据库-需要考虑多线程问题吗","link":"#在spring-boot的web项目中-通过controller调用service操作数据库-需要考虑多线程问题吗","children":[]}]},{"level":2,"title":"cas 是什么","slug":"cas-是什么","link":"#cas-是什么","children":[]}],"git":{"updatedTime":1711074643000,"contributors":[{"name":"hyfly233","username":"hyfly233","email":"hyfly233@outlook.com","commits":5,"url":"https://github.com/hyfly233"}]},"filePathRelative":"md/interview/java/multithread/锁.md"}');export{c as comp,h as data};
