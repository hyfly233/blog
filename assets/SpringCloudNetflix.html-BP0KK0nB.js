import{_ as n,c as s,f as e,o as i}from"./app-chPKMbRn.js";const a={};function r(t,l){return i(),s("div",null,l[0]||(l[0]=[e(`<h1 id="spring-cloud-netflix" tabindex="-1"><a class="header-anchor" href="#spring-cloud-netflix"><span>Spring Cloud Netflix</span></a></h1><h2 id="spring-cloud-netflix-1" tabindex="-1"><a class="header-anchor" href="#spring-cloud-netflix-1"><span>Spring Cloud Netflix</span></a></h2><p>Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件，Spring Cloud 2020.0 版本删除了Netflix除Eureka外的所有组件</p><ul><li>**Eureka：**服务治理组件，包括服务端的注册中心和客户端的服务发现机制</li><li>**Ribbon：**负载均衡的服务调用组件，具有多种负载均衡调用策略</li><li>**Hystrix：**服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力</li><li><strong>Feign：<strong>基于 Ribbon 和 Hystrix 的</strong>声明式服务调用组件</strong></li><li>**Zuul：**API网关组件，对请求提供路由及过滤功能</li></ul><h2 id="eureka" tabindex="-1"><a class="header-anchor" href="#eureka"><span>Eureka</span></a></h2><h3 id="eureka工作原理" tabindex="-1"><a class="header-anchor" href="#eureka工作原理"><span>Eureka工作原理</span></a></h3><ul><li>**Eureka：**服务注册中心(可以是一个集群)，对外暴露自己地址</li><li>**服务提供者：**启动后向 Eureka 注册自己信息(地址，提供的是什么服务)</li><li>**服务消费者：**向 Eureka 订阅服务，Eureka会将对应服务的服务列表发送给消费者，并且定期更新</li><li>**心跳(续约)：**服务提供者定期通过 http 方式向 Eureka 刷新自己的状态</li></ul><h3 id="什么是服务注册" tabindex="-1"><a class="header-anchor" href="#什么是服务注册"><span>什么是服务注册</span></a></h3><p>服务提供者在启动时，会向 EurekaServer 发起一次请求，将自己注册到 Eureka 注册中心中去</p><h3 id="什么是服务续约" tabindex="-1"><a class="header-anchor" href="#什么是服务续约"><span>什么是服务续约</span></a></h3><p>在注册服务完成以后，服务提供者会维持一个心跳(每30s定时向 EurekaServer 分发起请求)，通知 EurekaServer 当前为可用状态</p><h3 id="什么是失效剔除" tabindex="-1"><a class="header-anchor" href="#什么是失效剔除"><span>什么是失效剔除</span></a></h3><p>服务提供方并不一定是正常下线的，可能是内存溢出、网络故障等原因导致服务无法正常工作。EurekaServer 会将这些失效的服务从服务列表中剔除。因此它会开启一个定时任务，每隔60秒会对失效的服务进行一次剔除</p><h3 id="什么是自我保护" tabindex="-1"><a class="header-anchor" href="#什么是自我保护"><span>什么是自我保护</span></a></h3><p>当可能因为网络原因服务未按时进行心跳续约时，此时把服务从服务列表中剔除并不妥当，因为服务也有可能未宕机。Eureka 就会把当前实例的注册信息保护起来，不允剔除。这种方式在生产环境下很有效，保证了大多数服务依然可用</p><h3 id="不使用eureka注册中心的情况下-分布式服务必然面临的问题" tabindex="-1"><a class="header-anchor" href="#不使用eureka注册中心的情况下-分布式服务必然面临的问题"><span>不使用Eureka注册中心的情况下，分布式服务必然面临的问题</span></a></h3><ul><li><p>服务管理：</p></li><li><ul><li>如何自动注册和发现服务</li><li>如何实现服务状态的监管</li><li>如何实现动态路由，从而实现负载均衡</li></ul></li><li><p>服务如何实现负载均衡</p></li><li><p>服务如何解决容灾问题</p></li><li><p>服务如何实现统一配置</p></li></ul><h3 id="简述什么是cap-并说明eureka包含cap中的哪些" tabindex="-1"><a class="header-anchor" href="#简述什么是cap-并说明eureka包含cap中的哪些"><span>简述什么是CAP，并说明Eureka包含CAP中的哪些?</span></a></h3><ul><li>CAP理论：一个分布式系统不可能同时满足C (一致性)、A(可用性)、P(分区容错性)。由于<strong>分区容错性P</strong>在分布式系统中是必须要保证的，因此只能从A和C中进行权衡</li><li>Eureka 遵守 AP</li><li>Eureka 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务</li><li>Eureka的客户端在向某个 Eureka 注册或查询时，如果发现连接失败，则会自动切换至其他节点</li><li>只要有一台Eureka还在，就能保证注册服务可用，只不过查的信息可能不是最新的（不保证强一致性）</li></ul><h3 id="eureka的region和zone-todo" tabindex="-1"><a class="header-anchor" href="#eureka的region和zone-todo"><span>Eureka的Region和Zone todo</span></a></h3><h2 id="zuul" tabindex="-1"><a class="header-anchor" href="#zuul"><span>Zuul</span></a></h2><h3 id="什么是zuul" tabindex="-1"><a class="header-anchor" href="#什么是zuul"><span>什么是Zuul</span></a></h3><p>Zuul作为微服务系统的网关组件，是从设备和网站到后端的所有请求的前门。作为边缘服务应用程序，Zuul旨在实现动态路由，监控，弹性和安全性。Zuul包含了对请求的路由、过滤、限流三个最主要的功能，Zuul 和 Eureka进行整合时，Zuul 将自身注册为 Eureka 服务治理下的应用，同时从 Eureka 中获得其他微服务的消息，以后的访问微服务都是通过 Zuul 跳转后获得</p><ul><li>**路由：**负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口</li><li>**过滤器：**负责对请求的处理过程进行干预，可实现请求校验、服务聚合等功能</li><li>**限流：**添加 spring-cloud-zuul-ratelimit 依赖，进行流量限制</li></ul><h3 id="zuul的工作原理-todo" tabindex="-1"><a class="header-anchor" href="#zuul的工作原理-todo"><span>Zuul的工作原理 todo</span></a></h3><h3 id="zuul的作用" tabindex="-1"><a class="header-anchor" href="#zuul的作用"><span>Zuul的作用</span></a></h3><p>Zuul可以通过加载动态过滤机制，从而实现以下各项功能：</p><ul><li><strong>验证与安全保障:</strong> 识别面向各类资源的验证要求并拒绝那些与要求不符的请求</li><li><strong>审查与监控:</strong> 在边缘位置追踪有意义数据及统计结果</li><li><strong>动态路由:</strong> 以动态方式根据需要将请求路由至不同后端集群处</li><li><strong>分散压力:</strong> 逐渐增加指向集群的负载流量，从而计算性能水平</li><li><strong>负载分配:</strong> 为每一种负载类型分配对应容量，并弃用超出限定值的请求</li><li><strong>静态响应处理:</strong> 在边缘位置直接建立部分响应，从而避免其流入内部集群</li></ul><h3 id="zuul和nginx的区别" tabindex="-1"><a class="header-anchor" href="#zuul和nginx的区别"><span>Zuul和Nginx的区别</span></a></h3><ul><li><p>相同点：Zuul和Nginx都可以实现负载均衡、反向代理、过滤请求，实现网关的效果</p></li><li><p>不同点:</p></li><li><ul><li>Nginx由C语言开发，Zuul由Java开发</li><li>负载均衡：Nginx采用服务器实现负载均衡，Zuul采用Ribbon+Eureka实现本地负载均衡</li><li>Nginx相比Zuul功能会更加强大，Nginx整合一些脚本语言（lua）</li><li>Nginx适合于服务器端负载均衡，Zuul适合微服务中的网关实现</li></ul></li></ul><h3 id="zuul限流" tabindex="-1"><a class="header-anchor" href="#zuul限流"><span>Zuul限流</span></a></h3><ul><li><p>Zuul的限流算法为<strong>漏桶算法和令牌桶算法</strong>(所有的限流统一算法)</p></li><li><p>限流粒度</p></li><li><ul><li><strong>粗粒度</strong></li></ul></li><li><ul><li><ul><li>网关限流</li><li>单个服务</li></ul></li></ul></li><li><ul><li><strong>细粒度</strong></li></ul></li><li><ul><li><ul><li>**user：**认证用户或者匿名，针对某个用户粒度进行限流</li><li>**origin：**客户机的IP，针对请求客户机的IP进行限流</li><li>**url：**特定url，针对请求的url粒度进行限流</li><li>**serviceId：**特定服务，针对某个服务的id粒度进行限流</li></ul></li></ul></li></ul><h2 id="ribbon" tabindex="-1"><a class="header-anchor" href="#ribbon"><span>Ribbon</span></a></h2><h3 id="ribbon概述" tabindex="-1"><a class="header-anchor" href="#ribbon概述"><span>Ribbon概述</span></a></h3><p>Srping Cloud Ribbon是基于Netfix Ribbon实现的一套客户端负债均衡工具，Ribbon是Netflix发布的开源项目，主要功能是提供<strong>客户端的负载均衡算法</strong>。Ribbon客户端组件提供一系列完善的配置项，如：连接超时，重试等。简单的说，就是在配置文件中列出 Load Balancer 后面所有的机器，Ribbon会自动基于某种规则（如简单轮询，随机连接等）去连接这些机器</p><h3 id="ribbon常见的负载均衡算法" tabindex="-1"><a class="header-anchor" href="#ribbon常见的负载均衡算法"><span>Ribbon常见的负载均衡算法</span></a></h3><ul><li><strong>轮询(RoundRobinRule)</strong>：默认算法</li><li><strong>随机(RandomRule）</strong></li><li><strong>轮询重试(RetryRule)</strong></li><li><strong>响应速度决定权重(WeightedResponseTimeRule)</strong>：响应时间越快，权重越大</li><li><strong>最优可用(BestAvailableRule)：<strong>选择</strong>并发连接数</strong>较小的Server发送请求</li><li>**可用性过滤规则(AvailabilityFilteringRule)：**先过滤掉不可用的Server实例，再选择并发连接最小的实例</li><li>**区域内可用性能最优(ZoneAvoidanceRule)：<strong>基于</strong>可用性过滤规则(AvailabilityFilteringRule)**的基础，首先判断一个Zone的运行性能是否可用，剔除不可用的区域Zone的所有Server，然后再过滤并发连接过多的Server</li></ul><h3 id="ribbon自定义负载均衡算法" tabindex="-1"><a class="header-anchor" href="#ribbon自定义负载均衡算法"><span>Ribbon自定义负载均衡算法</span></a></h3><ol><li>实现 IRule 接口，参考 RoundRobinRule 的实现</li></ol><div class="language-java line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-java;"><code><span class="line"><span class="line"><span style="color:#ECEFF4;">@</span><span style="color:#D08770;">Configuration</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">public</span><span style="color:#81A1C1;"> class</span><span style="color:#8FBCBB;"> MyRule</span><span style="color:#81A1C1;"> implements</span><span style="color:#8FBCBB;font-weight:bold;"> IRule</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">}</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>创建 IRule 的 Bean</li></ol><div class="language-java line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-java;"><code><span class="line"><span class="line"><span style="color:#ECEFF4;">@</span><span style="color:#D08770;">Configuration</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">public</span><span style="color:#81A1C1;"> class</span><span style="color:#8FBCBB;"> MyRuleConfig</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">	@</span><span style="color:#D08770;">Bean</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    public</span><span style="color:#8FBCBB;"> IRule</span><span style="color:#88C0D0;"> myRule</span><span style="color:#ECEFF4;">()</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">        return</span><span style="color:#81A1C1;"> new</span><span style="color:#88C0D0;"> MyRule</span><span style="color:#ECEFF4;">()</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">    }</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">}</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ribbon和feign的区别" tabindex="-1"><a class="header-anchor" href="#ribbon和feign的区别"><span>Ribbon和Feign的区别</span></a></h3><p>都是调用其他服务的，但方式不同</p><ol><li>启动类注解不同：Ribbon是**@RibbonClient**，Feign的是**@EnableFeignClients**</li><li>服务指定的位置不同：Ribbon是在**@RibbonClient<strong>注解上</strong>声明负载均衡算法和使用负载均衡的Service**，Feign是在定义抽象方法的<strong>接口中</strong>使用@FeignClient声明</li><li>调用方式不同：Ribbon需要自己构建http请求，然后使用RestTemplate发送给其他服务，步骤繁琐。Feign只需要将调用的方法定义成抽象方法即可</li></ol><h3 id="ribbon-原理" tabindex="-1"><a class="header-anchor" href="#ribbon-原理"><span>Ribbon 原理</span></a></h3><p>使用HTTP通信的框架组件(如：HttpClient)，先从Ribbon的<strong>本地Eureka注册表缓存</strong>中获取服务提供者的列表，然后进行负载均衡，选出一台机器，接着针对那台机器发送 Http 请求</p><h3 id="ribbon的总体流程" tabindex="-1"><a class="header-anchor" href="#ribbon的总体流程"><span>Ribbon的总体流程</span></a></h3><p>针对被**@LoadBalanced<strong>修饰的RestTemplate，给该RestTemplate增加</strong>LoadBalancerInterceptor拦截器**，从而实现对负载均衡器的调用。负载均衡器通过服务名获取过滤后的服务列表，通过负载均衡算法获取其中某台实例，并进行调用</p><h3 id="ribbon如何选择调用哪个实例" tabindex="-1"><a class="header-anchor" href="#ribbon如何选择调用哪个实例"><span>Ribbon如何选择调用哪个实例</span></a></h3><ol><li>**获取服务列表：**为了减少服务的延迟，客户端会通过 <strong>eureka.instance.metadata-map.zone</strong> 指定的zone对服务列表进行过滤</li><li>**负载均衡：**通过负载均衡策略从服务列表中获得其中一台，默认是RoundRobinRule轮询策略，再对服务端进行调用</li></ol><h3 id="服务列表的获取过程" tabindex="-1"><a class="header-anchor" href="#服务列表的获取过程"><span>服务列表的获取过程</span></a></h3><ol><li><p>服务列表默认是基于服务发现的，在应用启动时Ribbon就会从Eureka服务器中获取所有注册服务的列表数据，并<strong>保持同步</strong>。也可以通过动态设置的方式在配置文件中进行指定</p></li><li><p>通过<strong>ServerListFilter</strong>对服务器列表进行过滤</p></li><li><ol><li>**ZoneAffinityServerListFilter：**基于区域感知的方式，实现对服务实例的过滤，仅返回与本身所处区域一直的服务提供者实例列表；</li><li><strong>ServerListSubsetFilter：<strong>该过滤器继承自ZoneAffinityServerListFilter，在进行区域感知过滤后，仅返回一个固定大小的服务列表。默认将返回20个服务实例，可以通过</strong>ribbon.ServerListSubsetFilter.size</strong>进行设置；</li><li>**ZonePreferenceServerListFilter：**Eureka和Ribbon时默认的过滤器。实现通过配置或者Eureka所属区域来过滤出同区域的服务实例列表。</li></ol></li></ol><h3 id="ribbon如何避免调用失效实例" tabindex="-1"><a class="header-anchor" href="#ribbon如何避免调用失效实例"><span>Ribbon如何避免调用失效实例</span></a></h3><ol><li>通过<strong>IPing机制</strong>检测实例，如果检测到某服务实例不存在或一定时间未响应，则会从服务列表中及时移除</li><li>保留Zone的统计数据，Ribbon可以避免可能访问失效的Zone</li></ol><h2 id="feign-todo" tabindex="-1"><a class="header-anchor" href="#feign-todo"><span>Feign todo</span></a></h2><h2 id="hystrix" tabindex="-1"><a class="header-anchor" href="#hystrix"><span>Hystrix</span></a></h2><h3 id="使用" tabindex="-1"><a class="header-anchor" href="#使用"><span>使用</span></a></h3><p>一般都是在消费端配置断路器，因为不用来回传值。需要在启动类配置的注解为：<strong>@EnableHystrix</strong></p><div class="language-java line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-java;"><code><span class="line"><span class="line"><span style="color:#ECEFF4;">@</span><span style="color:#D08770;">GetMapping</span><span style="color:#ECEFF4;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">/test/{id}</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">)</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">@</span><span style="color:#D08770;">HystrixCommand</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">fallbackMethod</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">testFallBackMethod</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9;">                commandProperties</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">                    @</span><span style="color:#D08770;">HystrixProperty</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9;">name</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">execution.isolation.thread.timeoutInMilliseconds</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">,</span><span style="color:#D8DEE9FF;"> </span></span></span>
<span class="line"><span class="line"><span style="color:#D8DEE9;">                                     value</span><span style="color:#81A1C1;"> =</span><span style="color:#ECEFF4;"> &quot;</span><span style="color:#A3BE8C;">1500</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">)</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">                })</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">public</span><span style="color:#8FBCBB;"> String</span><span style="color:#88C0D0;"> test</span><span style="color:#ECEFF4;">(@</span><span style="color:#D08770;">PathVariable</span><span style="color:#ECEFF4;">(</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#A3BE8C;">id</span><span style="color:#ECEFF4;">&quot;</span><span style="color:#ECEFF4;">)</span><span style="color:#8FBCBB;"> Integer</span><span style="color:#D8DEE9FF;"> id</span><span style="color:#ECEFF4;">)</span><span style="color:#ECEFF4;"> {</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">    return</span><span style="color:#D8DEE9;"> testService</span><span style="color:#ECEFF4;">.</span><span style="color:#88C0D0;">test</span><span style="color:#ECEFF4;">(</span><span style="color:#D8DEE9FF;">id</span><span style="color:#ECEFF4;">)</span><span style="color:#81A1C1;">;</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">}</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置的文件为application.yml：</p><div class="language-yaml line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="yml" data-title="yml"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-yaml;"><code><span class="line"><span class="line"><span style="color:#8FBCBB;">feign</span><span style="color:#ECEFF4;">:</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">	hystrix</span><span style="color:#ECEFF4;">:</span></span></span>
<span class="line"><span class="line"><span style="color:#8FBCBB;">		enabled</span><span style="color:#ECEFF4;">:</span><span style="color:#81A1C1;"> true</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="hystrix简介" tabindex="-1"><a class="header-anchor" href="#hystrix简介"><span>Hystrix简介</span></a></h3><ul><li>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix 能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，从而提高分布式系统的稳定性</li><li><strong>断路器</strong>本身是一种开关装置，当某个服务单元发送故障之后，通过断路器的<strong>故障监控</strong>(类似熔断保险丝)，向调用方返回一个<strong>符合预期的、可处理的备选响应</strong>(FallBack)，<strong>而不是长时间的等待或抛出调用方无法处理的异常</strong>，这样就保证了<strong>服务调用方的线程不会被长时间、不必要地占用</strong>，从而避免了故障在分布式系统中的蔓延，乃至雪崩</li></ul><h3 id="hystrix的提供的功能" tabindex="-1"><a class="header-anchor" href="#hystrix的提供的功能"><span>Hystrix的提供的功能</span></a></h3><p>资源隔离、限流、熔断、降级、运维监控</p><h3 id="为什么要使用断路器hystrix" tabindex="-1"><a class="header-anchor" href="#为什么要使用断路器hystrix"><span>为什么要使用断路器Hystrix</span></a></h3><p>在微服务架构中，将业务拆分成一个个的服务，服务与服务之间可以相互调用。为了保证其高可用，单个服务有必须集群部署。由于<strong>网络原因</strong>或者<strong>自身的原因</strong>，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现<strong>网络延迟</strong>，此时若有大量的网络请求涌入，会形成<strong>任务累计</strong>，导致服务瘫痪，甚至导致<strong>服务雪崩</strong>。为了解决这个问题出现了短路器，相当于现实生活中的保险丝，用于保障系统的稳定性</p><h3 id="hystrix重要概念" tabindex="-1"><a class="header-anchor" href="#hystrix重要概念"><span>Hystrix重要概念</span></a></h3><ul><li><p>服务降级：服务器忙，不让客户端等待并立刻返回一个友好提示，<strong>fallback</strong></p></li><li><ul><li>出现降级的情况：</li></ul></li><li><ul><li><ul><li>程序运行异常</li><li>超时</li><li>线程池 / 信号量打满导致服务降级</li><li>服务熔断触发服务降级</li></ul></li></ul></li><li><p>服务熔断：类似保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示</p></li><li><p>服务限流：秒杀高并发等操作，严禁大量的流量直接涌入</p></li></ul><h3 id="什么是服务雪崩" tabindex="-1"><a class="header-anchor" href="#什么是服务雪崩"><span>什么是服务雪崩</span></a></h3><ul><li>多个服务之间调用的时候，假设服务A调用服务B和服务C，服务B和服务C又调用其他的服务，这就是所谓的<strong>扇出</strong>。如果扇出的链路上某个服务调用<strong>响应时间过长或者不可用</strong>，对服务A的调用就会<strong>占用越来越多的系统资源</strong>，<strong>进而引起系统崩溃</strong>，所谓的<strong>雪崩效应</strong>。</li><li>对于<strong>高流量的应用</strong>来说，<strong>单一</strong>的后端依赖可能会导致所有服务器上的<strong>所有资源</strong>都在<strong>几秒钟内饱和</strong>。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列、线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</li><li>通常当发现一个模块下的某个实例失败后，这时候这个模块依然还会接受流量，然后这个<strong>有问题的模块还调用了其他的模块</strong>，这样就会发生<strong>级联故障</strong>及<strong>服务雪崩</strong>。</li><li>要避免级联故障，需要有一种<strong>链路中断</strong>的方案：<strong>服务降级</strong>、<strong>服务熔断</strong></li></ul><h3 id="hystrix的总体流程" tabindex="-1"><a class="header-anchor" href="#hystrix的总体流程"><span>Hystrix的总体流程</span></a></h3><ol><li>【入口】通过<strong>HystrixCommand</strong>和<strong>HystrixCollapser</strong>注解修饰的方法，会被<strong>HystrixCommandAspect</strong>进行AOP处理</li><li>【缓存】如<strong>RequestCache</strong>打开，则判断缓存是否命中</li><li>【熔断】判断是否有被开关、熔断降级；若被降级，则走降级逻辑；若未被降级，则走正常逻辑</li><li>【隔离】根据配置走<strong>线程池隔离</strong>或<strong>信号量隔离</strong>，任务满则走降级逻辑</li><li>【执行】执行任务，若任务执行失败或异常，则进入降级逻辑</li><li>【超时】通过<strong>定时器延时任务</strong>检测业务调用执行是否超时，若超时则<strong>取消业务执行</strong>的线程，进入降级逻辑；若未超时，则正常返回</li><li>【降级】若进入降级逻辑，根据**getFallback()**方法，返回降级处理的数据，<strong>若未实现该方法，则返回异常</strong></li><li>【统计】业务调用执行结果成功、失败、超时等均会进入统计模块，<strong>通过健康统计结果来决定熔断器打开或关闭</strong></li></ol><h3 id="requestcache是什么" tabindex="-1"><a class="header-anchor" href="#requestcache是什么"><span>RequestCache是什么</span></a></h3><p><strong>缓存在高并发的环境下使用，能够有效地减少服务器的压力</strong>，使用Hystrix返回结果缓存，后续请求可以直接调用缓存数据，该缓存就是 RequestCache。Hystrix 通过参数 <strong>requestCache.enabled</strong> 设置是否缓存请求，默认值true</p><h3 id="hystrix的开关降级如何实现" tabindex="-1"><a class="header-anchor" href="#hystrix的开关降级如何实现"><span>Hystrix的开关降级如何实现</span></a></h3><p>开关降级的参数：</p><ul><li><strong>circuitBreaker.forceOpen：<strong>熔断器</strong>强制打开</strong>，该状态下它将拒绝所有请求，默认值 false。</li><li><strong>circuitBreaker.forceClosed：<strong>熔断器</strong>强制关闭</strong>，在此状态下，无论错误百分比如何，它都将允许请求，默认值 false。</li></ul><h3 id="hystrix的超时降级如何实现" tabindex="-1"><a class="header-anchor" href="#hystrix的超时降级如何实现"><span>Hystrix的超时降级如何实现</span></a></h3><p>超时降级的参数：</p><ul><li>**execution.timeout.enabled：**是否启用超时时间，默认值为true</li><li>**execution.isolationthread.timeoutInMilliseconds：**超时时间，默认值为1000</li><li>**execution.isolation.thread.interruptOnTimeout：**超时后是否允许中断 interrupt，默认为 true</li><li>**execution.isolation.thread.interruptOnCancel：**关闭 cancel 后是否中断 interrupt，默认为 false</li></ul><h3 id="hystrix的熔断降级如何实现" tabindex="-1"><a class="header-anchor" href="#hystrix的熔断降级如何实现"><span>Hystrix的熔断降级如何实现</span></a></h3><p>熔断降级的参数：</p><ul><li><strong>circuitBreaker.requestVolumeThreshold：触发熔断判断</strong>的<strong>请求次数阈值</strong>，<strong>默认值为20，<strong>是一段时间内</strong>至少</strong>有20个请求才进行熔断降级计算。如一段时间有19个请求全部失败，错误率是100%，但熔断器不会打开，因为总请求数不满足20</li><li><strong>circuitBreaker.sleepWindowInMilliseconds：半开状态试探睡眠时间</strong>，默认值5000ms，如熔断器开启5000ms后，会尝试放过去一部分流量<strong>进行试探</strong>，确定依赖服务是否恢复</li><li>**circuitBreaker.errorThresholdPersentage：**错误率，默认值50%，例如一段时间（10s）内有100个请求，其中有54个超时或者有异常，则错误率是54%，大于默认值50%，这种情况下触发熔断器开关</li></ul><h3 id="线程池隔离与信号量隔离的选型" tabindex="-1"><a class="header-anchor" href="#线程池隔离与信号量隔离的选型"><span>线程池隔离与信号量隔离的选型</span></a></h3><p>线程池隔离和信号量隔离是<strong>用于限制调用分布式服务的资源使用，某一个调用的服务出现问题不会影响其他服务调用</strong>，通过 <strong>hystrix.command.default.execution.isolation.strategy</strong> 配置隔离策略，可选 Thread、Semaphore，默认是 Thread</p><ul><li><strong>线程隔离（Thread）：<strong>使用该方式</strong>HystrixCommand</strong>将会在<strong>单独的线程上执行</strong>，<strong>并发请求受线程池中线程数量的限制</strong></li><li><strong>信号量隔离（Semaphore）：<strong>使用该方式</strong>HystrixCommand</strong>将会在<strong>调用线程上执行</strong>，开销相对较小，<strong>并发请求受信号量的个数的限制</strong></li></ul>`,88)]))}const p=n(a,[["render",r],["__file","SpringCloudNetflix.html.vue"]]),u=JSON.parse('{"path":"/md/interview/java/framework/springcloud/SpringCloudNetflix.html","title":"Spring Cloud Netflix","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Spring Cloud Netflix","slug":"spring-cloud-netflix-1","link":"#spring-cloud-netflix-1","children":[]},{"level":2,"title":"Eureka","slug":"eureka","link":"#eureka","children":[{"level":3,"title":"Eureka工作原理","slug":"eureka工作原理","link":"#eureka工作原理","children":[]},{"level":3,"title":"什么是服务注册","slug":"什么是服务注册","link":"#什么是服务注册","children":[]},{"level":3,"title":"什么是服务续约","slug":"什么是服务续约","link":"#什么是服务续约","children":[]},{"level":3,"title":"什么是失效剔除","slug":"什么是失效剔除","link":"#什么是失效剔除","children":[]},{"level":3,"title":"什么是自我保护","slug":"什么是自我保护","link":"#什么是自我保护","children":[]},{"level":3,"title":"不使用Eureka注册中心的情况下，分布式服务必然面临的问题","slug":"不使用eureka注册中心的情况下-分布式服务必然面临的问题","link":"#不使用eureka注册中心的情况下-分布式服务必然面临的问题","children":[]},{"level":3,"title":"简述什么是CAP，并说明Eureka包含CAP中的哪些?","slug":"简述什么是cap-并说明eureka包含cap中的哪些","link":"#简述什么是cap-并说明eureka包含cap中的哪些","children":[]},{"level":3,"title":"Eureka的Region和Zone todo","slug":"eureka的region和zone-todo","link":"#eureka的region和zone-todo","children":[]}]},{"level":2,"title":"Zuul","slug":"zuul","link":"#zuul","children":[{"level":3,"title":"什么是Zuul","slug":"什么是zuul","link":"#什么是zuul","children":[]},{"level":3,"title":"Zuul的工作原理 todo","slug":"zuul的工作原理-todo","link":"#zuul的工作原理-todo","children":[]},{"level":3,"title":"Zuul的作用","slug":"zuul的作用","link":"#zuul的作用","children":[]},{"level":3,"title":"Zuul和Nginx的区别","slug":"zuul和nginx的区别","link":"#zuul和nginx的区别","children":[]},{"level":3,"title":"Zuul限流","slug":"zuul限流","link":"#zuul限流","children":[]}]},{"level":2,"title":"Ribbon","slug":"ribbon","link":"#ribbon","children":[{"level":3,"title":"Ribbon概述","slug":"ribbon概述","link":"#ribbon概述","children":[]},{"level":3,"title":"Ribbon常见的负载均衡算法","slug":"ribbon常见的负载均衡算法","link":"#ribbon常见的负载均衡算法","children":[]},{"level":3,"title":"Ribbon自定义负载均衡算法","slug":"ribbon自定义负载均衡算法","link":"#ribbon自定义负载均衡算法","children":[]},{"level":3,"title":"Ribbon和Feign的区别","slug":"ribbon和feign的区别","link":"#ribbon和feign的区别","children":[]},{"level":3,"title":"Ribbon 原理","slug":"ribbon-原理","link":"#ribbon-原理","children":[]},{"level":3,"title":"Ribbon的总体流程","slug":"ribbon的总体流程","link":"#ribbon的总体流程","children":[]},{"level":3,"title":"Ribbon如何选择调用哪个实例","slug":"ribbon如何选择调用哪个实例","link":"#ribbon如何选择调用哪个实例","children":[]},{"level":3,"title":"服务列表的获取过程","slug":"服务列表的获取过程","link":"#服务列表的获取过程","children":[]},{"level":3,"title":"Ribbon如何避免调用失效实例","slug":"ribbon如何避免调用失效实例","link":"#ribbon如何避免调用失效实例","children":[]}]},{"level":2,"title":"Feign todo","slug":"feign-todo","link":"#feign-todo","children":[]},{"level":2,"title":"Hystrix","slug":"hystrix","link":"#hystrix","children":[{"level":3,"title":"使用","slug":"使用","link":"#使用","children":[]},{"level":3,"title":"Hystrix简介","slug":"hystrix简介","link":"#hystrix简介","children":[]},{"level":3,"title":"Hystrix的提供的功能","slug":"hystrix的提供的功能","link":"#hystrix的提供的功能","children":[]},{"level":3,"title":"为什么要使用断路器Hystrix","slug":"为什么要使用断路器hystrix","link":"#为什么要使用断路器hystrix","children":[]},{"level":3,"title":"Hystrix重要概念","slug":"hystrix重要概念","link":"#hystrix重要概念","children":[]},{"level":3,"title":"什么是服务雪崩","slug":"什么是服务雪崩","link":"#什么是服务雪崩","children":[]},{"level":3,"title":"Hystrix的总体流程","slug":"hystrix的总体流程","link":"#hystrix的总体流程","children":[]},{"level":3,"title":"RequestCache是什么","slug":"requestcache是什么","link":"#requestcache是什么","children":[]},{"level":3,"title":"Hystrix的开关降级如何实现","slug":"hystrix的开关降级如何实现","link":"#hystrix的开关降级如何实现","children":[]},{"level":3,"title":"Hystrix的超时降级如何实现","slug":"hystrix的超时降级如何实现","link":"#hystrix的超时降级如何实现","children":[]},{"level":3,"title":"Hystrix的熔断降级如何实现","slug":"hystrix的熔断降级如何实现","link":"#hystrix的熔断降级如何实现","children":[]},{"level":3,"title":"线程池隔离与信号量隔离的选型","slug":"线程池隔离与信号量隔离的选型","link":"#线程池隔离与信号量隔离的选型","children":[]}]}],"git":{"updatedTime":1711074643000,"contributors":[{"name":"hyfly233","username":"hyfly233","email":"hyfly233@outlook.com","commits":4,"url":"https://github.com/hyfly233"}]},"filePathRelative":"md/interview/java/framework/springcloud/SpringCloudNetflix.md"}');export{p as comp,u as data};
