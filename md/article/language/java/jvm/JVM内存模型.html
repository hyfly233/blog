<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.19" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>JVM 内存模型详解 | とんぼの気持ち</title><meta name="description" content="">
    <link rel="preload" href="/blog/assets/style-nxaj3WOG.css" as="style"><link rel="stylesheet" href="/blog/assets/style-nxaj3WOG.css">
    <link rel="modulepreload" href="/blog/assets/app-chPKMbRn.js"><link rel="modulepreload" href="/blog/assets/JVM内存模型.html-CZyniu0B.js">
    <link rel="prefetch" href="/blog/assets/directory.html-CM077g0X.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-WkqGtERh.js" as="script"><link rel="prefetch" href="/blog/assets/directory.html-BH0WGkAw.js" as="script"><link rel="prefetch" href="/blog/assets/CephAnsible扩充OSD节点.html-DQGhyA8S.js" as="script"><link rel="prefetch" href="/blog/assets/CephAnsible的OSD存储满后的临时解决方案.html-BDuF8Lky.js" as="script"><link rel="prefetch" href="/blog/assets/CephAnsible部署Ceph.html-B1ua_UqN.js" as="script"><link rel="prefetch" href="/blog/assets/iSCSI安装.html-HVTL7fJU.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BceON7lL.js" as="script"><link rel="prefetch" href="/blog/assets/如何升级系统构架.html-B16ubYTA.js" as="script"><link rel="prefetch" href="/blog/assets/如何正确加锁.html-DjvlAowS.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-C3nYQ7aQ.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BmNefUmR.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DJsvdjYt.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BlgG4jCN.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bp1xrcuH.js" as="script"><link rel="prefetch" href="/blog/assets/linear_search.html-Dr3lRrFe.js" as="script"><link rel="prefetch" href="/blog/assets/binary_tree_sort.html-BZSaHXpo.js" as="script"><link rel="prefetch" href="/blog/assets/bitonic_sort.html-DZHRyZF8.js" as="script"><link rel="prefetch" href="/blog/assets/bubble_sort.html-XLBBj8rD.js" as="script"><link rel="prefetch" href="/blog/assets/bucket_sort.html-D1NDEl5q.js" as="script"><link rel="prefetch" href="/blog/assets/cocktail_shaker_sort.html-sQF3C84o.js" as="script"><link rel="prefetch" href="/blog/assets/comb_sort.html-B6Z7wIqt.js" as="script"><link rel="prefetch" href="/blog/assets/counting_sort.html-D8wkfUEd.js" as="script"><link rel="prefetch" href="/blog/assets/gnome_sort.html-ClFIwPrf.js" as="script"><link rel="prefetch" href="/blog/assets/heap_sort.html-Rp3rKaBj.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DSXsiBgb.js" as="script"><link rel="prefetch" href="/blog/assets/insertion_sort.html-Cb45Fk0s.js" as="script"><link rel="prefetch" href="/blog/assets/merge_sort.html-DKhyfHNj.js" as="script"><link rel="prefetch" href="/blog/assets/odd_even_sort.html-BUUtGCfM.js" as="script"><link rel="prefetch" href="/blog/assets/pancake_sort.html-CLbqQfeK.js" as="script"><link rel="prefetch" href="/blog/assets/quick_sort.html-DsTl6rI_.js" as="script"><link rel="prefetch" href="/blog/assets/radix_sort.html-DGfsIMQr.js" as="script"><link rel="prefetch" href="/blog/assets/selection_sort.html-CWB7HCPo.js" as="script"><link rel="prefetch" href="/blog/assets/shell_sort.html-RYeqqTj9.js" as="script"><link rel="prefetch" href="/blog/assets/smooth_sort.html-B0t6JSLd.js" as="script"><link rel="prefetch" href="/blog/assets/stooge_sort.html-YfhFB3iG.js" as="script"><link rel="prefetch" href="/blog/assets/tim_sort.html-BoCSzhxx.js" as="script"><link rel="prefetch" href="/blog/assets/ESXI虚机迁移至OpenStack.html-6EM4grfG.js" as="script"><link rel="prefetch" href="/blog/assets/Kolla使用Libvirt.html-BH6Q3PvO.js" as="script"><link rel="prefetch" href="/blog/assets/Kolla及Ceph部署.html-DBRpVcxj.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BlM2okaw.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DuySOOS7.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-COYjVXza.js" as="script"><link rel="prefetch" href="/blog/assets/环境搭建.html-BwslABub.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bk5wCQBA.js" as="script"><link rel="prefetch" href="/blog/assets/Schema变更.html-CmXDyeR-.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bl4wowJu.js" as="script"><link rel="prefetch" href="/blog/assets/动态分区和RoutineLoad.html-BYzTxZd0.js" as="script"><link rel="prefetch" href="/blog/assets/存算分离.html-9GVDpuqQ.js" as="script"><link rel="prefetch" href="/blog/assets/数据划分.html-yeEAwxQ-.js" as="script"><link rel="prefetch" href="/blog/assets/数据库建表最佳实践.html-CU31WBJ2.js" as="script"><link rel="prefetch" href="/blog/assets/日志存储最佳实践.html-BJPmJmHB.js" as="script"><link rel="prefetch" href="/blog/assets/表模型.html-lvuDP8dJ.js" as="script"><link rel="prefetch" href="/blog/assets/表索引.html-Ck9S3vCk.js" as="script"><link rel="prefetch" href="/blog/assets/表设计.html-tk_DoCsV.js" as="script"><link rel="prefetch" href="/blog/assets/集群部署.html-4idh13Cl.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Cth5DVaR.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-ZicgUK5U.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DoXHiDiT.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CrHNcY8F.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CUx8GfJe.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BHVKGkTF.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-COz27HnP.js" as="script"><link rel="prefetch" href="/blog/assets/query.html-DoPeGCPi.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-w3kLOssO.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DTpqBRxQ.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BxORDID2.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-k7IOKuSo.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CQB9Z0b8.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-EtRq-J4i.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-JVp3vOGH.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DQBe6C8G.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BHiZJrZY.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DIai_jYU.js" as="script"><link rel="prefetch" href="/blog/assets/TerraformFramework实现Provider.html-DmR-BbHm.js" as="script"><link rel="prefetch" href="/blog/assets/Terraform命令.html-CSe_xkG9.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-B-1hZwCU.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DCKXXjZh.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-C0awBswM.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Wn39Nn3s.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bzvj5tms.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BE5TLZ79.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BH9xzrDi.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-fENjPdqb.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DBCYo0z6.js" as="script"><link rel="prefetch" href="/blog/assets/Rsyslog日志转存.html-VynoGpA4.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-49epSqc8.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-B_flGDt0.js" as="script"><link rel="prefetch" href="/blog/assets/SeaTunnel数据库CDC配置.html-ON8CoGPS.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-ChXgdJTg.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bc5oNQiy.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-B-dcPYv2.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Ck1dZsqe.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-3t4G-zts.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-KRPZcEBU.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-RQaezZK1.js" as="script"><link rel="prefetch" href="/blog/assets/ZabbixAgent安装及自定义脚本.html-DKURZalB.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-C29L2VNh.js" as="script"><link rel="prefetch" href="/blog/assets/zabbix安装.html-FEQL6thK.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-R3ii_NIK.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-C5_B4zlm.js" as="script"><link rel="prefetch" href="/blog/assets/SQL.html-89x0k9Cm.js" as="script"><link rel="prefetch" href="/blog/assets/数据库优化.html-K6nWNgZK.js" as="script"><link rel="prefetch" href="/blog/assets/数据库索引.html-BX4K5xTn.js" as="script"><link rel="prefetch" href="/blog/assets/数据库锁与事务.html-CS8d_ANn.js" as="script"><link rel="prefetch" href="/blog/assets/Mybatis.html-CIkBxdDk.js" as="script"><link rel="prefetch" href="/blog/assets/Java基础.html-D_QRBbpt.js" as="script"><link rel="prefetch" href="/blog/assets/Java调优.html-B4RoEDf7.js" as="script"><link rel="prefetch" href="/blog/assets/Java进阶.html-Db99JmhM.js" as="script"><link rel="prefetch" href="/blog/assets/反射.html-B9fatXTn.js" as="script"><link rel="prefetch" href="/blog/assets/线程池.html-CxbSCpUd.js" as="script"><link rel="prefetch" href="/blog/assets/锁.html-B6SpjkfJ.js" as="script"><link rel="prefetch" href="/blog/assets/集合.html-CUZ1m7It.js" as="script"><link rel="prefetch" href="/blog/assets/面向对象.html-UMaUbHDD.js" as="script"><link rel="prefetch" href="/blog/assets/jvm.html-BWNS3e3B.js" as="script"><link rel="prefetch" href="/blog/assets/JUC.html-DLUivWNX.js" as="script"><link rel="prefetch" href="/blog/assets/ThreadLocal.html-BYxYh7yT.js" as="script"><link rel="prefetch" href="/blog/assets/多线程.html-BmpsxTLI.js" as="script"><link rel="prefetch" href="/blog/assets/线程池.html-DwozZdb4.js" as="script"><link rel="prefetch" href="/blog/assets/锁.html--5qDdUfD.js" as="script"><link rel="prefetch" href="/blog/assets/Redis.html-BsKKSiRX.js" as="script"><link rel="prefetch" href="/blog/assets/ElasticSearch.html-Pn1J3Cur.js" as="script"><link rel="prefetch" href="/blog/assets/JVM.html-DNvsmY-J.js" as="script"><link rel="prefetch" href="/blog/assets/JVM对高效并发的支持.html-eb1cM9Dq.js" as="script"><link rel="prefetch" href="/blog/assets/JVM工具和JVM调优.html--xINkAvq.js" as="script"><link rel="prefetch" href="/blog/assets/垃圾回收.html-WnvI2chO.js" as="script"><link rel="prefetch" href="/blog/assets/Spring.html-B4O33Fe1.js" as="script"><link rel="prefetch" href="/blog/assets/SpringBoot.html-O44ccL2x.js" as="script"><link rel="prefetch" href="/blog/assets/SpringMvc.html-C8kgBqP7.js" as="script"><link rel="prefetch" href="/blog/assets/SpringCloud.html-DTSK6rgN.js" as="script"><link rel="prefetch" href="/blog/assets/SpringCloudAlibaba.html-BXlIalpv.js" as="script"><link rel="prefetch" href="/blog/assets/SpringCloudNetflix.html-BP0KK0nB.js" as="script"><link rel="prefetch" href="/blog/assets/Zookeeper.html-BlOTU2g8.js" as="script"><link rel="prefetch" href="/blog/assets/分布式事务.html-BphbxoLK.js" as="script"><link rel="prefetch" href="/blog/assets/分布式锁.html-CgINm6oC.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-5cdhF5yj.js" as="script"><link rel="prefetch" href="/blog/assets/setupDevtools-7MC2TMWH-CYpgxpoD.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/blog/"><img class="vp-site-logo" src="/blog/assets/img/game.ico" alt="とんぼの気持ち"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">とんぼの気持ち</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/blog/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="八股文"><span class="title">八股文</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="八股文"><span class="title">八股文</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>Spring Cloud</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloud.html" aria-label="Spring Cloud"><!---->Spring Cloud<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloudAlibaba.html" aria-label="Spring Cloud Alibaba"><!---->Spring Cloud Alibaba<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloudNetflix.html" aria-label="Spring Cloud Netflix"><!---->Spring Cloud Netflix<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>Zookeeper</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/Zookeeper.html" aria-label="Zookeeper"><!---->Zookeeper<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>分布式锁</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/分布式锁.html" aria-label="分布式锁"><!---->分布式锁<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>分布式事务</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/分布式事务.html" aria-label="分布式事务"><!---->分布式事务<!----></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/hyfly233/blog" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/blog/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="八股文"><span class="title">八股文</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="八股文"><span class="title">八股文</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>Spring Cloud</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloud.html" aria-label="Spring Cloud"><!---->Spring Cloud<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloudAlibaba.html" aria-label="Spring Cloud Alibaba"><!---->Spring Cloud Alibaba<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloudNetflix.html" aria-label="Spring Cloud Netflix"><!---->Spring Cloud Netflix<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>Zookeeper</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/Zookeeper.html" aria-label="Zookeeper"><!---->Zookeeper<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>分布式锁</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/分布式锁.html" aria-label="分布式锁"><!---->分布式锁<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>分布式事务</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/分布式事务.html" aria-label="分布式事务"><!---->分布式事务<!----></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/hyfly233/blog" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">JVM 内存模型详解 <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><h2 id="jvm-的简化架构" tabindex="-1"><a class="header-anchor" href="#jvm-的简化架构"><span>JVM 的简化架构</span></a></h2><p>JVM 的简化架构，内存区域被称为运行时数据区 <img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681136814886-240288f8-3b94-461e-9fa2-4bfcebf5e5fe.png#averageHue=%23d1a985&amp;clientId=u35c67d1a-373a-4&amp;from=ui&amp;id=tzWmT&amp;originHeight=1044&amp;originWidth=1400&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=505683&amp;status=done&amp;style=none&amp;taskId=u272586e2-5a21-4584-a572-ad7f48b6dd9&amp;title=" alt="Snipaste_2023-04-10_22-26-17.png"></p><h3 id="运行时数据区" tabindex="-1"><a class="header-anchor" href="#运行时数据区"><span>运行时数据区</span></a></h3><p>主要包括：PC 寄存器、Java 虚拟机栈、Java 堆、方法区、运行时常量池、本地方法栈等</p><h3 id="pc-program-counter-寄存器" tabindex="-1"><a class="header-anchor" href="#pc-program-counter-寄存器"><span>PC（Program Counter）寄存器</span></a></h3><ol><li>每个线程拥有一个 PC 寄存器，是线程私有的，用来存储的是当前线程下一条即将执行的指令的地址（而不是当前正在执行的指令的地址）</li><li>在创建一个新线程时，会自动创建一个 PC 寄存器，并将其初始化为 0，表示从字节码的第一条指令开始执行</li><li>执行本地方法时，PC 寄存器的值为 undefined</li><li>PC 寄存器是一个较小的内存空间，是唯一一个在 JVM 规范中没有规定 OutOfMemoryError 的内存区域</li><li>PC 寄存器的下一条指令地址是由 JVM 根据当前指令的“操作码”和“操作数”计算出来的，并由 JVM 自动将 PC 寄存器中的值更新为下一条指令的地址，以便继续执行下一条指令</li></ol><h3 id="java-栈-java-stack" tabindex="-1"><a class="header-anchor" href="#java-栈-java-stack"><span>Java 栈（Java Stack）</span></a></h3><ol><li>栈由一系列帧 Frame 组成的（Java 栈也叫做帧栈），是线程私有的，具有“先进后出”的特性</li><li>每个线程在执行方法时，都会创建一个对应的栈，用于存储该线程执行方法的信息。及线程每一次方法调用都会创建一个帧，并进行压栈，退出方法的时候，修改栈顶指针就可以把栈帧中的内容销毁</li><li>当线程调用的方法又调用了其他方法，则 JVM 会在当前的栈中创建一个新的栈，以此类推</li><li>一个线程可以同时对应多个栈，并且线程中的 Java 栈相互独立，当一个线程执行完一个方法后，该方法的栈会被销毁，线程继续执行其他方法的栈</li><li>帧保存的信息主要有：局部变量、操作数栈（所有的参数传递使用操作数栈）、常量池指针、动态链接、方法返回值等</li><li>局部变量表存放了编译期可知的各种基本数据类型和引用类型，每个插槽 slot 存放 32 位的数据，long、double 占两个插槽</li><li>栈的存取速度比堆快，仅次于 PC 寄存器</li><li>在栈中的数据的大小、生命周期是在编译期决定的，缺乏灵活性。栈的大小是由 Java 虚拟机在启动时，根据方法调用的嵌套深度和栈的大小限制等因素设置的，通常只有几百到几千字节</li><li>栈空间不足时，JVM 会抛出 StackOverflowError，而当 JVM 无法分配更多的栈空间时，会抛出 OutOfMemoryError</li></ol><h4 id="操作数栈-operand-stack" tabindex="-1"><a class="header-anchor" href="#操作数栈-operand-stack"><span>操作数栈（Operand Stack）</span></a></h4><p>操作数栈是 JVM 在执行方法的过程中使用的临时数据区域，先进后出的结构。用于存储方法执行过程中的操作数、中间结果以及返回值等信息，JVM 在执行方法时，需要将操作数栈中的数据作为操作数进行相应的计算</p><h4 id="java-栈和操作数栈的区别" tabindex="-1"><a class="header-anchor" href="#java-栈和操作数栈的区别"><span>Java 栈和操作数栈的区别</span></a></h4><p>Java 栈和操作数栈是 JVM 执行方法时使用的两种不同的内存区域</p><ul><li>Java 栈主要用于存储方法的局部变量、操作数栈、方法调用信息等</li><li>操作数栈主要用于存储方法执行过程中的操作数和返回值</li></ul><h3 id="java-堆-java-heap" tabindex="-1"><a class="header-anchor" href="#java-堆-java-heap"><span>Java 堆（Java Heap）</span></a></h3><ol><li>Java 堆（Java Heap）是 JVM 中用于存储对象实例和数组的内存区域，是 Java 中最大的一块内存区域。在 Java 程序运行期间，所有通过 new 关键字创建的对象都会被分配到 Java 堆中</li><li>Java 堆是一个运行时数据区，它是在 JVM 启动时创建的，是可以被所有线程共享的内存区域</li><li>Java 堆的大小可以通过虚拟机的启动参数来设置，并且可以动态扩展</li><li>在 Java 堆中分配对象实例时，Java 虚拟机会自动进行内存管理，负责对象的分配、回收等操作，开发人员不需要手动管理 Java 堆中的内存</li><li>Java 堆中不仅仅存储了 Java 对象的实例数据，还包括对象头信息、数组长度等数据。在 Java 堆中分配对象实例时，JVM 会为每个对象分配一个对象头，用于存储对象的运行时数据和类型信息。同时，如果该对象是数组，JVM 还会为该对象分配一个额外的空间，用于存储数组的长度信息</li><li>GC 主要是管理堆空间，对分代 GC 来说，堆也是分代的</li><li>堆的效率相对较慢</li></ol><h3 id="方法区-method-area" tabindex="-1"><a class="header-anchor" href="#方法区-method-area"><span>方法区（Method Area）</span></a></h3><ol><li>JDK 7 时 HotSpot 虚拟机使用永生代（PermGen）实现的方法区</li><li>JDK 8 移除了永生代，使用了元空间（Metaspace）实现的方法区，一部分数据存在元空间，一部分存在 Java 堆中</li><li>元空间与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中，它的别名是 Non-heap（非堆）</li><li>方法区是线程共享的内存区域，在 JVM 启动时创建的</li><li>方法区的大小可以通过虚拟机的启动参数来设置，并且可以动态扩展 <ol><li>JDK 7： <ol><li>-XX:Permsize 设置永久代初始分配空间</li><li>-XX:MaxPermsize 设定永久代最大可分配空间</li></ol></li><li>JDK 8： <ol><li>-XX:MetaspaceSize：设置初始的元空间大小</li><li>-XX:MaxMetaspaceSize：设置元空间最大的大小</li></ol></li></ol></li><li>通常用来保存的信息有： <ol><li>装载的类型信息：各类全限定名、类型标志、类的访问描述符等</li><li>类型的常量池</li><li>字段信息：修饰符、类型、名称等</li><li>方法信息：修饰符、返回类型、方法名、参数等</li><li>静态变量</li><li>指向类加载器的引用</li><li>指向 Class 实例的引用</li><li>方法表</li><li>运用时常量池</li></ol></li><li>Java 方法区和 Java 堆之间存在交集关系，Java 方法区并不等同于 Java 堆</li></ol><h4 id="元空间-metaspace" tabindex="-1"><a class="header-anchor" href="#元空间-metaspace"><span>元空间（Metaspace）</span></a></h4><p>Java 元空间是从 JDK 8 开始引入的一种新的内存区域，用于存储类的元数据信息。在之前的版本中，Java 类的元数据信息是存储在永久代中的，在 JDK 8 中，永久代被移除，元数据信息被存储在了元空间中，解决了永久代大小有限的问题</p><h3 id="运行时常量池-runtime-constant-pool" tabindex="-1"><a class="header-anchor" href="#运行时常量池-runtime-constant-pool"><span>运行时常量池（Runtime Constant Pool）</span></a></h3><ol><li>运行时常量池是方法区的一部分</li><li>JDK 6 时运行时常量池存放在永久代，JDK 7 开始存放在堆中</li><li>运行时常量池是 Class 文件中每个类或接口的常量池表，在运行期间的表示形式</li><li>通常包括：类的版本、字段、方法、接口等信息</li><li>通常在加载类和接口到 JVM 后，就创建了相应的运行时常量池</li></ol><h3 id="本地方法栈-native-method-stack" tabindex="-1"><a class="header-anchor" href="#本地方法栈-native-method-stack"><span>本地方法栈（Native Method Stack）</span></a></h3><p>本地方法栈是在 JVM 中用来支持 native 方法执行的栈</p><h2 id="栈、堆、方法区之间的交互关系" tabindex="-1"><a class="header-anchor" href="#栈、堆、方法区之间的交互关系"><span>栈、堆、方法区之间的交互关系</span></a></h2><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681285052154-cf767e7d-f237-4417-8884-38a82b5a7f4d.png#averageHue=%23f2f4f1&amp;clientId=uc4953b46-eede-4&amp;from=ui&amp;id=Uvruq&amp;originHeight=294&amp;originWidth=940&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=104401&amp;status=done&amp;style=none&amp;taskId=uf1361e6c-e39b-47f2-a386-7e669f0a2c7&amp;title=" alt="Snipaste_2023-04-12_15-37-09.png"> todo <img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681224528581-7ebca77d-91b7-47f6-820a-66038d300e8c.png#averageHue=%233d8b88&amp;clientId=uf6415ab8-e277-4&amp;from=ui&amp;id=k1bpb&amp;originHeight=990&amp;originWidth=2220&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=584286&amp;status=done&amp;style=none&amp;taskId=u97b6ab35-3bbd-4261-8435-4103698f6ce&amp;title=" alt="Snipaste_2023-04-11_22-48-26.png"></p><h3 id="堆与方法区的关系" tabindex="-1"><a class="header-anchor" href="#堆与方法区的关系"><span>堆与方法区的关系</span></a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681354356507-45303e39-377b-409f-8d76-ed307651294a.png#averageHue=%23e1f3df&amp;clientId=u9e9d98e7-061c-4&amp;from=ui&amp;id=u6b064ea7&amp;originHeight=758&amp;originWidth=1122&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=171811&amp;status=done&amp;style=none&amp;taskId=u2663ecb1-a0df-4218-9488-fbb5ab0fee0&amp;title=" alt="Snipaste_2023-04-13_10-52-12.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681354395586-5b2abdc6-7436-4d8e-9cad-c5e5032caa4c.png#averageHue=%23f5e5cf&amp;clientId=u9e9d98e7-061c-4&amp;from=ui&amp;id=u8afbc775&amp;originHeight=808&amp;originWidth=1374&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=520205&amp;status=done&amp;style=none&amp;taskId=u1fb45aa2-6c0c-4aa4-913a-707949553fa&amp;title=" alt="Snipaste_2023-04-13_10-52-58.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681354426253-f139b275-2f3b-49ba-9e15-098fb455dc03.png#averageHue=%23f7e9d5&amp;clientId=u9e9d98e7-061c-4&amp;from=ui&amp;id=u35d6b625&amp;originHeight=772&amp;originWidth=1466&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=564570&amp;status=done&amp;style=none&amp;taskId=ubff5af4e-1681-4164-8fcd-e058408238e&amp;title=" alt="Snipaste_2023-04-13_10-53-35.png"></p><h2 id="java-堆内存" tabindex="-1"><a class="header-anchor" href="#java-堆内存"><span>Java 堆内存</span></a></h2><ul><li>Java 堆用来存放应用系统创建的对象和数组，所有线程共享 Java 堆</li><li>Java 堆需要在逻辑上连续</li><li>Java 堆是在运行期动态分配内存大小，自动进行垃圾回收</li><li>Java 垃圾回收主要是回收堆内存，对分代 GC 来说，堆也是分代的</li></ul><h3 id="java-堆的结构" tabindex="-1"><a class="header-anchor" href="#java-堆的结构"><span>Java 堆的结构</span></a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681534245501-ecc0cfb6-cb21-422e-9f55-df01e0f529f9.png#averageHue=%23f1ebc2&amp;clientId=u0221be08-7657-4&amp;from=ui&amp;id=u6bcdb1fe&amp;originHeight=844&amp;originWidth=1966&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=538294&amp;status=done&amp;style=none&amp;taskId=u1802b859-ae2e-4fa9-9667-1afcea7294e&amp;title=" alt="Snipaste_2023-04-15_12-50-26.png"></p><ul><li>新时代：用来存放新分配的对象，新生代中经过垃圾回收，没有被回收的对象将被复制到老年代</li><li>老年代存储对象比新生代对象的年龄大得多</li><li>老年代会存储一些大对象</li><li>整个堆大小 = 新生代 + 老年代</li><li>新时代 = Eden + 存活区</li><li>JDK 8 之前的永生代，用来存放 Class、Method 等元信息，JDK 8 使用元空间（MetaSpace）代替，元空间并不存在于虚拟机中，而是直接使用本地内存</li></ul><h3 id="对象的内存布局" tabindex="-1"><a class="header-anchor" href="#对象的内存布局"><span>对象的内存布局</span></a></h3><ul><li>对象在内存中存储的布局（HotSpot），分为：对象头、实例数据和对齐填充</li><li>对象头： <ul><li>Mark Word：存储对象自身的运行数据，如：HashCode、GC 分代年龄、锁状态标志等</li><li>类型指针：对象指向它的类元数据的指针</li></ul></li><li>实例数据： <ul><li>真正存放对象实例数据的地方</li></ul></li><li>对齐填充 <ul><li>这部分不一定存在，仅仅是占位符，HotSpot 要求对象的起始地址都是 8 字节的整数倍，如果不是就需要对齐填充</li></ul></li></ul><h3 id="对象的访问定位" tabindex="-1"><a class="header-anchor" href="#对象的访问定位"><span>对象的访问定位</span></a></h3><ul><li>在 JVM 规范中只规定了 reference 类型是一个指向对象的引用，但没有规定这个引用具体如何去定位、访问堆中对象的具体位置</li><li>因此对象的访问方式取决于 JVM 的实现，目前主流的有：使用“句柄”和“指针”两种方式 <ul><li>句柄 在 Java 堆中会划分出一块内存来做句柄池，reference 中存储句柄的地址，句柄中存储对象的实例数据和类元数据的地址</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681539870482-4d574dc0-5afb-4158-bb94-2d6d0cd60c3e.png#averageHue=%23c9d5e2&amp;clientId=u0221be08-7657-4&amp;from=ui&amp;id=u96db2158&amp;originHeight=886&amp;originWidth=1562&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=480592&amp;status=done&amp;style=none&amp;taskId=u2d3a5256-3cb6-4297-a3c7-43cc5ab4ddc&amp;title=" alt="Snipaste_2023-04-15_14-24-21.png"></p><ul><li>指针 Java 堆中会存放访问类元数据的地址，reference 存储的是对象的地址</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681540025703-46036514-3110-45a5-a417-3dc3205590b4.png#averageHue=%23b5d5b1&amp;clientId=u0221be08-7657-4&amp;from=ui&amp;id=u225cc9ae&amp;originHeight=848&amp;originWidth=1818&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=712477&amp;status=done&amp;style=none&amp;taskId=u2af4b1d7-9503-49e3-b07f-c245b6a4f63&amp;title=" alt="Snipaste_2023-04-15_14-26-53.png"></p><h2 id="java-内存分配参数" tabindex="-1"><a class="header-anchor" href="#java-内存分配参数"><span>Java 内存分配参数</span></a></h2><h3 id="trace-跟踪参数" tabindex="-1"><a class="header-anchor" href="#trace-跟踪参数"><span>Trace 跟踪参数</span></a></h3><ul><li>打印 GC 的简要信息：-Xlog:gc、PrintGC（JDK 8）</li><li>打印 GC 的详细信息：-Xlog:gc*</li><li>指定 GC log 的位置，以文件输出：-Xlog:gc:flieName.log</li><li>每次 GC 后，都打印堆信息：-Xlog:gc+heap=debug</li></ul><h4 id="gc-日志格式" tabindex="-1"><a class="header-anchor" href="#gc-日志格式"><span>GC 日志格式</span></a></h4><ul><li>GC 发生的时间，JVM 从启动以来经过的秒数</li><li>日志级别信息和日志类型标记</li><li>GC 识别号</li><li>GC 类型和说明 GC 的原因</li><li>容量：GC 前容量 -&gt; GC 后容量（该区域总容量）</li><li>GC 持续时间，单位秒</li></ul><h3 id="java-堆的参数" tabindex="-1"><a class="header-anchor" href="#java-堆的参数"><span>Java 堆的参数</span></a></h3><ul><li>Xms：初始堆大小，默认是物理内存的 1/64</li><li>Xmx：最大堆大小，默认物理内存的 1/4</li><li>Xmn：新生代大小。默认是堆的 3/8，新生代过小会频繁的 GC，新生代过大会导致过多的 Full GC，程序停顿时间长</li><li>-XX:+HeapDumpOnOutOfMemoryError：OOM 时导出堆到文件</li><li>-XX:+HeapDumpPath：导出 OOM 的路径</li><li>-XX:NewRatio：；老年代与新生代的比值，如果 xms = xmx，且设置了 xmn 的情况下，该参数不用设置</li><li>-XX:SurvivorRatio：Eden 区和 survivor 区的大小比值，设置为 8，则两个 Survivor 区与一个 Eden 区的比值为 2:8，一个 Survivor 占整个新生代的 1/10</li><li>-XX:OnOutOfMemoryError：在 OOM 时，执行一个脚本</li></ul><h3 id="java-栈的参数" tabindex="-1"><a class="header-anchor" href="#java-栈的参数"><span>Java 栈的参数</span></a></h3><ul><li>Xss：通常只有几百 K，决定了函数调用的深度</li></ul><h3 id="元空间的参数" tabindex="-1"><a class="header-anchor" href="#元空间的参数"><span>元空间的参数</span></a></h3><ul><li>-XX:MetaspaceSize：初始空间大小</li><li>-XX:MaxMetaspaceSize：最大空间，默认没有限制</li><li>-XX:MinMetaspaceFreeRatio：在 GC 之后，最小的 Metaspace 剩余空间容量的百分比</li><li>-XX:MaxMetaspaceFreeRatio：在 GC 之后，最大的 Metaspace 剩余空间容量的百分比</li></ul><h2 id="字节码执行引擎" tabindex="-1"><a class="header-anchor" href="#字节码执行引擎"><span>字节码执行引擎</span></a></h2><ul><li>JVM 字节码执行引擎，基本功能就是输入字节码文件，然后对字节码进行解析并处理，最后输出执行的结果</li><li>实现方式： <ul><li>通过解释器直接解释执行字节码</li><li>通过编译器产生本地代码，编译执行</li></ul></li></ul><h3 id="栈帧" tabindex="-1"><a class="header-anchor" href="#栈帧"><span>栈帧</span></a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1682744312961-b3746c12-8a3a-47d9-a894-adb2a4f57179.png#averageHue=%23eaeae9&amp;clientId=u45945a78-9e3a-4&amp;from=ui&amp;id=u1b53a524&amp;originHeight=920&amp;originWidth=1020&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=255713&amp;status=done&amp;style=none&amp;taskId=ue4e1bae5-937a-4c20-b98e-c1dfa5ca162&amp;title=" alt="Snipaste_2023-04-29_12-58-17.png"></p><ul><li>是用于支持 JVM 进行方法调用和方法执行的数据结构</li><li>栈帧随着方法的调用而创建，随着方法结束而销毁</li><li>栈帧用于存放方法的局部变量、操作数栈、动态连接、方法返回地址等信息 <ul><li>局部变量表：用来存放方法参数和方法内部定义的局部变量的存储空间 <ul><li>以变量槽 slot 为单位，目前一个 slot 存放 32 位以内的数据类型</li><li>对于 64 位数据占 2 个 slot</li><li>对于实例方法，第 0 位 slot 存放的是 this，然后从 1 到 n，依次分配给参数列表</li><li>然后根据方法体内部定义的变量顺序和作用域分配 slot</li><li>slot 是复用的，以节省栈帧的空间，这种设计可能会影响到系统的垃圾回收行为</li></ul></li><li>操作数栈：用来存放方法运行期间，各个指令操作的数据 <ul><li>操作数栈中元素的数据类型必须和字节码指令的顺序严格匹配</li><li>虚拟机在实现栈帧的时候可能会让两个栈帧出现部分重叠区域，以存放公用的数据</li></ul></li><li>动态连接：每个栈帧持有一个指向运行时常量池中该栈帧所属方法的引用，以支持方法调用过程的动态连接 <ul><li>静态解析：类加载的时候，符号引用转换为直接引用</li><li>动态连接：运行期间转换为直接引用</li></ul></li><li>方法返回地址：方法执行后返回的地址</li><li>方法调用：方法调用是确定具体调用那一个方法，并不涉及方法内部的执行过程 <ul><li>部分方法是直接在类加载的解析节点就确定了直接引用关系</li><li>对于实例方法，也称虚方法，因为重载和多态，需要运行期间动态委派</li></ul></li><li>分派：静态分派和动态分派 <ul><li>静态分派：所有依赖静态类型来定位方法执行版本的分派方式，如：方法重载</li><li>动态分派：根据运行期的实际类型来定位方法执行版本的分配方式，如：方法覆盖</li><li>单分派和多分派：多余一个的就是多分派，只有一个的就是单分派</li></ul></li></ul></li><li>JVM 通过基于栈的字节码解释执行引擎来执行指令，JVM 的指令集也是基于栈的</li></ul><h1 id="jvm-内存模型详解" tabindex="-1"><a class="header-anchor" href="#jvm-内存模型详解"><span>JVM 内存模型详解</span></a></h1><h2 id="_1-jvm-架构概述" tabindex="-1"><a class="header-anchor" href="#_1-jvm-架构概述"><span>1. JVM 架构概述</span></a></h2><h3 id="_1-1-jvm-简化架构" tabindex="-1"><a class="header-anchor" href="#_1-1-jvm-简化架构"><span>1.1 JVM 简化架构</span></a></h3><p>JVM（Java Virtua### 2.2 Java 虚拟机栈（Java Virtual Machine Stack）</p><h4 id="_2-2-1-基本特征" tabindex="-1"><a class="header-anchor" href="#_2-2-1-基本特征"><span>2.2.1 基本特征</span></a></h4><ul><li><strong>线程私有</strong>：每个线程都有独立的虚拟机栈</li><li><strong>数据结构</strong>：由栈帧（Frame）组成，遵循&quot;后进先出&quot;（LIFO）原则</li><li><strong>生命周期</strong>：与线程相同，线程创建时创建，线程结束时销毁</li></ul><h4 id="_2-2-2-栈帧结构" tabindex="-1"><a class="header-anchor" href="#_2-2-2-栈帧结构"><span>2.2.2 栈帧结构</span></a></h4><p>每个方法调用都会创建一个栈帧，栈帧包含以下组件：</p><p><strong>局部变量表（Local Variable Table）</strong>：</p><ul><li>存储方法参数和局部变量</li><li>以变量槽（Slot）为单位，每个 Slot 存储 32 位数据</li><li>long 和 double 类型占用 2 个 Slot</li><li>对于实例方法，第 0 个 Slot 存储 this 引用</li></ul><p><strong>操作数栈（Operand Stack）</strong>：</p><ul><li>存储方法执行过程中的操作数和中间结果</li><li>遵循后进先出原则</li><li>用于字节码指令的操作数传递</li></ul><p><strong>动态链接（Dynamic Linking）</strong>：</p><ul><li>每个栈帧都包含一个指向运行时常量池中该方法的引用</li><li>支持方法调用过程中的动态连接</li></ul><p><strong>方法返回地址（Return Address）</strong>：</p><ul><li>存储方法执行完毕后的返回地址</li><li>包括正常退出和异常退出两种情况</li></ul><h4 id="_2-2-3-性能特点" tabindex="-1"><a class="header-anchor" href="#_2-2-3-性能特点"><span>2.2.3 性能特点</span></a></h4><ul><li><strong>访问速度</strong>：仅次于程序计数器，比堆内存快</li><li><strong>大小限制</strong>：通常只有几百到几千字节</li><li><strong>编译时确定</strong>：数据大小和生命周期在编译期确定</li></ul><h4 id="_2-2-4-异常情况" tabindex="-1"><a class="header-anchor" href="#_2-2-4-异常情况"><span>2.2.4 异常情况</span></a></h4><ul><li><strong>StackOverflowError</strong>：线程请求的栈深度大于虚拟机所允许的深度</li><li><strong>OutOfMemoryError</strong>：虚拟机栈可以动态扩展时，扩展时无法申请到足够的内存</li></ul><h4 id="_2-2-5-操作数栈详解" tabindex="-1"><a class="header-anchor" href="#_2-2-5-操作数栈详解"><span>2.2.5 操作数栈详解</span></a></h4><ul><li><strong>定义</strong>：JVM 执行方法过程中使用的临时数据区域</li><li><strong>特点</strong>：先进后出的数据结构</li><li><strong>作用</strong>：存储方法执行过程中的操作数、中间结果和返回值</li><li><strong>与 Java 栈的关系</strong>：操作数栈是栈帧的一部分，每个栈帧都有自己的操作数栈</li></ul><h3 id="_2-3-本地方法栈-native-method-stack" tabindex="-1"><a class="header-anchor" href="#_2-3-本地方法栈-native-method-stack"><span>2.3 本地方法栈（Native Method Stack）</span></a></h3><h4 id="_2-3-1-基本特征" tabindex="-1"><a class="header-anchor" href="#_2-3-1-基本特征"><span>2.3.1 基本特征</span></a></h4><ul><li><strong>作用</strong>：为虚拟机使用到的本地（Native）方法服务</li><li><strong>实现</strong>：虚拟机规范对本地方法栈没有强制规定，由虚拟机实现自由实现</li><li><strong>HotSpot 实现</strong>：将本地方法栈和虚拟机栈合二为一</li></ul><h4 id="_2-3-2-异常情况" tabindex="-1"><a class="header-anchor" href="#_2-3-2-异常情况"><span>2.3.2 异常情况</span></a></h4><p>与虚拟机栈相同，可能抛出 StackOverflowError 和 OutOfMemoryError 异常。运行时数据区（Runtime Data Area），是 Java 程序运行时所需的各种内存空间的总称。</p><p>![JVM架构图]</p><h3 id="_1-2-运行时数据区组成" tabindex="-1"><a class="header-anchor" href="#_1-2-运行时数据区组成"><span>1.2 运行时数据区组成</span></a></h3><p>JVM 运行时数据区主要包括以下几个部分：</p><ul><li><strong>程序计数器（PC Register）</strong></li><li><strong>Java 虚拟机栈（Java Virtual Machine Stack）</strong></li><li><strong>本地方法栈（Native Method Stack）</strong></li><li><strong>Java 堆（Java Heap）</strong></li><li><strong>方法区（Method Area）</strong></li><li><strong>运行时常量池（Runtime Constant Pool）</strong></li></ul><h3 id="_1-3-内存区域分类" tabindex="-1"><a class="header-anchor" href="#_1-3-内存区域分类"><span>1.3 内存区域分类</span></a></h3><h4 id="_1-3-1-线程私有区域" tabindex="-1"><a class="header-anchor" href="#_1-3-1-线程私有区域"><span>1.3.1 线程私有区域</span></a></h4><ul><li>程序计数器</li><li>Java 虚拟机栈</li><li>本地方法栈</li></ul><h4 id="_1-3-2-线程共享区域" tabindex="-1"><a class="header-anchor" href="#_1-3-2-线程共享区域"><span>1.3.2 线程共享区域</span></a></h4><ul><li>Java 堆</li><li>方法区（包含运行时常量池）</li></ul><h2 id="_2-线程私有内存区域" tabindex="-1"><a class="header-anchor" href="#_2-线程私有内存区域"><span>2. 线程私有内存区域</span></a></h2><h3 id="_2-1-程序计数器-pc-register" tabindex="-1"><a class="header-anchor" href="#_2-1-程序计数器-pc-register"><span>2.1 程序计数器（PC Register）</span></a></h3><h4 id="_2-1-1-基本特征" tabindex="-1"><a class="header-anchor" href="#_2-1-1-基本特征"><span>2.1.1 基本特征</span></a></h4><ul><li><strong>线程私有</strong>：每个线程都有独立的程序计数器</li><li><strong>作用</strong>：存储当前线程下一条将要执行的字节码指令的地址</li><li><strong>大小</strong>：是一个较小的内存空间</li></ul><h4 id="_2-1-2-工作原理" tabindex="-1"><a class="header-anchor" href="#_2-1-2-工作原理"><span>2.1.2 工作原理</span></a></h4><ul><li><strong>初始化</strong>：线程创建时，PC 寄存器初始化为 0，从字节码第一条指令开始执行</li><li><strong>指令跳转</strong>：JVM 根据当前指令的操作码和操作数计算下一条指令地址</li><li><strong>自动更新</strong>：JVM 自动更新 PC 寄存器中的值为下一条指令的地址</li></ul><h4 id="_2-1-3-特殊情况" tabindex="-1"><a class="header-anchor" href="#_2-1-3-特殊情况"><span>2.1.3 特殊情况</span></a></h4><ul><li><strong>执行 Java 方法</strong>：PC 寄存器记录正在执行的字节码指令地址</li><li><strong>执行本地方法</strong>：PC 寄存器的值为 undefined（未定义）</li><li><strong>异常处理</strong>：PC 寄存器是唯一不会出现 OutOfMemoryError 的内存区域 JVM 的简化架构，内存区域被称为运行时数据区 <img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681136814886-240288f8-3b94-461e-9fa2-4bfcebf5e5fe.png#averageHue=%23d1a985&amp;clientId=u35c67d1a-373a-4&amp;from=ui&amp;id=tzWmT&amp;originHeight=1044&amp;originWidth=1400&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=505683&amp;status=done&amp;style=none&amp;taskId=u272586e2-5a21-4584-a572-ad7f48b6dd9&amp;title=" alt="Snipaste_2023-04-10_22-26-17.png"></li></ul><h3 id="运行时数据区-1" tabindex="-1"><a class="header-anchor" href="#运行时数据区-1"><span>运行时数据区</span></a></h3><p>主要包括：PC 寄存器、Java 虚拟机栈、Java 堆、方法区、运行时常量池、本地方法栈等</p><h3 id="pc-program-counter-寄存器-1" tabindex="-1"><a class="header-anchor" href="#pc-program-counter-寄存器-1"><span>PC（Program Counter）寄存器</span></a></h3><ol><li>每个线程拥有一个 PC 寄存器，是线程私有的，用来存储的是当前线程下一条即将执行的指令的地址（而不是当前正在执行的指令的地址）</li><li>在创建一个新线程时，会自动创建一个 PC 寄存器，并将其初始化为 0，表示从字节码的第一条指令开始执行</li><li>执行本地方法时，PC 寄存器的值为 undefined</li><li>PC 寄存器是一个较小的内存空间，是唯一一个在 JVM 规范中没有规定 OutOfMemoryError 的内存区域</li><li>PC 寄存器的下一条指令地址是由 JVM 根据当前指令的“操作码”和“操作数”计算出来的，并由 JVM 自动将 PC 寄存器中的值更新为下一条指令的地址，以便继续执行下一条指令</li></ol><h3 id="java-栈-java-stack-1" tabindex="-1"><a class="header-anchor" href="#java-栈-java-stack-1"><span>Java 栈（Java Stack）</span></a></h3><ol><li>栈由一系列帧 Frame 组成的（Java 栈也叫做帧栈），是线程私有的，具有“先进后出”的特性</li><li>每个线程在执行方法时，都会创建一个对应的栈，用于存储该线程执行方法的信息。及线程每一次方法调用都会创建一个帧，并进行压栈，退出方法的时候，修改栈顶指针就可以把栈帧中的内容销毁</li><li>当线程调用的方法又调用了其他方法，则 JVM 会在当前的栈中创建一个新的栈，以此类推</li><li>一个线程可以同时对应多个栈，并且线程中的 Java 栈相互独立，当一个线程执行完一个方法后，该方法的栈会被销毁，线程继续执行其他方法的栈</li><li>帧保存的信息主要有：局部变量、操作数栈（所有的参数传递使用操作数栈）、常量池指针、动态链接、方法返回值等</li><li>局部变量表存放了编译期可知的各种基本数据类型和引用类型，每个插槽 slot 存放 32 位的数据，long、double 占两个插槽</li><li>栈的存取速度比堆快，仅次于 PC 寄存器</li><li>在栈中的数据的大小、生命周期是在编译期决定的，缺乏灵活性。栈的大小是由 Java 虚拟机在启动时，根据方法调用的嵌套深度和栈的大小限制等因素设置的，通常只有几百到几千字节</li><li>栈空间不足时，JVM 会抛出 StackOverflowError，而当 JVM 无法分配更多的栈空间时，会抛出 OutOfMemoryError</li></ol><h4 id="操作数栈-operand-stack-1" tabindex="-1"><a class="header-anchor" href="#操作数栈-operand-stack-1"><span>操作数栈（Operand Stack）</span></a></h4><p>操作数栈是 JVM 在执行方法的过程中使用的临时数据区域，先进后出的结构。用于存储方法执行过程中的操作数、中间结果以及返回值等信息，JVM 在执行方法时，需要将操作数栈中的数据作为操作数进行相应的计算</p><h4 id="java-栈和操作数栈的区别-1" tabindex="-1"><a class="header-anchor" href="#java-栈和操作数栈的区别-1"><span>Java 栈和操作数栈的区别</span></a></h4><p>Java 栈和操作数栈是 JVM 执行方法时使用的两种不同的内存区域</p><ul><li>Java 栈主要用于存储方法的局部变量、操作数栈、方法调用信息等</li><li>操作数栈主要用于存储方法执行过程中的操作数和返回值</li></ul><h2 id="_3-线程共享内存区域" tabindex="-1"><a class="header-anchor" href="#_3-线程共享内存区域"><span>3. 线程共享内存区域</span></a></h2><h3 id="_3-1-java-堆-java-heap" tabindex="-1"><a class="header-anchor" href="#_3-1-java-堆-java-heap"><span>3.1 Java 堆（Java Heap）</span></a></h3><h4 id="_3-1-1-基本特征" tabindex="-1"><a class="header-anchor" href="#_3-1-1-基本特征"><span>3.1.1 基本特征</span></a></h4><ul><li><strong>最大内存区域</strong>：Java 堆是 JVM 中最大的一块内存区域</li><li><strong>线程共享</strong>：所有线程共享 Java 堆内存</li><li><strong>对象存储</strong>：存储所有对象实例和数组</li><li><strong>垃圾收集</strong>：垃圾收集器主要管理的内存区域</li></ul><h4 id="_3-1-2-内存管理" tabindex="-1"><a class="header-anchor" href="#_3-1-2-内存管理"><span>3.1.2 内存管理</span></a></h4><ul><li><strong>动态分配</strong>：运行期动态分配内存大小</li><li><strong>自动管理</strong>：JVM 自动进行内存管理，包括对象分配和回收</li><li><strong>可调整大小</strong>：可以通过 JVM 启动参数设置堆大小，支持动态扩展</li><li><strong>逻辑连续</strong>：在逻辑上必须是连续的内存空间</li></ul><h4 id="_3-1-3-存储内容" tabindex="-1"><a class="header-anchor" href="#_3-1-3-存储内容"><span>3.1.3 存储内容</span></a></h4><ul><li><strong>对象实例数据</strong>：通过 new 关键字创建的所有对象</li><li><strong>对象头信息</strong>：包含对象的运行时数据和类型信息</li><li><strong>数组长度信息</strong>：数组对象的长度数据</li><li><strong>实例变量</strong>：对象的成员变量数据</li></ul><h4 id="_3-1-4-性能特点" tabindex="-1"><a class="header-anchor" href="#_3-1-4-性能特点"><span>3.1.4 性能特点</span></a></h4><ul><li><strong>访问速度</strong>：相对较慢，但容量大</li><li><strong>内存效率</strong>：支持大容量数据存储</li><li><strong>分代管理</strong>：支持分代垃圾收集策略</li></ul><h3 id="_3-2-方法区-method-area" tabindex="-1"><a class="header-anchor" href="#_3-2-方法区-method-area"><span>3.2 方法区（Method Area）</span></a></h3><h4 id="_3-2-1-版本演进" tabindex="-1"><a class="header-anchor" href="#_3-2-1-版本演进"><span>3.2.1 版本演进</span></a></h4><p><strong>JDK 7 及之前</strong>：</p><ul><li>使用永久代（PermGen）实现方法区</li><li>永久代是堆内存的一部分</li><li>大小受限，容易发生 OutOfMemoryError</li></ul><p><strong>JDK 8 及之后</strong>：</p><ul><li>移除永久代，引入元空间（Metaspace）</li><li>元空间使用本地内存，不再受堆大小限制</li><li>一部分数据存在元空间，一部分存在 Java 堆中</li></ul><h4 id="_3-2-2-基本特征" tabindex="-1"><a class="header-anchor" href="#_3-2-2-基本特征"><span>3.2.2 基本特征</span></a></h4><ul><li><strong>线程共享</strong>：所有线程共享方法区</li><li><strong>创建时机</strong>：JVM 启动时创建</li><li><strong>可扩展</strong>：大小可以通过启动参数设置，并支持动态扩展</li><li><strong>别名</strong>：也被称为 Non-heap（非堆）</li></ul><h4 id="_3-2-3-存储内容" tabindex="-1"><a class="header-anchor" href="#_3-2-3-存储内容"><span>3.2.3 存储内容</span></a></h4><p>方法区主要存储以下信息：</p><p><strong>类型信息</strong>：</p><ul><li>类的全限定名</li><li>类的直接超类的全限定名</li><li>类的访问修饰符</li><li>类的类型（类或接口）</li></ul><p><strong>方法信息</strong>：</p><ul><li>方法名称</li><li>方法的返回类型</li><li>方法参数的数量和类型</li><li>方法的访问修饰符</li><li>方法的字节码、操作数栈和局部变量表的大小</li></ul><p><strong>字段信息</strong>：</p><ul><li>字段名称</li><li>字段类型</li><li>字段的访问修饰符</li></ul><p><strong>其他信息</strong>：</p><ul><li>静态变量</li><li>类的常量池</li><li>指向类加载器的引用</li><li>指向 Class 实例的引用</li><li>方法表（用于支持动态分派）</li></ul><h4 id="_3-2-4-jvm-参数配置" tabindex="-1"><a class="header-anchor" href="#_3-2-4-jvm-参数配置"><span>3.2.4 JVM 参数配置</span></a></h4><p><strong>JDK 7 参数</strong>：</p><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-XX:PermSize</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;size&gt;        </span><span style="color:#616E88;"># 设置永久代初始大小</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:MaxPermSize</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;size&gt;     </span><span style="color:#616E88;"># 设置永久代最大大小</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>JDK 8 参数</strong>：</p><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-XX:MetaspaceSize</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;size&gt;       </span><span style="color:#616E88;"># 设置元空间初始大小</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:MaxMetaspaceSize</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;size&gt;    </span><span style="color:#616E88;"># 设置元空间最大大小</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-2-5-元空间-metaspace-详解" tabindex="-1"><a class="header-anchor" href="#_3-2-5-元空间-metaspace-详解"><span>3.2.5 元空间（Metaspace）详解</span></a></h4><ul><li><strong>定义</strong>：JDK 8 引入的新内存区域，用于存储类的元数据信息</li><li><strong>位置</strong>：使用本地内存（直接内存），不在 JVM 堆中</li><li><strong>优势</strong>： <ul><li>避免了永久代大小限制的问题</li><li>减少了 GC 对元数据的影响</li><li>提高了类加载和卸载的性能</li></ul></li><li><strong>大小管理</strong>：默认情况下没有大小限制，受系统内存限制</li></ul><h3 id="_3-3-运行时常量池-runtime-constant-pool" tabindex="-1"><a class="header-anchor" href="#_3-3-运行时常量池-runtime-constant-pool"><span>3.3 运行时常量池（Runtime Constant Pool）</span></a></h3><h4 id="_3-3-1-基本概念" tabindex="-1"><a class="header-anchor" href="#_3-3-1-基本概念"><span>3.3.1 基本概念</span></a></h4><ul><li><strong>定义</strong>：方法区的一部分，是 Class 文件中常量池表的运行时表示</li><li><strong>来源</strong>：每个类或接口的常量池表在运行期的表示形式</li><li><strong>创建时机</strong>：在类和接口被加载到 JVM 后创建</li></ul><h4 id="_3-3-2-版本变化" tabindex="-1"><a class="header-anchor" href="#_3-3-2-版本变化"><span>3.3.2 版本变化</span></a></h4><ul><li><strong>JDK 6</strong>：运行时常量池存放在永久代中</li><li><strong>JDK 7</strong>：字符串常量池移到 Java 堆中</li><li><strong>JDK 8</strong>：随着永久代的移除，运行时常量池移至元空间</li></ul><h4 id="_3-3-3-存储内容" tabindex="-1"><a class="header-anchor" href="#_3-3-3-存储内容"><span>3.3.3 存储内容</span></a></h4><ul><li><strong>字面量</strong>：文本字符串、声明为 final 的常量值等</li><li><strong>符号引用</strong>： <ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li><strong>运行时解析的常量</strong>：动态生成的常量</li></ul><h4 id="_3-3-4-特性" tabindex="-1"><a class="header-anchor" href="#_3-3-4-特性"><span>3.3.4 特性</span></a></h4><ul><li><strong>动态性</strong>：相对于 Class 文件常量池的一个重要特征是具备动态性</li><li><strong>可扩展性</strong>：运行期间也可以将新的常量放入池中</li><li><strong>典型应用</strong>：String 类的 intern()方法</li></ul><h2 id="_4-内存区域交互关系" tabindex="-1"><a class="header-anchor" href="#_4-内存区域交互关系"><span>4. 内存区域交互关系</span></a></h2><h3 id="_4-1-栈、堆、方法区的关系" tabindex="-1"><a class="header-anchor" href="#_4-1-栈、堆、方法区的关系"><span>4.1 栈、堆、方法区的关系</span></a></h3><p>![内存区域交互图]</p><h4 id="_4-1-1-对象创建过程" tabindex="-1"><a class="header-anchor" href="#_4-1-1-对象创建过程"><span>4.1.1 对象创建过程</span></a></h4><ol><li><strong>类加载检查</strong>：检查类是否已被加载、解析和初始化</li><li><strong>内存分配</strong>：在 Java 堆中为新生对象分配内存</li><li><strong>初始化零值</strong>：将分配的内存空间初始化为零值</li><li><strong>设置对象头</strong>：设置对象的对象头信息</li><li><strong>执行初始化</strong>：执行对象的初始化方法</li></ol><h4 id="_4-1-2-引用关系" tabindex="-1"><a class="header-anchor" href="#_4-1-2-引用关系"><span>4.1.2 引用关系</span></a></h4><ul><li><strong>栈到堆</strong>：局部变量表中的引用指向堆中的对象</li><li><strong>堆到方法区</strong>：对象头中的类型指针指向方法区中的类信息</li><li><strong>方法区到堆</strong>：Class 对象存储在堆中，静态变量也在堆中</li></ul><h3 id="_4-2-堆与方法区的详细关系" tabindex="-1"><a class="header-anchor" href="#_4-2-堆与方法区的详细关系"><span>4.2 堆与方法区的详细关系</span></a></h3><h4 id="_4-2-1-数据分布" tabindex="-1"><a class="header-anchor" href="#_4-2-1-数据分布"><span>4.2.1 数据分布</span></a></h4><ul><li><strong>对象实例</strong>：存储在 Java 堆中</li><li><strong>对象类型数据</strong>：存储在方法区中</li><li><strong>对象引用</strong>：存储在栈的局部变量表中</li></ul><h4 id="_4-2-2-访问过程" tabindex="-1"><a class="header-anchor" href="#_4-2-2-访问过程"><span>4.2.2 访问过程</span></a></h4><ol><li>通过栈中的 reference 定位到堆中的对象</li><li>通过对象头中的类型指针定位到方法区中的类信息</li><li>根据类信息进行方法调用和字段访问</li></ol><h2 id="_5-java-堆内存详解" tabindex="-1"><a class="header-anchor" href="#_5-java-堆内存详解"><span>5. Java 堆内存详解</span></a></h2><h3 id="_5-1-堆内存特性" tabindex="-1"><a class="header-anchor" href="#_5-1-堆内存特性"><span>5.1 堆内存特性</span></a></h3><ul><li><strong>线程共享</strong>：Java 堆被所有线程共享，用于存放应用系统创建的对象和数组</li><li><strong>逻辑连续</strong>：Java 堆在逻辑上必须是连续的内存空间</li><li><strong>动态管理</strong>：运行期动态分配内存大小，自动进行垃圾回收</li><li><strong>分代设计</strong>：对于分代 GC 来说，堆采用分代结构</li></ul><h3 id="_5-2-java-堆的结构" tabindex="-1"><a class="header-anchor" href="#_5-2-java-堆的结构"><span>5.2 Java 堆的结构</span></a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681534245501-ecc0cfb6-cb21-422e-9f55-df01e0f529f9.png#averageHue=%23f1ebc2&amp;clientId=u0221be08-7657-4&amp;from=ui&amp;id=u6bcdb1fe&amp;originHeight=844&amp;originWidth=1966&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=538294&amp;status=done&amp;style=none&amp;taskId=u1802b859-ae2e-4fa9-9667-1afcea7294e&amp;title=" alt="Java堆结构图"></p><h4 id="_5-2-1-分代划分" tabindex="-1"><a class="header-anchor" href="#_5-2-1-分代划分"><span>5.2.1 分代划分</span></a></h4><ul><li><strong>新生代（Young Generation）</strong>：用来存放新分配的对象 <ul><li><strong>Eden 区</strong>：对象首次分配的区域</li><li><strong>Survivor 区</strong>：分为 From 和 To 两个区域，用于存放经过一次 GC 后存活的对象</li></ul></li><li><strong>老年代（Old Generation）</strong>：存放生存时间较长的对象和大对象</li><li><strong>永久代/元空间</strong>：JDK 8 之前使用永久代存放类元信息，JDK 8 之后使用元空间替代</li></ul><h4 id="_5-2-2-大小关系" tabindex="-1"><a class="header-anchor" href="#_5-2-2-大小关系"><span>5.2.2 大小关系</span></a></h4><ul><li><strong>整个堆大小</strong> = 新生代 + 老年代</li><li><strong>新生代</strong> = Eden 区 + Survivor 区（From + To）</li><li><strong>默认比例</strong>：新生代:老年代 = 1:2，Eden:Survivor = 8:1</li><li>老年代会存储一些大对象</li><li>整个堆大小 = 新生代 + 老年代</li><li>新时代 = Eden + 存活区</li><li>JDK 8 之前的永生代，用来存放 Class、Method 等元信息，JDK 8 使用元空间（MetaSpace）代替，元空间并不存在于虚拟机中，而是直接使用本地内存</li></ul><h3 id="对象的内存布局-1" tabindex="-1"><a class="header-anchor" href="#对象的内存布局-1"><span>对象的内存布局</span></a></h3><ul><li>对象在内存中存储的布局（HotSpot），分为：对象头、实例数据和对齐填充</li><li>对象头： <ul><li>Mark Word：存储对象自身的运行数据，如：HashCode、GC 分代年龄、锁状态标志等</li><li>类型指针：对象指向它的类元数据的指针</li></ul></li><li>实例数据： <ul><li>真正存放对象实例数据的地方</li></ul></li><li>对齐填充 <ul><li>这部分不一定存在，仅仅是占位符，HotSpot 要求对象的起始地址都是 8 字节的整数倍，如果不是就需要对齐填充</li></ul></li></ul><h3 id="对象的访问定位-1" tabindex="-1"><a class="header-anchor" href="#对象的访问定位-1"><span>对象的访问定位</span></a></h3><ul><li>在 JVM 规范中只规定了 reference 类型是一个指向对象的引用，但没有规定这个引用具体如何去定位、访问堆中对象的具体位置</li><li>因此对象的访问方式取决于 JVM 的实现，目前主流的有：使用“句柄”和“指针”两种方式</li></ul><h4 id="_5-4-1-句柄访问" tabindex="-1"><a class="header-anchor" href="#_5-4-1-句柄访问"><span>5.4.1 句柄访问</span></a></h4><ul><li><strong>实现方式</strong>：在 Java 堆中划分一块内存作为句柄池</li><li><strong>访问过程</strong>：reference 存储句柄地址，句柄中包含对象实例数据与类型数据的具体地址信息</li><li><strong>优点</strong>：reference 中存储的是稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针</li><li><strong>缺点</strong>：增加了一次指针定位的时间开销</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681539870482-4d574dc0-5afb-4158-bb94-2d6d0cd60c3e.png#averageHue=%23c9d5e2&amp;clientId=u0221be08-7657-4&amp;from=ui&amp;id=u96db2158&amp;originHeight=886&amp;originWidth=1562&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=480592&amp;status=done&amp;style=none&amp;taskId=u2d3a5256-3cb6-4297-a3c7-43cc5ab4ddc&amp;title=" alt="句柄访问"></p><h4 id="_5-4-2-直接指针访问" tabindex="-1"><a class="header-anchor" href="#_5-4-2-直接指针访问"><span>5.4.2 直接指针访问</span></a></h4><ul><li><strong>实现方式</strong>：reference 直接存储对象地址</li><li><strong>访问过程</strong>：通过 reference 直接访问对象，对象头中存储类型数据的指针</li><li><strong>优点</strong>：访问速度快，节省了一次指针定位的时间开销</li><li><strong>缺点</strong>：对象被移动时需要修改 reference 本身</li><li><strong>应用</strong>：HotSpot 虚拟机采用的方式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1681540025703-46036514-3110-45a5-a417-3dc3205590b4.png#averageHue=%23b5d5b1&amp;clientId=u0221be08-7657-4&amp;from=ui&amp;id=u225cc9ae&amp;originHeight=848&amp;originWidth=1818&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=712477&amp;status=done&amp;style=none&amp;taskId=u2af4b1d7-9503-49e3-b07f-c245b6a4f63&amp;title=" alt="直接指针访问"></p><h2 id="_6-jvm-参数配置" tabindex="-1"><a class="header-anchor" href="#_6-jvm-参数配置"><span>6. JVM 参数配置</span></a></h2><h3 id="_6-1-gc-跟踪参数" tabindex="-1"><a class="header-anchor" href="#_6-1-gc-跟踪参数"><span>6.1 GC 跟踪参数</span></a></h3><h4 id="_6-1-1-jdk-8-及之前版本" tabindex="-1"><a class="header-anchor" href="#_6-1-1-jdk-8-及之前版本"><span>6.1.1 JDK 8 及之前版本</span></a></h4><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-XX:+PrintGC</span><span style="color:#616E88;">                    # 打印GC简要信息</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:+PrintGCDetails</span><span style="color:#616E88;">             # 打印GC详细信息</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:+PrintGCTimeStamps</span><span style="color:#616E88;">          # 打印GC时间戳</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-Xloggc:gc.log</span><span style="color:#616E88;">                  # 指定GC日志文件</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-1-2-jdk-9-及之后版本" tabindex="-1"><a class="header-anchor" href="#_6-1-2-jdk-9-及之后版本"><span>6.1.2 JDK 9 及之后版本</span></a></h4><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-Xlog:gc</span><span style="color:#616E88;">                        # 打印GC简要信息</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-Xlog:gc*</span><span style="color:#616E88;">                       # 打印GC详细信息</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-Xlog:gc:fileName.log</span><span style="color:#616E88;">           # 指定GC日志文件位置</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-Xlog:gc+heap</span><span style="color:#A3BE8C;">=debug</span><span style="color:#616E88;">             # 每次GC后打印堆信息</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-1-3-gc-日志格式说明" tabindex="-1"><a class="header-anchor" href="#_6-1-3-gc-日志格式说明"><span>6.1.3 GC 日志格式说明</span></a></h4><ul><li><strong>时间戳</strong>：GC 发生的时间，JVM 从启动以来经过的秒数</li><li><strong>日志级别</strong>：日志级别信息和日志类型标记</li><li><strong>GC 标识</strong>：GC 识别号</li><li><strong>GC 类型</strong>：GC 类型和产生 GC 的原因</li><li><strong>内存变化</strong>：GC 前容量 -&gt; GC 后容量（该区域总容量）</li><li><strong>持续时间</strong>：GC 持续时间，单位为秒</li></ul><h3 id="_6-2-java-堆参数配置" tabindex="-1"><a class="header-anchor" href="#_6-2-java-堆参数配置"><span>6.2 Java 堆参数配置</span></a></h3><h4 id="_6-2-1-基本堆参数" tabindex="-1"><a class="header-anchor" href="#_6-2-1-基本堆参数"><span>6.2.1 基本堆参数</span></a></h4><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-Xms</span><span style="color:#D8DEE9FF;">&lt;size&gt;                      </span><span style="color:#616E88;"># 初始堆大小，默认物理内存的1/64</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-Xmx</span><span style="color:#D8DEE9FF;">&lt;size&gt;                      </span><span style="color:#616E88;"># 最大堆大小，默认物理内存的1/4</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-Xmn</span><span style="color:#D8DEE9FF;">&lt;size&gt;                      </span><span style="color:#616E88;"># 新生代大小，默认是堆的3/8</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-2-2-分代比例参数" tabindex="-1"><a class="header-anchor" href="#_6-2-2-分代比例参数"><span>6.2.2 分代比例参数</span></a></h4><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-XX:NewRatio</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;ratio&gt;            </span><span style="color:#616E88;"># 老年代与新生代的比值</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:SurvivorRatio</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;ratio&gt;       </span><span style="color:#616E88;"># Eden区与Survivor区的大小比值</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-2-3-调试和监控参数" tabindex="-1"><a class="header-anchor" href="#_6-2-3-调试和监控参数"><span>6.2.3 调试和监控参数</span></a></h4><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-XX:+HeapDumpOnOutOfMemoryError</span><span style="color:#616E88;"> # OOM时自动导出堆转储文件</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:HeapDumpPath</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;path&gt;         </span><span style="color:#616E88;"># 设置堆转储文件的保存路径</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:OnOutOfMemoryError</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;cmd&gt;    </span><span style="color:#616E88;"># OOM时执行指定脚本</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-3-java-栈参数配置" tabindex="-1"><a class="header-anchor" href="#_6-3-java-栈参数配置"><span>6.3 Java 栈参数配置</span></a></h3><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-Xss</span><span style="color:#D8DEE9FF;">&lt;size&gt;                      </span><span style="color:#616E88;"># 设置线程栈大小，通常几百KB</span></span></span>
<span class="line"><span class="line"><span style="color:#616E88;">                               # 决定了函数调用的最大深度</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6-4-元空间参数配置" tabindex="-1"><a class="header-anchor" href="#_6-4-元空间参数配置"><span>6.4 元空间参数配置</span></a></h3><div class="language-bash line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-bash;"><code><span class="line"><span class="line"><span style="color:#88C0D0;">-XX:MetaspaceSize</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;size&gt;              </span><span style="color:#616E88;"># 元空间初始大小</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:MaxMetaspaceSize</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;size&gt;           </span><span style="color:#616E88;"># 元空间最大大小，默认无限制</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:MinMetaspaceFreeRatio</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;percent&gt;   </span><span style="color:#616E88;"># GC后最小剩余空间百分比</span></span></span>
<span class="line"><span class="line"><span style="color:#88C0D0;">-XX:MaxMetaspaceFreeRatio</span><span style="color:#A3BE8C;">=</span><span style="color:#D8DEE9FF;">&lt;percent&gt;   </span><span style="color:#616E88;"># GC后最大剩余空间百分比</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_7-字节码执行引擎" tabindex="-1"><a class="header-anchor" href="#_7-字节码执行引擎"><span>7. 字节码执行引擎</span></a></h2><h3 id="_7-1-执行引擎概述" tabindex="-1"><a class="header-anchor" href="#_7-1-执行引擎概述"><span>7.1 执行引擎概述</span></a></h3><p>JVM 字节码执行引擎的基本功能是输入字节码文件，进行解析和处理，最后输出执行结果。</p><h4 id="_7-1-1-实现方式" tabindex="-1"><a class="header-anchor" href="#_7-1-1-实现方式"><span>7.1.1 实现方式</span></a></h4><ul><li><strong>解释执行</strong>：通过解释器直接解释执行字节码</li><li><strong>编译执行</strong>：通过编译器产生本地代码，编译执行</li><li><strong>混合模式</strong>：解释执行与编译执行并存</li></ul><h3 id="_7-2-栈帧-stack-frame" tabindex="-1"><a class="header-anchor" href="#_7-2-栈帧-stack-frame"><span>7.2 栈帧（Stack Frame）</span></a></h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/29236088/1682744312961-b3746c12-8a3a-47d9-a894-adb2a4f57179.png#averageHue=%23eaeae9&amp;clientId=u45945a78-9e3a-4&amp;from=ui&amp;id=u1b53a524&amp;originHeight=920&amp;originWidth=1020&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=255713&amp;status=done&amp;style=none&amp;taskId=ue4e1bae5-937a-4c20-b98e-c1dfa5ca162&amp;title=" alt="栈帧结构图"></p><h4 id="_7-2-1-栈帧概念" tabindex="-1"><a class="header-anchor" href="#_7-2-1-栈帧概念"><span>7.2.1 栈帧概念</span></a></h4><ul><li><strong>定义</strong>：用于支持 JVM 进行方法调用和方法执行的数据结构</li><li><strong>生命周期</strong>：随着方法调用而创建，随着方法结束而销毁</li><li><strong>存储内容</strong>：方法的局部变量、操作数栈、动态连接、方法返回地址等信息</li></ul><h4 id="_7-2-2-局部变量表-local-variable-table" tabindex="-1"><a class="header-anchor" href="#_7-2-2-局部变量表-local-variable-table"><span>7.2.2 局部变量表（Local Variable Table）</span></a></h4><p><strong>功能</strong>：存放方法参数和方法内部定义的局部变量</p><p><strong>存储单位</strong>：</p><ul><li>以变量槽（Slot）为基本单位</li><li>一个 Slot 存放 32 位以内的数据类型</li><li>64 位数据类型占用 2 个 Slot</li></ul><p><strong>分配规则</strong>：</p><ul><li>对于实例方法：第 0 位 Slot 存放 this 引用</li><li>参数列表：从第 1 位到第 n 位依次分配给参数</li><li>局部变量：根据方法体内定义顺序和作用域分配</li><li><strong>Slot 复用</strong>：为节省栈帧空间，Slot 可以复用，可能影响垃圾回收行为</li></ul><h4 id="_7-2-3-操作数栈-operand-stack" tabindex="-1"><a class="header-anchor" href="#_7-2-3-操作数栈-operand-stack"><span>7.2.3 操作数栈（Operand Stack）</span></a></h4><p><strong>功能</strong>：存放方法运行期间各个指令操作的数据</p><p><strong>特性</strong>：</p><ul><li>操作数栈中元素的数据类型必须与字节码指令严格匹配</li><li>虚拟机实现时可能让两个栈帧出现部分重叠区域，以存放公用数据</li></ul><h4 id="_7-2-4-动态连接-dynamic-linking" tabindex="-1"><a class="header-anchor" href="#_7-2-4-动态连接-dynamic-linking"><span>7.2.4 动态连接（Dynamic Linking）</span></a></h4><p><strong>功能</strong>：每个栈帧持有一个指向运行时常量池中该栈帧所属方法的引用</p><p><strong>连接方式</strong>：</p><ul><li><strong>静态解析</strong>：类加载时，符号引用转换为直接引用</li><li><strong>动态连接</strong>：运行期间转换为直接引用</li></ul><h4 id="_7-2-5-方法返回地址-return-address" tabindex="-1"><a class="header-anchor" href="#_7-2-5-方法返回地址-return-address"><span>7.2.5 方法返回地址（Return Address）</span></a></h4><p><strong>功能</strong>：存储方法执行后返回的地址信息</p><h3 id="_7-3-方法调用" tabindex="-1"><a class="header-anchor" href="#_7-3-方法调用"><span>7.3 方法调用</span></a></h3><h4 id="_7-3-1-方法调用概念" tabindex="-1"><a class="header-anchor" href="#_7-3-1-方法调用概念"><span>7.3.1 方法调用概念</span></a></h4><ul><li><strong>定义</strong>：确定具体调用哪一个方法，不涉及方法内部的具体执行过程</li><li><strong>解析时机</strong>：部分方法在类加载的解析阶段就确定了直接引用关系</li><li><strong>动态特性</strong>：实例方法（虚方法）因重载和多态需要运行期动态委派</li></ul><h4 id="_7-3-2-分派机制" tabindex="-1"><a class="header-anchor" href="#_7-3-2-分派机制"><span>7.3.2 分派机制</span></a></h4><p><strong>静态分派</strong>：</p><ul><li><strong>定义</strong>：依赖静态类型来定位方法执行版本的分派方式</li><li><strong>典型应用</strong>：方法重载（Overload）</li><li><strong>解析时机</strong>：编译期确定</li></ul><p><strong>动态分派</strong>：</p><ul><li><strong>定义</strong>：根据运行期实际类型来定位方法执行版本的分派方式</li><li><strong>典型应用</strong>：方法覆盖（Override）</li><li><strong>解析时机</strong>：运行期确定</li></ul><p><strong>单分派与多分派</strong>：</p><ul><li><strong>单分派</strong>：根据一个宗量对目标方法进行选择</li><li><strong>多分派</strong>：根据多个宗量对目标方法进行选择</li></ul><h3 id="_7-4-基于栈的字节码解释执行引擎" tabindex="-1"><a class="header-anchor" href="#_7-4-基于栈的字节码解释执行引擎"><span>7.4 基于栈的字节码解释执行引擎</span></a></h3><h4 id="_7-4-1-执行模型" tabindex="-1"><a class="header-anchor" href="#_7-4-1-执行模型"><span>7.4.1 执行模型</span></a></h4><ul><li>JVM 通过基于栈的字节码解释执行引擎来执行指令</li><li>JVM 的指令集采用基于栈的设计</li><li>操作数栈作为计算过程中操作数的临时存储区域</li></ul><h4 id="_7-4-2-指令执行过程" tabindex="-1"><a class="header-anchor" href="#_7-4-2-指令执行过程"><span>7.4.2 指令执行过程</span></a></h4><ol><li><strong>取指令</strong>：从字节码流中读取下一条指令</li><li><strong>解码</strong>：解析指令的操作码和操作数</li><li><strong>执行</strong>：根据指令类型执行相应操作</li><li><strong>更新程序计数器</strong>：指向下一条指令</li></ol><h2 id="_8-总结" tabindex="-1"><a class="header-anchor" href="#_8-总结"><span>8. 总结</span></a></h2><h3 id="_8-1-jvm-内存模型核心要点" tabindex="-1"><a class="header-anchor" href="#_8-1-jvm-内存模型核心要点"><span>8.1 JVM 内存模型核心要点</span></a></h3><ol><li><strong>内存区域划分</strong>：PC 寄存器、Java 栈、本地方法栈、堆、方法区、运行时常量池</li><li><strong>线程私有区域</strong>：PC 寄存器、Java 栈、本地方法栈</li><li><strong>线程共享区域</strong>：Java 堆、方法区、运行时常量池</li><li><strong>堆内存管理</strong>：分代设计、对象内存布局、访问定位机制</li><li><strong>执行引擎</strong>：基于栈的字节码解释执行、栈帧结构、方法调用机制</li></ol><h3 id="_8-2-性能调优关键点" tabindex="-1"><a class="header-anchor" href="#_8-2-性能调优关键点"><span>8.2 性能调优关键点</span></a></h3><ol><li><strong>合理配置堆大小</strong>：根据应用特点设置 Xms、Xmx 参数</li><li><strong>分代比例调整</strong>：通过 NewRatio、SurvivorRatio 优化 GC 性能</li><li><strong>栈大小配置</strong>：使用 Xss 参数避免 StackOverflowError</li><li><strong>元空间监控</strong>：JDK 8+需要关注 MetaspaceSize 配置</li><li><strong>GC 日志分析</strong>：通过 GC 日志分析内存使用模式和性能瓶颈</li></ol><h3 id="_8-3-最佳实践建议" tabindex="-1"><a class="header-anchor" href="#_8-3-最佳实践建议"><span>8.3 最佳实践建议</span></a></h3><ol><li><strong>监控内存使用</strong>：定期检查各内存区域的使用情况</li><li><strong>优化对象生命周期</strong>：减少不必要的对象创建和长生命周期对象</li><li><strong>合理使用本地缓存</strong>：避免内存泄漏</li><li><strong>定期分析 GC 日志</strong>：识别性能问题和优化机会</li><li><strong>压测验证配置</strong>：在类似生产环境中验证 JVM 参数设置</li></ol></div><!--[--><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link label" href="https://github.com/hyfly233/blog/edit/main/md/article/language/java/jvm/JVM内存模型.md" aria-label="Edit this page" rel="noopener noreferrer" target="_blank"><!--[--><svg class="edit-icon" viewbox="0 0 1024 1024"><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->Edit this page<!----></a></div><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最后更新时间: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: hyfly233@outlook.com">hyfly233</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/blog/assets/app-chPKMbRn.js" defer></script>
  </body>
</html>
