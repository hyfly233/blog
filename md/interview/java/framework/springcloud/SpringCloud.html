<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.19" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>とんぼの気持ち</title><meta name="description" content="">
    <link rel="preload" href="/blog/assets/style-nxaj3WOG.css" as="style"><link rel="stylesheet" href="/blog/assets/style-nxaj3WOG.css">
    <link rel="modulepreload" href="/blog/assets/app-chPKMbRn.js"><link rel="modulepreload" href="/blog/assets/SpringCloud.html-DTSK6rgN.js">
    <link rel="prefetch" href="/blog/assets/directory.html-CM077g0X.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-WkqGtERh.js" as="script"><link rel="prefetch" href="/blog/assets/directory.html-BH0WGkAw.js" as="script"><link rel="prefetch" href="/blog/assets/CephAnsible扩充OSD节点.html-DQGhyA8S.js" as="script"><link rel="prefetch" href="/blog/assets/CephAnsible的OSD存储满后的临时解决方案.html-BDuF8Lky.js" as="script"><link rel="prefetch" href="/blog/assets/CephAnsible部署Ceph.html-B1ua_UqN.js" as="script"><link rel="prefetch" href="/blog/assets/iSCSI安装.html-HVTL7fJU.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BceON7lL.js" as="script"><link rel="prefetch" href="/blog/assets/如何升级系统构架.html-B16ubYTA.js" as="script"><link rel="prefetch" href="/blog/assets/如何正确加锁.html-DjvlAowS.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-C3nYQ7aQ.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BmNefUmR.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DJsvdjYt.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BlgG4jCN.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bp1xrcuH.js" as="script"><link rel="prefetch" href="/blog/assets/linear_search.html-Dr3lRrFe.js" as="script"><link rel="prefetch" href="/blog/assets/binary_tree_sort.html-BZSaHXpo.js" as="script"><link rel="prefetch" href="/blog/assets/bitonic_sort.html-DZHRyZF8.js" as="script"><link rel="prefetch" href="/blog/assets/bubble_sort.html-XLBBj8rD.js" as="script"><link rel="prefetch" href="/blog/assets/bucket_sort.html-D1NDEl5q.js" as="script"><link rel="prefetch" href="/blog/assets/cocktail_shaker_sort.html-sQF3C84o.js" as="script"><link rel="prefetch" href="/blog/assets/comb_sort.html-B6Z7wIqt.js" as="script"><link rel="prefetch" href="/blog/assets/counting_sort.html-D8wkfUEd.js" as="script"><link rel="prefetch" href="/blog/assets/gnome_sort.html-ClFIwPrf.js" as="script"><link rel="prefetch" href="/blog/assets/heap_sort.html-Rp3rKaBj.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DSXsiBgb.js" as="script"><link rel="prefetch" href="/blog/assets/insertion_sort.html-Cb45Fk0s.js" as="script"><link rel="prefetch" href="/blog/assets/merge_sort.html-DKhyfHNj.js" as="script"><link rel="prefetch" href="/blog/assets/odd_even_sort.html-BUUtGCfM.js" as="script"><link rel="prefetch" href="/blog/assets/pancake_sort.html-CLbqQfeK.js" as="script"><link rel="prefetch" href="/blog/assets/quick_sort.html-DsTl6rI_.js" as="script"><link rel="prefetch" href="/blog/assets/radix_sort.html-DGfsIMQr.js" as="script"><link rel="prefetch" href="/blog/assets/selection_sort.html-CWB7HCPo.js" as="script"><link rel="prefetch" href="/blog/assets/shell_sort.html-RYeqqTj9.js" as="script"><link rel="prefetch" href="/blog/assets/smooth_sort.html-B0t6JSLd.js" as="script"><link rel="prefetch" href="/blog/assets/stooge_sort.html-YfhFB3iG.js" as="script"><link rel="prefetch" href="/blog/assets/tim_sort.html-BoCSzhxx.js" as="script"><link rel="prefetch" href="/blog/assets/ESXI虚机迁移至OpenStack.html-6EM4grfG.js" as="script"><link rel="prefetch" href="/blog/assets/Kolla使用Libvirt.html-BH6Q3PvO.js" as="script"><link rel="prefetch" href="/blog/assets/Kolla及Ceph部署.html-DBRpVcxj.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BlM2okaw.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DuySOOS7.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-COYjVXza.js" as="script"><link rel="prefetch" href="/blog/assets/环境搭建.html-BwslABub.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bk5wCQBA.js" as="script"><link rel="prefetch" href="/blog/assets/Schema变更.html-CmXDyeR-.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bl4wowJu.js" as="script"><link rel="prefetch" href="/blog/assets/动态分区和RoutineLoad.html-BYzTxZd0.js" as="script"><link rel="prefetch" href="/blog/assets/存算分离.html-9GVDpuqQ.js" as="script"><link rel="prefetch" href="/blog/assets/数据划分.html-yeEAwxQ-.js" as="script"><link rel="prefetch" href="/blog/assets/数据库建表最佳实践.html-CU31WBJ2.js" as="script"><link rel="prefetch" href="/blog/assets/日志存储最佳实践.html-BJPmJmHB.js" as="script"><link rel="prefetch" href="/blog/assets/表模型.html-lvuDP8dJ.js" as="script"><link rel="prefetch" href="/blog/assets/表索引.html-Ck9S3vCk.js" as="script"><link rel="prefetch" href="/blog/assets/表设计.html-tk_DoCsV.js" as="script"><link rel="prefetch" href="/blog/assets/集群部署.html-4idh13Cl.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Cth5DVaR.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-ZicgUK5U.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DoXHiDiT.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CrHNcY8F.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CUx8GfJe.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BHVKGkTF.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-COz27HnP.js" as="script"><link rel="prefetch" href="/blog/assets/query.html-DoPeGCPi.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-w3kLOssO.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DTpqBRxQ.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BxORDID2.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-k7IOKuSo.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-CQB9Z0b8.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-EtRq-J4i.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-JVp3vOGH.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DQBe6C8G.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BHiZJrZY.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DIai_jYU.js" as="script"><link rel="prefetch" href="/blog/assets/TerraformFramework实现Provider.html-DmR-BbHm.js" as="script"><link rel="prefetch" href="/blog/assets/Terraform命令.html-CSe_xkG9.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-B-1hZwCU.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DCKXXjZh.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-C0awBswM.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Wn39Nn3s.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bzvj5tms.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BE5TLZ79.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-BH9xzrDi.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-fENjPdqb.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-DBCYo0z6.js" as="script"><link rel="prefetch" href="/blog/assets/Rsyslog日志转存.html-VynoGpA4.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-49epSqc8.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-B_flGDt0.js" as="script"><link rel="prefetch" href="/blog/assets/SeaTunnel数据库CDC配置.html-ON8CoGPS.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-ChXgdJTg.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Bc5oNQiy.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-B-dcPYv2.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-Ck1dZsqe.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-3t4G-zts.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-KRPZcEBU.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-RQaezZK1.js" as="script"><link rel="prefetch" href="/blog/assets/ZabbixAgent安装及自定义脚本.html-DKURZalB.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-C29L2VNh.js" as="script"><link rel="prefetch" href="/blog/assets/zabbix安装.html-FEQL6thK.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-R3ii_NIK.js" as="script"><link rel="prefetch" href="/blog/assets/index.html-C5_B4zlm.js" as="script"><link rel="prefetch" href="/blog/assets/SQL.html-89x0k9Cm.js" as="script"><link rel="prefetch" href="/blog/assets/数据库优化.html-K6nWNgZK.js" as="script"><link rel="prefetch" href="/blog/assets/数据库索引.html-BX4K5xTn.js" as="script"><link rel="prefetch" href="/blog/assets/数据库锁与事务.html-CS8d_ANn.js" as="script"><link rel="prefetch" href="/blog/assets/Mybatis.html-CIkBxdDk.js" as="script"><link rel="prefetch" href="/blog/assets/Java基础.html-D_QRBbpt.js" as="script"><link rel="prefetch" href="/blog/assets/Java调优.html-B4RoEDf7.js" as="script"><link rel="prefetch" href="/blog/assets/Java进阶.html-Db99JmhM.js" as="script"><link rel="prefetch" href="/blog/assets/反射.html-B9fatXTn.js" as="script"><link rel="prefetch" href="/blog/assets/线程池.html-CxbSCpUd.js" as="script"><link rel="prefetch" href="/blog/assets/锁.html-B6SpjkfJ.js" as="script"><link rel="prefetch" href="/blog/assets/集合.html-CUZ1m7It.js" as="script"><link rel="prefetch" href="/blog/assets/面向对象.html-UMaUbHDD.js" as="script"><link rel="prefetch" href="/blog/assets/jvm.html-BWNS3e3B.js" as="script"><link rel="prefetch" href="/blog/assets/JUC.html-DLUivWNX.js" as="script"><link rel="prefetch" href="/blog/assets/ThreadLocal.html-BYxYh7yT.js" as="script"><link rel="prefetch" href="/blog/assets/多线程.html-BmpsxTLI.js" as="script"><link rel="prefetch" href="/blog/assets/线程池.html-DwozZdb4.js" as="script"><link rel="prefetch" href="/blog/assets/锁.html--5qDdUfD.js" as="script"><link rel="prefetch" href="/blog/assets/Redis.html-BsKKSiRX.js" as="script"><link rel="prefetch" href="/blog/assets/ElasticSearch.html-Pn1J3Cur.js" as="script"><link rel="prefetch" href="/blog/assets/JVM.html-DNvsmY-J.js" as="script"><link rel="prefetch" href="/blog/assets/JVM内存模型.html-CZyniu0B.js" as="script"><link rel="prefetch" href="/blog/assets/JVM对高效并发的支持.html-eb1cM9Dq.js" as="script"><link rel="prefetch" href="/blog/assets/JVM工具和JVM调优.html--xINkAvq.js" as="script"><link rel="prefetch" href="/blog/assets/垃圾回收.html-WnvI2chO.js" as="script"><link rel="prefetch" href="/blog/assets/Spring.html-B4O33Fe1.js" as="script"><link rel="prefetch" href="/blog/assets/SpringBoot.html-O44ccL2x.js" as="script"><link rel="prefetch" href="/blog/assets/SpringMvc.html-C8kgBqP7.js" as="script"><link rel="prefetch" href="/blog/assets/SpringCloudAlibaba.html-BXlIalpv.js" as="script"><link rel="prefetch" href="/blog/assets/SpringCloudNetflix.html-BP0KK0nB.js" as="script"><link rel="prefetch" href="/blog/assets/Zookeeper.html-BlOTU2g8.js" as="script"><link rel="prefetch" href="/blog/assets/分布式事务.html-BphbxoLK.js" as="script"><link rel="prefetch" href="/blog/assets/分布式锁.html-CgINm6oC.js" as="script"><link rel="prefetch" href="/blog/assets/404.html-5cdhF5yj.js" as="script"><link rel="prefetch" href="/blog/assets/setupDevtools-7MC2TMWH-CYpgxpoD.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/blog/"><img class="vp-site-logo" src="/blog/assets/img/game.ico" alt="とんぼの気持ち"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">とんぼの気持ち</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/blog/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="八股文"><span class="title">八股文</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="八股文"><span class="title">八股文</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>Spring Cloud</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloud.html" aria-label="Spring Cloud"><!---->Spring Cloud<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloudAlibaba.html" aria-label="Spring Cloud Alibaba"><!---->Spring Cloud Alibaba<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloudNetflix.html" aria-label="Spring Cloud Netflix"><!---->Spring Cloud Netflix<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>Zookeeper</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/Zookeeper.html" aria-label="Zookeeper"><!---->Zookeeper<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>分布式锁</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/分布式锁.html" aria-label="分布式锁"><!---->分布式锁<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>分布式事务</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/分布式事务.html" aria-label="分布式事务"><!---->分布式事务<!----></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/hyfly233/blog" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/blog/" aria-label="Home"><!---->Home<!----></a></div><div class="vp-navbar-item"><div class="vp-navbar-dropdown-wrapper"><button class="vp-navbar-dropdown-title" type="button" aria-label="八股文"><span class="title">八股文</span><span class="arrow down"></span></button><button class="vp-navbar-dropdown-title-mobile" type="button" aria-label="八股文"><span class="title">八股文</span><span class="right arrow"></span></button><ul style="display:none;" class="vp-navbar-dropdown"><!--[--><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>Spring Cloud</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloud.html" aria-label="Spring Cloud"><!---->Spring Cloud<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloudAlibaba.html" aria-label="Spring Cloud Alibaba"><!---->Spring Cloud Alibaba<!----></a></li><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/SpringCloudNetflix.html" aria-label="Spring Cloud Netflix"><!---->Spring Cloud Netflix<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>Zookeeper</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/Zookeeper.html" aria-label="Zookeeper"><!---->Zookeeper<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>分布式锁</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/分布式锁.html" aria-label="分布式锁"><!---->分布式锁<!----></a></li><!--]--></ul><!--]--></li><li class="vp-navbar-dropdown-item"><!--[--><h4 class="vp-navbar-dropdown-subtitle"><span>分布式事务</span></h4><ul class="vp-navbar-dropdown-subitem-wrapper"><!--[--><li class="vp-navbar-dropdown-subitem"><a class="route-link auto-link" href="/blog/md/微服务/分布式事务.html" aria-label="分布式事务"><!---->分布式事务<!----></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/hyfly233/blog" aria-label="GitHub" rel="noopener noreferrer" target="_blank"><!---->GitHub<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading"> <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><h3 id="微服务中如何实现-session-共享" tabindex="-1"><a class="header-anchor" href="#微服务中如何实现-session-共享"><span>微服务中如何实现 session 共享</span></a></h3><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p><h3 id="服务注册和发现是什么" tabindex="-1"><a class="header-anchor" href="#服务注册和发现是什么"><span>服务注册和发现是什么</span></a></h3><p>当开始一个项目时，通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。</p><h3 id="负载平衡的意义什么" tabindex="-1"><a class="header-anchor" href="#负载平衡的意义什么"><span>负载平衡的意义什么</span></a></h3><p>负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性，负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程</p><h3 id="springboot-和-springcloud的区别" tabindex="-1"><a class="header-anchor" href="#springboot-和-springcloud的区别"><span>SpringBoot 和 SpringCloud的区别？</span></a></h3><ul><li>SpringBoot 专注于快速方便的开发单个个体微服务，SpringCloud 是关注全局的微服务协调整理治理框架，它将 SpringBoot 开发的一个个单体微服务整合并管理起来，为各个微服务之间提供配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</li><li>SpringBoot 可以离开 SpringCloud 独立使用开发项目， 但是 SpringCloud 离不开 SpringBoot ，属于依赖的关系</li></ul><h3 id="spring-cloud-是什么" tabindex="-1"><a class="header-anchor" href="#spring-cloud-是什么"><span>Spring Cloud 是什么</span></a></h3><ul><li>Spring Cloud 是一系列框架的有序集合。它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署</li><li>Spring Cloud 并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包</li></ul><h3 id="zuulfilter-常用有那些方法" tabindex="-1"><a class="header-anchor" href="#zuulfilter-常用有那些方法"><span>ZuulFilter 常用有那些方法</span></a></h3><ul><li>Run()：过滤器的具体业务逻辑</li><li>shouldFilter()：判断过滤器是否有效</li><li>filterOrder()：过滤器执行顺序</li><li>filterType()：过滤器拦截位置</li></ul><h3 id="什么是耦合" tabindex="-1"><a class="header-anchor" href="#什么是耦合"><span>什么是耦合</span></a></h3><p>组件之间依赖关系强度的度量被认为是耦合，一个好的设计总是被认为具有高内聚力和低耦合性</p><h3 id="eureka-和-zookeeper-的区别" tabindex="-1"><a class="header-anchor" href="#eureka-和-zookeeper-的区别"><span>Eureka 和 ZooKeeper 的区别</span></a></h3><p>Eureka 和 ZooKeeper 是两种不同的服务注册中心。下面是它们之间的一些区别：</p><ol><li>语言 Eureka 是用 Java 编写的，而 ZooKeeper 是用 C 编写的</li><li>CAP 理论 Eureka 遵循 AP 原则（可用性和分区容错性），而 ZooKeeper 遵循 CP 原则（一致性和分区容错性）</li><li>治理能力 Eureka 专注于服务治理，而 ZooKeeper 则是一个通用的分布式协调器，可以处理各种不同类型的数据</li><li>部署复杂性 ZooKeeper 的部署需要较多的配置和管理，而 Eureka 的部署比较简单</li><li>功能 ZooKeeper 提供了更多的功能，例如分布式锁和队列等，而 Eureka 仅提供了服务注册和发现</li><li>生态系统 Eureka 是 Netflix 的一部分，而 ZooKeeper 是 Apache 的一个项目，它们都有自己的生态系统</li><li>使用场景 Eureka 更适合在云环境中使用，而 ZooKeeper 更适合在企业级环境中使用</li><li>节点 ZooKeeper 有 Leader 和 Follower 角色，Eureka 各个节点平等</li><li>可用性 ZooKeeper 在选举期间注册服务瘫痪，虽然服务最终会恢复，但是选举期间不可用的，而 Eureka 各个节点是平等关系，只要有一台 Eureka 就可以保证服务可用，仍然能够接受新服务的注册和查询请求，但是不会立即被同步到其他节点，当网络稳定时，当前实例新的注册信息会被同步到其他节点中</li><li>数据是否最新 ZooKeeper 查询到的服务是最新的，服务提供者有注册和注销功能，Zookeeper 通过消费者的监听器通知其更新服务提供者列表，保证获取的服务是最新的，Eureka 查询到的服务并不是最新的，自我保护机制会导致Eureka 不再从注册列表移除因长时间没收到心跳而应该过期的服务</li><li>ZooKeeper 采用过半数存活原则，Eureka 采用自我保护机制解决分区问题</li><li>Eureka 本质上是一个工程，而 ZooKeeper 只是一个进程</li></ol><h3 id="zookeeper-能保证获取的数据是最新的吗" tabindex="-1"><a class="header-anchor" href="#zookeeper-能保证获取的数据是最新的吗"><span>ZooKeeper 能保证获取的数据是最新的吗</span></a></h3><p>ZooKeeper 保证客户端获得的数据是最新的。 当ZooKeeper 接收到客户端的写请求时，它会将请求写入内存和事务日志中。然后，它会将数据复制到其他ZooKeeper 节点的内存和事务日志中，并等待大多数节点的确认。一旦大多数节点都确认了写入请求，ZooKeeper就会将数据提交到内存数据库和磁盘事务日志中。 客户端在连接 ZooKeeper 服务器时会建立一个会话，该会话维护着客户端与服务器之间的心跳和通信。当客户端连接到 ZooKeeper 时，它会请求最新的视图（也称为 znode），并在会话期间保持该视图不变。如果发生任何更改，客户端会收到通知，并从 ZooKeeper 获取最新的视图。 因此，ZooKeeper 可以保证客户端获得的数据是最新的，而且不需要客户端进行额外的轮询。</p><h3 id="zookeeper-能保证获取的服务是最新的吗" tabindex="-1"><a class="header-anchor" href="#zookeeper-能保证获取的服务是最新的吗"><span>ZooKeeper 能保证获取的服务是最新的吗</span></a></h3><p>ZooKeeper 能保证获取的服务是最新的。 ZooKeeper 提供了服务注册和发现的功能。服务提供者在启动时将自己注册到 ZooKeeper 上，并在停止时注销。服务消费者在启动时从 ZooKeeper 上查询可用的服务提供者列表，并监听服务提供者节点的变化。 当服务提供者发生变化时，ZooKeeper会通知监听者。消费者在接收到变更通知后，会重新从 ZooKeeper 获取最新的服务提供者列表，因此可以保证获取到的服务是最新的。 总之，ZooKeeper 提供了强一致性和实时性的保证，因此能够保证获取的服务是最新的。</p><h3 id="分布式系统脑裂-todo" tabindex="-1"><a class="header-anchor" href="#分布式系统脑裂-todo"><span>分布式系统脑裂 todo</span></a></h3><h3 id="网关的作用是什么" tabindex="-1"><a class="header-anchor" href="#网关的作用是什么"><span>网关的作用是什么</span></a></h3><p>网关（Gateway）是系统架构中的一种设计模式，它作为系统的入口，扮演着路由、鉴权、限流、降级等功能的角色，可以理解为一个系统的“大门”。 具体来说，网关的作用主要包括：</p><ol><li>路由转发：将请求转发到不同的服务实例或者不同的后端服务，实现请求的转发和路由功能。</li><li>鉴权：对请求进行身份认证和权限校验，只有通过认证和校验的请求才能进入系统内部。</li><li>限流：对请求进行流量控制和限流，防止系统被过多请求压垮。</li><li>降级：当后端服务出现故障或者系统异常时，网关可以提供静态数据或者友好的错误提示，避免将错误传递给终端用户。</li><li>统一日志：记录系统的请求日志和响应日志，方便系统监控和问题排查。</li></ol><p>网关可以提高系统的可靠性、安全性和可扩展性，是微服务架构中非常重要的一部分。常见的网关有 Spring Cloud Gateway、Zuul 等。</p><h3 id="ribbon-和-feign-调用服务的区别" tabindex="-1"><a class="header-anchor" href="#ribbon-和-feign-调用服务的区别"><span>Ribbon 和 Feign 调用服务的区别</span></a></h3><p>Ribbon 和 Feign 都是 Spring Cloud 中用来调用服务的工具，它们的主要区别如下：</p><ol><li>Ribbon 是一个客户端负载均衡工具，它能够从服务注册中心获取可用的服务实例列表，并根据负载均衡算法选择其中的一台进行请求转发 Feign 则是一个基于 Ribbon 实现的声明式 HTTP 客户端，它将服务调用接口的定义和服务调用的实现解耦，使用起来更加方便简洁</li><li>Ribbon 可以直接使用 RestTemplate 或 HttpClient 等工具进行 HTTP 请求，也可以使用 Feign 进行请求 Feign 只能使用默认的 HTTP 客户端进行请求</li><li>Ribbon 可以灵活地配置负载均衡算法和策略，以满足不同场景下的负载均衡需求 Feign 则只支持简单的负载均衡算法，并且只能在客户端进行负载均衡，无法实现服务端负载均衡</li><li>Ribbon 可以灵活地进行服务调用的拦截和自定义处理 Feign 则对于请求的拦截和处理支持程度较低</li></ol><p>综上，Ribbon 适合需要更多自定义负载均衡策略和处理逻辑的场景，而 Feign 则更适合在 Spring Cloud 环境中快速地进行服务调用</p><h3 id="微服务的特点" tabindex="-1"><a class="header-anchor" href="#微服务的特点"><span>微服务的特点</span></a></h3><ul><li>解耦：系统内的服务很大程度上是分离的。因此，整个应用程序可以轻松构建，更改和扩展</li><li>组件化：微服务被视为可以轻松更换和升级的独立组件</li><li>业务能力：微服务非常简单，专注于单一功能</li><li>自治：开发人员和团队可以彼此独立工作，从而提高速度</li><li>持续交付：通过软件创建，测试和批准的系统自动化，允许频繁发布软件</li><li>责任：微服务不关注应用程序作为项目。相反，他们将应用程序视为他们负责的产品</li><li>分散治理：重点是使用正确的工具来做正确的工作。这意味着没有标准化模式或任何技术模式。开发人员可以自由选择最有用的工具来解决他们的问题</li><li>敏捷：微服务支持敏捷开发。任何新功能都可以快速开发并再次丢弃</li></ul><h3 id="微服务之间是如何独立通讯" tabindex="-1"><a class="header-anchor" href="#微服务之间是如何独立通讯"><span>微服务之间是如何独立通讯</span></a></h3><ul><li>HTTP/REST：每个服务都可以发布其 API，并暴露 HTTP 接口</li><li>RPC（Remote Procedure Call）：服务通过本地调用另一个服务的接口实现远程调用</li><li>MQ：AMQP（Advanced Message Queuing Protocol）和 Apache Kafka 等，用于在微服务之间进行异步通信和数据传输，以确保服务之间的解耦，并支持在不同的语言和框架之间进行通信。</li></ul><h3 id="为什么需要微服务容器" tabindex="-1"><a class="header-anchor" href="#为什么需要微服务容器"><span>为什么需要微服务容器</span></a></h3><p>要管理基于微服务的应用程序，容器是最简单的选择。它帮助用户单独部署和开发。可以使用 Docker 将微服务封装到容器的镜像中。没有任何额外的依赖或工作，微服务可以使用这些元素</p><h3 id="spring-cloud-和-dubbo-有哪些区别" tabindex="-1"><a class="header-anchor" href="#spring-cloud-和-dubbo-有哪些区别"><span>Spring Cloud 和 dubbo 有哪些区别</span></a></h3><p>Spring Cloud 和 Dubbo 都是分布式微服务框架，它们的区别主要体现在以下几个方面：</p><ol><li>语言支持：Spring Cloud 基于 Java 生态圈，而 Dubbo 支持 Java 和其他语言（如 Go、Node.js 等）。</li><li>面向对象设计和面向过程设计：Spring Cloud 采用面向对象设计，提供了很多通用的组件和框架；而 Dubbo 采用面向过程设计，提供了很多可扩展的点，可以根据具体需求进行扩展。</li><li>服务注册和发现：Spring Cloud 基于 Eureka 或 Consul 等注册中心实现服务的注册和发现，而 Dubbo 使用 ZooKeeper 作为注册中心。</li><li>通信协议：Spring Cloud 采用 HTTP 或者基于 TCP 的协议进行通信，Dubbo 基于 TCP 协议进行通信。</li><li>开发难度：Spring Cloud 提供了更加简单的开发模式和高层次的抽象，使开发人员可以更快地上手开发；而 Dubbo 的开发相对较为复杂，需要开发人员掌握更多的知识。</li></ol><p>需要注意的是，Spring Cloud 和 Dubbo 并不是相互排斥的，可以在某些场景下结合使用，例如可以使用 Dubbo 作为 RPC 框架，使用 Spring Cloud 作为整个微服务架构的部署和管理工具。</p><h3 id="spring-cloud-config-可以实现实时刷新吗" tabindex="-1"><a class="header-anchor" href="#spring-cloud-config-可以实现实时刷新吗"><span>Spring Cloud Config 可以实现实时刷新吗</span></a></h3><p>spring cloud config 实时刷新采用 Spring Cloud Bus 消息总线</p><h3 id="zookeeper如何保证-cp" tabindex="-1"><a class="header-anchor" href="#zookeeper如何保证-cp"><span>Zookeeper如何保证 CP</span></a></h3><p>当 master 节点因为⽹络故障与其他节点失去联系时，剩余节点会重新进⾏ leader 选举</p><h3 id="zuul与nginx有什么区别" tabindex="-1"><a class="header-anchor" href="#zuul与nginx有什么区别"><span>Zuul与Nginx有什么区别？</span></a></h3><p>Zuul 是 java 语言实现的，主要为 java 服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx 是使用 C 语言实现，性能高于 Zuul，但是实现自定义操作需要熟悉 lua 语言，对程序员要求较高，可以使用 Nginx 做 Zuul 集群。</p><h3 id="eureka自我保护模式" tabindex="-1"><a class="header-anchor" href="#eureka自我保护模式"><span>Eureka自我保护模式</span></a></h3><p>默认情况下，如果 Eureka Service 在一定时间内没有接收到某个微服务的心跳，Eureka Service 会进入自我保护模式，在该模式下 Eureka Service 会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式</p><h3 id="服务降级是什么" tabindex="-1"><a class="header-anchor" href="#服务降级是什么"><span>服务降级是什么</span></a></h3><ul><li>服务降级（Service Degradation） 是指在出现服务故障或服务异常的情况下，为了保证系统整体稳定性和可用性，临时关闭不重要的功能，或者提供一个简化的备选方案，以减少系统资源的占用和响应时间的延迟</li><li>服务降级的目的 减轻系统负荷，确保核心功能的正常运行，以避免整个系统因为一个服务的异常而崩溃。通过服务降级，可以让用户在不影响核心功能的情况下继续使用系统，从而提高系统的可用性</li><li>服务降级需要在系统设计和架构上提前考虑和规划，在服务出现故障或异常的情况下，需要有相应的降级方案和策略。例如，可以采用熔断器（Circuit Breaker）来实现服务降级，当服务出现故障或异常时，熔断器可以立即切断服务调用，并返回一个预设的响应，避免等待超时和重试等操作导致的资源浪费和延迟。</li></ul><h3 id="服务降级是如何实现的" tabindex="-1"><a class="header-anchor" href="#服务降级是如何实现的"><span>服务降级是如何实现的？</span></a></h3><ul><li>服务降级是通过在服务调用链路中加入熔断器（Circuit Breaker）来实现的</li><li>熔断器是一种可以自我监控、自我保护和自我修复的机制，当服务发生故障或者超时时，熔断器会自动切断服务调用，从而避免故障扩散和服务雪崩的情况发生</li><li>具体来说，熔断器会维护一个计数器，记录一定时间内服务调用失败的次数， <ul><li>当失败次数达到一定阈值时，熔断器就会进入打开状态，此时所有对该服务的调用都会直接返回错误信息，而不会继续调用后端服务，这样可以减轻后端服务的负担</li><li>当一定时间内服务调用次数低于阈值时，熔断器会进入半开状态，此时允许一部分流量通过进行测试，如果测试通过则熔断器会恢复正常调用，否则重新进入打开状态</li></ul></li><li>熔断器框架有：Netflix 的 Hystrix、Alibaba 的 Sentinel，也可以自己手动实现。无论采用何种方式，熔断器都需要在服务之间的调用中进行集成和配置</li><li>Hystrix 实现服务降级的功能是通过重写 HystrixCommand 中的 getFallback() 方法，当 Hystrix 的 run 方法或 construct 执行发生错误时转而执行 getFallback() 方法</li></ul><h3 id="接口限流方法" tabindex="-1"><a class="header-anchor" href="#接口限流方法"><span>接⼝限流⽅法？</span></a></h3><p>接⼝限流就是限制总并发数（⽐如：数据库连接池、线程池）</p><ul><li>限制瞬时并发数（如 nginx 的 limit_conn 模块，⽤来限制瞬时并发连接数）</li><li>限制时间窗⼝内的平均速率（如 Guava 的 RateLimiter、nginx 的 limit_req 模块，限制每秒的平均速率）</li><li>限制远程接⼝调⽤速率</li><li>限制 MQ 的消费速率</li></ul><p>可以根据⽹络连接数、⽹络流量、CPU或内存负载等来限流</p><h3 id="eureka-服务注册与发现原理" tabindex="-1"><a class="header-anchor" href="#eureka-服务注册与发现原理"><span>Eureka 服务注册与发现原理</span></a></h3><p>Eureka 是 Netflix 开源的一款服务注册和发现的组件，用于实现微服务架构中的服务注册和发现 Eureka 的架构由 Eureka Server 和 Eureka Client 两部分组成。Eureka Server 是服务注册中心，它是一个单独的应用程序，用于接收客户端注册服务实例信息并维护服务实例信息的注册表。Eureka Client 是服务提供者和服务消费者的客户端，用于向 Eureka Server 注册服务实例信息，并从 Eureka Server 中获取其他服务实例信息。Eureka Client 还可以通过心跳机制向 Eureka Server 发送自己的健康状态信息 Eureka 的服务注册流程如下：</p><ol><li>Eureka Client 向 Eureka Server 发送注册请求，包括服务名、服务实例IP和端口等信息</li><li>Eureka Server 将服务实例信息存储到注册表中，并通过心跳机制监控服务实例的健康状态</li><li>Eureka Client 通过心跳机制定期向 Eureka Server 发送自己的健康状态信息，如果服务实例出现故障或停止响应，则 Eureka Server 将从注册表中删除该服务实例信息</li></ol><p>Eureka 的服务发现流程如下：</p><ol><li>Eureka Client 向 Eureka Server 发送查询请求，包括要调用的服务名</li><li>Eureka Server 返回服务名对应的所有服务实例信息列表</li><li>Eureka Client 从服务实例信息列表中选择一台服务实例进行调用，如果调用失败则重试或选择其他服务实例进行调用</li></ol><p>总的来说，Eureka 实现了服务的自动注册和发现，使得服务提供者和服务消费者可以自动发现和调用其他服务，从而实现微服务架构的高效运作</p><h3 id="eureka-心跳机制" tabindex="-1"><a class="header-anchor" href="#eureka-心跳机制"><span>Eureka 心跳机制</span></a></h3><p>Eureka 客户端向 Eureka Server 注册时，会每隔 30 秒发送一次心跳，以告诉 Eureka Server 该客户端依然处于活动状态。Eureka Server 在接收到心跳的同时，会更新自己维护的服务实例的状态。如果一个服务实例的心跳超过了 90 秒（默认），Eureka Server 会将其剔除。服务消费方也会定时向 Eureka Server 请求注册表，以获取最新的服务实例信息。这样，Eureka Server 就能够在服务实例发生故障时，快速地将其从服务注册表中移除，从而达到实现服务的高可用和自我治愈的目的。</p><h3 id="多个消费者调用同一接口-eureka-默认的分配方式是什么" tabindex="-1"><a class="header-anchor" href="#多个消费者调用同一接口-eureka-默认的分配方式是什么"><span>多个消费者调⽤同⼀接⼝，Eureka 默认的分配⽅式是什么</span></a></h3><p>默认使用的是按顺序轮询方式（Round-Robin）来分配请求，即将请求平均分配给每个可用的服务提供者。每个请求都将由下一个服务提供者处理，以此循环下去。这样可以实现负载均衡，提高系统的可用性和性能。如果某个服务提供者宕机或者下线，Eureka 会将其从服务列表中移除，避免向该服务提供者发送请求，从而保证了系统的稳定性</p><h3 id="eureka-有哪些分配方式" tabindex="-1"><a class="header-anchor" href="#eureka-有哪些分配方式"><span>Eureka 有哪些分配方式</span></a></h3><p>Eureka 有两种分配方式：Round Robin 和 Random</p><ul><li>Round Robin：指按照顺序轮流分配服务实例，当一次请求分配不成功时，会尝试分配下一个服务实例</li><li>Random：随机分配服务实例，可以在不同的请求中获得不同的服务实例，从而平衡负载</li></ul><h3 id="eureka-的缓存机制是什么" tabindex="-1"><a class="header-anchor" href="#eureka-的缓存机制是什么"><span>Eureka 的缓存机制是什么</span></a></h3><p>Eureka 缓存机制是指服务注册中心在注册和取消服务的时候，将注册信息放入本地缓存中，以减少注册中心的网络通信压力和提升查询效率 Eureka 客户端在启动时，会首先从 Eureka 服务端获取当前注册中心中所有的服务信息，然后会定期（默认30s）的从 Eureka 服务端获取服务注册列表信息，此时会返回一个新的服务注册列表信息，客户端将此服务注册列表信息放入到缓存中 当其他服务需要调用该服务时，服务消费者会在自己的缓存中查找可用的服务列表。如果在本地缓存中未找到可用的服务列表，服务消费者将会向注册中心发起服务查询请求，查询服务提供者的地址列表并将其缓存在本地缓存中，下次其他服务再次请求该服务时就可以从本地缓存中获取到可用的服务列表，不用再次向注册中心发起请求 Eureka 缓存机制通过本地缓存，减少了对 Eureka 服务端的调用，避免了服务注册中心的过载，同时也提升了服务查询的效率</p><h3 id="discoveryclient-的作用" tabindex="-1"><a class="header-anchor" href="#discoveryclient-的作用"><span>DiscoveryClient 的作用</span></a></h3><p>DiscoveryClient 是 Spring Cloud 中的一个组件（org.springframework.cloud.client.discovery.DiscoveryClient），用于向服务注册中心（例如 Eureka、Consul 等）发现服务和获取服务信息，同时也支持本地缓存服务信息，提高服务发现效率。 DiscoveryClient 的作用如下：</p><ol><li>与服务注册中心进行交互，获取注册中心中注册的所有服务信息；</li><li>将获取到的服务信息存储在本地缓存中，便于快速访问；</li><li>向注册中心订阅服务变化事件，及时更新本地服务缓存；</li><li>提供 API 接口，供其他组件或应用程序调用，获取服务信息。</li></ol><p>总之，DiscoveryClient 提供了服务发现的核心功能，是微服务架构中的重要组成部分。</p><h3 id="服务降级、服务熔断、服务隔离" tabindex="-1"><a class="header-anchor" href="#服务降级、服务熔断、服务隔离"><span>服务降级、服务熔断、服务隔离</span></a></h3><p>服务降级、服务熔断、服务隔离是微服务架构中的重要概念，用于提高系统的可靠性和可用性</p><ul><li>服务降级：服务降级是指当系统资源不足、系统负载过高或者第三方服务不可用等情况下，为了保证核心服务的可用性，暂时关闭一些非核心服务，或者切换为备用方案。通过服务降级，可以减少不必要的等待和资源占用，提高系统的吞吐量和响应速度，同时保证核心服务的可用性</li><li>服务熔断：服务熔断是一种自我保护机制，用于处理服务调用时出现的故障，防止故障扩散，提高系统的可靠性和稳定性。当服务调用失败的次数达到一定阈值时，熔断器会打开，停止向该服务发起请求，直接返回错误响应。在一定时间内，熔断器会定时检查该服务的可用性，如果可用，则关闭熔断器，恢复正常调用</li><li>服务隔离：服务隔离是一种将不同的服务放到不同的容器中运行，防止不同服务之间的故障相互影响，提高系统的稳定性和可用性。通过服务隔离，可以将相互依赖的服务分开运行，避免因为某个服务出现故障而导致整个系统崩溃的情况发生</li></ul><h3 id="如何实现动态-zuul-网关路由转发" tabindex="-1"><a class="header-anchor" href="#如何实现动态-zuul-网关路由转发"><span>如何实现动态 Zuul 网关路由转发</span></a></h3><p>实现动态 Zuul 网关路由转发需要结合 Spring Cloud Config、Zuul 和 Eureka 三个组件进行配置和实现。 具体步骤如下：</p><ol><li>在 Spring Cloud Config 中配置 Zuul 路由规则，将路由规则存储在 Config Server 中。</li><li>在 Zuul 中添加 Config Client 的依赖。</li><li>在 Zuul 的配置文件中添加 Config Server 的配置信息，以便从 Config Server 中获取配置。</li><li>在 Zuul 中添加 Eureka Client 的依赖。</li><li>配置 Eureka Client 信息，从 Eureka Server 中获取服务列表。</li><li>添加动态路由规则的接口，当动态修改路由规则时，通过接口更新 Config Server 中的路由规则。</li><li>在 Zuul 中添加路由转发的过滤器，当请求进来时，通过路由规则进行路由转发。</li></ol><p>通过上述步骤，就可以实现动态 Zuul 网关路由转发。当需要修改路由规则时，只需要更新 Config Server 中的路由规则即可，Zuul 会自动从 Config Server 中获取最新的路由规则，并根据路由规则进行路由转发。</p><h3 id="ribbon-底层实现原理" tabindex="-1"><a class="header-anchor" href="#ribbon-底层实现原理"><span>Ribbon 底层实现原理</span></a></h3><p>Ribbon 是一个负载均衡框架，它的底层实现主要是通过使用 Ribbon 的客户端组件，结合多种负载均衡算法实现的</p><ul><li>Ribbon 的核心组件是 ILoadBalancer 接口，它定义了负载均衡器的基本行为，包括获取服务实例列表和选择一个实例等。在 ILoadBalancer 的具体实现中，Ribbon 提供了很多负载均衡算法实现，比如轮询、加权轮询、随机等算法。Ribbon 还提供了许多扩展接口，如 IPing、IRule、ServerListFilter 等，用于定制化不同场景下的负载均衡策略</li><li>在使用 Ribbon 时，客户端会向 Eureka 等服务注册中心获取服务实例列表，然后通过负载均衡器从实例列表中选择一个实例进行服务调用。Ribbon 还提供了缓存机制，将服务实例列表缓存在客户端内存中，减少对服务注册中心的访问。</li></ul><p>总之，Ribbon 是通过在客户端实现负载均衡来提高系统的可靠性和可用性，同时提供了多种负载均衡算法和扩展接口，可以根据具体的场景和需求进行定制化的配置。</p><h3 id="loadbalanced-注解实现原理" tabindex="-1"><a class="header-anchor" href="#loadbalanced-注解实现原理"><span>@LoadBalanced 注解实现原理</span></a></h3><ul><li>@LoadBalanced 注解是 Spring Cloud 提供的一个负载均衡的注解，它可以在 RestTemplate 和 WebClient 上使用，用于让它们具有负载均衡的能力</li></ul><div class="language-java line-numbers-mode line-numbers-mode" data-highlighter="prismjs" data-ext="java" data-title="java"><pre class="shiki nord vp-code" style="background-color:#2e3440ff;color:#d8dee9ff language-java;"><code><span class="line"><span class="line"><span style="color:#ECEFF4;">@</span><span style="color:#D08770;">LoadBalanced</span></span></span>
<span class="line"><span class="line"><span style="color:#ECEFF4;">@</span><span style="color:#D08770;">Autowired</span></span></span>
<span class="line"><span class="line"><span style="color:#81A1C1;">private</span><span style="color:#8FBCBB;"> RestTemplate</span><span style="color:#D8DEE9;"> restTemplate</span><span style="color:#81A1C1;">;</span></span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>实现原理是通过在 RestTemplate 或 WebClient 中添加拦截器的方式，在发送 HTTP 请求之前先从服务注册中心中获取可用的服务实例列表，然后使用负载均衡算法从实例列表中选择一个实例作为目标进行请求。这个过程是通过使用 Spring Cloud LoadBalancer 中提供的 LoadBalancerClient 接口实现的</li><li>当使用 @LoadBalanced 注解时，Spring 会在应用上下文中注册一个名为 loadBalancedRetryFactory 的 RetryListener 对象，然后创建一个带有 LoadBalancerInterceptor 的 RestTemplateCustomizer，并将其加入到 RestTemplate 实例的拦截器链中，从而实现负载均衡的能力。在执行 HTTP 请求时，LoadBalancerInterceptor 会通过 LoadBalancerClient 获取可用的服务实例列表，并使用负载均衡算法选择一个实例作为目标进行请求</li></ul><h3 id="nginx-与-ribbon-的区别" tabindex="-1"><a class="header-anchor" href="#nginx-与-ribbon-的区别"><span>Nginx 与 Ribbon 的区别</span></a></h3><p>Nginx 和 Ribbon 都是负载均衡器，但它们的设计思想和用途略有不同</p><ul><li>Nginx 是一个高性能的 Web 服务器和反向代理服务器，它的主要用途是接收客户端请求并将请求转发到服务器端的应用程序。Nginx 使用的是基于 IP 的负载均衡，根据请求的 IP 地址或其他基于 IP 的规则将请求路由到不同的服务器上</li><li>Ribbon 是一个客户端负载均衡器，它通常与服务消费者一起使用，用于从服务提供者列表中选择一个实例来处理客户端请求。Ribbon 使用的是基于客户端的负载均衡，它通过轮询、随机选择、加权随机选择等算法从可用的服务实例列表中选择一个实例来处理请求。Ribbon 可以与 Eureka 等服务注册中心集成，自动从注册中心获取可用的服务实例列表</li></ul><p>总的来说，Nginx 更适用于 Web 应用程序的负载均衡和反向代理，而 Ribbon 更适用于微服务架构中服务消费者的负载均衡</p><h3 id="单片-soa-和微服务架构有什么区别" tabindex="-1"><a class="header-anchor" href="#单片-soa-和微服务架构有什么区别"><span>单片，SOA 和微服务架构有什么区别</span></a></h3><p>单片架构（Monolithic Architecture）、SOA 架构（Service-Oriented Architecture）和微服务架构（Microservices Architecture）是三种不同的架构模式</p><ul><li>在单片架构中，整个应用程序被设计为一个单独的可执行文件或进程。所有功能模块都在同一个代码库中，共享相同的资源（如内存、CPU 等）。这种架构通常难以扩展和维护。</li><li>在 SOA 架构中，应用程序被分解为一组服务，每个服务都提供一个特定的功能，可以被其他服务或者应用程序调用。服务之间通过定义良好的接口和协议来通信，使得服务可以独立于其实现和部署。SOA 的目标是实现松散耦合的服务，可以随意添加、删除和修改服务，但是它的实现往往过于复杂，增加了维护的难度。</li><li>在微服务架构中，应用程序被分解为一组小型、自治的服务，每个服务都独立运行、部署和扩展。每个服务都专注于单个业务领域，并且可以使用不同的技术堆栈、数据存储、部署策略等。服务之间通过定义良好的接口和协议来通信，使得服务可以独立于其实现和部署。这种架构提供了更好的可伸缩性、灵活性和可维护性，但同时也带来了管理多个服务的挑战。</li></ul><h3 id="什么是-semantic-监控" tabindex="-1"><a class="header-anchor" href="#什么是-semantic-监控"><span>什么是 Semantic 监控</span></a></h3><p>Semantic 监控是一种基于语义信息的应用性能监控方法。它通过对应用程序的运行时语义信息进行分析和监测，提取出业务逻辑的关键性能指标，而非仅仅关注服务器或系统的资源使用情况，从而更好地反映应用程序的运行状态和性能状况。这种方法可以更好地理解和诊断应用程序的问题，提升应用程序的可观测性和可维护性。常见的应用性能监控工具如 Zipkin、Prometheus 等，都支持 Semantic 监控。</p></div><!--[--><!--]--></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link label" href="https://github.com/hyfly233/blog/edit/main/md/interview/java/framework/springcloud/SpringCloud.md" aria-label="Edit this page" rel="noopener noreferrer" target="_blank"><!--[--><svg class="edit-icon" viewbox="0 0 1024 1024"><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->Edit this page<!----></a></div><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最后更新时间: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: hyfly233@outlook.com">hyfly233</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/blog/assets/app-chPKMbRn.js" defer></script>
  </body>
</html>
