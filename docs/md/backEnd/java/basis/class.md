# 面向对象

## 对象

对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位

类的实例化可生成对象，一个对象的生命周期包括三个阶段：生成、使用、消除

当不存在对一个对象的引用时，该对象成为一个无用对象。垃圾收集器自动扫描对象的动态内存区，把没有引用的对象作为垃圾收集起来并释放。当系统内存用尽或调用`System.gc()`要求垃圾回收时，垃圾回收与系统同步运行



## 类

类是具有相同属性和方法的一组对象的集合，它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和方法两个主要部分



## 面向对象的特性

+ 封装：指隐藏对象的属性和现实细节，仅对外提供公共访问方式
+ 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继 承信息的类被称为子类（派生类）
+ 多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应



## 多态的实现

多态性分为`编译时的多态性`和`运行时的多态性`

运行时的多态：

+ 继承父类重写方法，及Override
+ 接口实现
+ 父类型引用指向子类型对象

编译时多态：

+ 同一类中进行方法重载，及Overload



### 重载 Overload

发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载



### 重写 Override

发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）



### 特殊情况

1. 构造方法，不能被继承，不能被重写，但可以被重载
2. 父类的静态方法不能被子类重写，重写只适用于实例方法（如果子类当中含有和父类相同签名的静态方法，称之为隐藏，调用的方法为定义的类所有的静态方法）



## 多态的好处

- 可替换性：多态对已存在代码具有可替换性.
- 可扩充性：增加新的子类不影响已经存在的类结构.
- 接口性：多态是超类通过方法签名,向子类提供一个公共接口,由子类来完善或者重写它来实现的.
- 灵活性：它在应用中体现了灵活多样的操作，提高了使用效率
- 简化性：多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要



## 虚拟机实现多态

使用的是``动态绑定技术(dynamic binding)``，执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法

在类继承之后，一个对象变量在运行过程中可以自动寻找合适的方法执行，这称为动态绑定



## 抽象类

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类

抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样，使用`abstract`关键字



## 接口

接口(Interface)，是一个抽象类型，是抽象方法的集合，接口以interface来声明。接口并不是类，类描述对象的属性和方法，接口则包含类要实现的方法



## 抽象类和接口的区别

1. 抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用
2. 一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类
3. 接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法
4. 抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的
5. 抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量
6. 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。



## 六原则一法则

- 单一职责原则：一个类只做它该做的事情
- 开闭原则：软件实体应当对扩展开放，对修改关闭

- 依赖倒转原则：面向接口编程

- 里氏替换原则：任何时候都可以用子类型替换掉父类型

- 接口隔离原则：接口要小而专，绝不能大而全

- 合成聚合复用原则：优先使用聚合或合成关系复用代码

- 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解



# 引用

## 引用类型

强引用、软引用、弱引用、虚引用

不同的引用类型主要体现在GC上，在Java中有时候需要适当的控制对象被回收的时机，因此就诞生了不同的引用类型，可以说不同的引用类型实则是对GC回收时机不可控的妥协。

+ 利用软引用和弱引用解决OOM问题，比如：用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题
+ 通过软引用实现对象的高速缓存，比如：创建了一个Person的类，如果每次需要查询一个人的信息，哪怕是几秒中之前刚刚查询过的，都要重新构建一个实例，这将引起大量Person对象的消耗，并且由于这些对象的生命周期相对较短，会引起多次GC影响性能。此时，通过软引用和 HashMap 的结合可以构建高速缓存，提供性能



+ 强引用

  如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出`OutOfMemoryError`错误，使程序异常终止

  如果想中断强引用和某个对象之间的关联，可以显式地将引用`赋值为null`，这样一来的话，JVM在合适的时间就会回收该对象

+ 软引用

  在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收

+ 弱引用

  具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象

+ 虚引用

  形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。





# 核心类

## 字符串

### String

`String`是一个引用类型，它本身也是一个`class`。但是，Java编译器对`String`有特殊处理，即可以直接用双引号`"..."`来表示一个字符串

```java
String s1 = "Hello!";
```



实际上字符串在`String`内部是通过一个`char[]`数组表示的，因此，按下面的写法也是可以的：

```
String s2 = new String(new char[] {'H', 'e', 'l', 'l', 'o', '!'});
```



#### 不可变性

jdk9之前是通过内部的`private final char[] value`字段，以及没有提供任何修改value的方法来实现的

jdk9开始是通过内部的`private final byte[] value`字段加coder编码标识，以及没有提供任何修改value的方法来实现的

```java
// ----------JDK8-----------

// jdk9 之前使用 char[]
private final char[] value;

// ----------JDK9-----------

// jdk9 开始使用 byte[] 和 coder 的组合
private final byte[] value;
// byte 默认值为 0，所以对应 LATIN1
private final byte coder;

// coder 的值
@Native static final byte LATIN1 = 0; // 单字节编码
@Native static final byte UTF16  = 1; // UTF-16 编码

// 默认构造方法
public String() {
    this.value = "".value;
    this.coder = "".coder;
}
```

变更的主要原因是，节省空间，char 占用16位，即两字节，byte 占用8位，即1字节



#### new String()创建了几个字符串对象

如果静态区没有 xyz，`String s = new String(“xyz”)`创建了两个对象，一个静态区的 xyz，一个是用new创建在堆上的对象。如果静态区有 xyz 就是创建的一个（在堆区）









### StringBuilder

### StringBuffer

### StringJoiner



### 包装类型

### JavaBean

