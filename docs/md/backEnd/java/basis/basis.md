

# Basis

## 变量和数据类型

### 基本类型

**byte：**

- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
- 最小值是 -128（-2^7）；
- 最大值是 127（2^7-1）；
- 默认值是 0；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；



**short：**

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 -2^15；
- 最大值是 2^15 - 1；
- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
- 默认值是 0；



**int：**

- int 数据类型是32位、有符号的以二进制补码表示的整数；
- 最小值是 -2^31；
- 最大值是 2^31 - 1；
- 一般地整型变量默认为 int 类型；
- 默认值是 0 ；



**long：**

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 -2^63；
- 最大值是 2^63 -1；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 0L；



**float：**

- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 0.0f；
- 浮点数不能用来表示精确的值，如货币；



**double：**

- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；
- 浮点数的默认类型为double类型；
- double类型同样不能表示精确的值，如货币；
- 默认值是 0.0d；



**boolean：**

- boolean数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 false；



**char：**

- char类型是一个单一的 16 位 Unicode 字符；
- 最小值是 \u0000（即为0）；
- 最大值是 \uffff（即为65,535）；
- char 数据类型可以储存任何字符；



### 引用类型

除开基本类型的数据都是引用类型



#### 4种引用类型





## 运算

#### 整数运算

整数的数值表示不但是精确的，而且整数运算**永远是精确的**，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分

整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而**溢出不会报错**，却会得到一个奇怪的结果 



#### 常用的移位运算，位运算todo





#### 浮点数运算

类型提升：如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型

强制转型： 可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值



### 自增/自减

注意``++/--``写在前面和后面计算结果是不同的

`++n`表示先 加1 再 引用n，`n++`表示先 引用n 再 加1



## 字符和字符串

+ 字符类型`char`是基本数据类型，它是`character`的缩写。一个`char`保存一个Unicode字符
+ 字符串类型`String`是引用类型，我们用双引号`"..."`表示字符串。一个字符串可以存储0个到任意个字符， 字符串是不可变的



+  Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个`char`类型表示，它们都占用`两个字节`。要显示一个字符的Unicode编码，只需将`char`类型直接赋值给`int`类型即可
+ 可以直接用转义字符`\u`+Unicode编码来表示一个字符



## StringBuilder、StringBuffer



## 数组类型

定义一个数组类型的变量，使用数组类型“类型[]”，例如，`int[]`。和单个基本类型变量不同，数组变量初始化必须使用`new int[5]`表示创建一个可容纳5个`int`元素的数组 

数组是`引用类型`，在使用索引访问数组元素时，如果索引超出范围，运行时将报错

```java
int[] ns = new int[] { 68, 79, 91, 85, 62 };
int[] ns = { 68, 79, 91, 85, 62 };
```





## 流程控制

### Switch

字符串匹配时，是比较“内容相等” 

新语法使用`->`，如果有多条语句，需要用`{}`括起来。不要写`break`语句，因为新语法只会执行匹配的语句，没有穿透效应。 

#### yield

在`switch`表达式内部，返回简单的值

 ```java
int opt = switch (fruit) {
    case "apple" -> 1;
    case "pear", "mango" -> 2;
    default -> {
        int code = fruit.hashCode();
        yield code; // switch语句返回值
    }
};
 ```