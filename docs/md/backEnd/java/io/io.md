# Java 序列化

+ 序列化：将对象可以被表示为字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型；
+ 反序列化：将字节序列表示为对象，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象；

整个过程都是 JVM 独立的，也就是说，在一个平台上序列化可以在另一个完全不同的平台上反序列化



类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法 



# NIO



## IO操作最佳实践

- 使用有缓冲的IO类,不要单独读取字节或字符
- 使用NIO和NIO 2或者AIO,而非BIO
- 在finally中关闭流
- 使用内存映射文件获取更快的IO

## Java IO 分类

- Java BIO： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
- Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，每个连接共用一个线程。
- Java AIO(NIO.2) ： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。

## 说出 5 条 IO 的最佳实践

IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：

- 使用有缓冲区的 IO 类，而不要单独读取字节或字符。
- 使用 NIO 和 NIO2
- 在 finally 块中关闭流，或者使用 try-with-resource 语句。
- 使用内存映射文件获取更快的 IO。

## BIO、NIO、AIO适用场景分析

- BIO（同步并阻塞）方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
- NIO（同步非阻塞）方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
- AIO（ 异步非阻塞）方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

## Java NIO和IO的主要区别

1. 面向流与面向缓冲.
   Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。
2. 阻塞与非阻塞IO
   Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。
3. 选择器（Selectors）
   Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。

## Java I/O库的两个设计模式

Java I/O库的总体设计是符合装饰模式和适配器模式的。如前所述，这个库中处理流的类叫流类。

装饰模式（Decorator）：在由InputStream、OutputStream、Reader和Writer代表的等级结构内部，有一些流处理器可以对另一些流处理器起到装饰作用，形成新的、具有改善了的功能的流处理器。

适配器模式（Adapter）：在由InputStream、OutputStream、Reader和Writer代表的等级结构内部，有一些流处理器是对其他类型的流处理器的适配。这就是适配器的应用。







## 网络&IO模型

```
常见问题
1，【网络到分布式lvs+redis+zk】http://mashibing.com/pc.html
2，网络的小课
3，内存与IO，磁盘IO，网络IO

从程序员的角度理解网络通信

面试突击班怎么学，自己时间衡量，一点带面，能够应付变种问题
你有点体系的基础
查漏补缺，建立体系的过程

做规划，面试辅导，又几个进了腾讯：redis+网络+IO
```



1. TCP三次握手

   backlog：

     cat /proc/sys/net/core/somaxconn   ACCEPT队列  你可以给出backlog 取min

   每个人顾好自己，每个人处理好对别人的打扰

     cat /proc/sys/net/ipv4/tcp_max_syn_backlog  DDOS

   backlog满了 accept队列满了，新客户端直接Connection refused

2. TCP四次分手

3. TCP连接状态

4. Connection refused

5. OSI七层参考模型

6. 什么是长连接和短连接？有状态，无状态？

   TCP是长连接吗？

   tcp只是连接，受应用层协议

   连接是不是一个“复用”载体

   举一个例子：http 1.0 ，1.1 没有开启keepalive保持，连接只负责一次同步阻塞的请求+响应，短连接！

   举一个例子：http 1.0,1.1 开启了keepalive保持，同步复用连接：多次(请求+响应)，以上是无状态通信，长连接！

   举一个列子：dubbo协议(rpc)，打开连接，同步/异步复用连接：多次（请求+响应）（请求请求）（响应响应），当复用连接的时候，需要消息的ID，而且客户端和服务端同时完成这个约束  有状态通信，长连接！

7. IO模型

   0：IO是程序对着内核的socket-queue的包装

   BIO：读取，一直等queue里有才返回，阻塞模型，每连接对应一个线程

   NIO：读取，立刻返回：两种结果，读到，没读到，程序逻辑要自己维护，nio noblock

   多路复用器：内核增加select，poll，epoll新增的和数据接收，连接接受实质无关的调用，得到是对应socket的事件(listen socket ，socket)，可以有效地去再次accept，R/W

   

   AIO*

8. 同步阻塞，同步非阻塞

   BIO,NIO,多路复用器，在IO模型上都是同步的，都是程序自己accpet，R/W

9. 粘包，粘包，拆包

   有程序，有内核，程序和内核协调工作

   有一些是内核做的事情，三次握手，数据发送出去，接受进来，内核，TCP，分包

   到我们自己的程序，即便在一个socket里，也可能收到多个消息在一个字节数组中，我们要自己拆解

   

