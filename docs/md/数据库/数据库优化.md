# 数据库优化

## 优化

### SQL优化

- 查询优化 

- - 主键查询，千万条记录，1 - 10 ms
  - 唯一索引，千万条记录，10 - 100 ms
  - 非唯一索引，千万条记录，100 - 1000 ms
  - 无索引，百万条记录，1000 ms+

- 批量写 

- - for each {insert into table values (1)}
  - Execute once insert into table values (1), (2), (3)

- 索引优化
- `innodb`相关优化

### 索引优化

- 经常被查询的区分度高的列做索引
- 最左原则
- 回盘排序
- 覆盖索引
- 小表驱动大表

### 读写分离

- 一主多从
- 读库延迟问题处理
- 主从切换处理

### 分库分表

- 垂直拆分
- 水平拆分
- 多主多从

## 慢查询相关

### 如何定位并优化慢查询SQL

- 根据慢查询日志定位慢查询sql 

- - 在数据库工具中查找慢日志是否打开 

```sql
show variables like '%quer%';

// long_query_time 查询时间，超过则记录慢日志
// show_query_log 开启慢日志
// show_query_log_file 日志地址

show status like '%slow_queries%'; // 慢日志条数

set global show_query_log = on; // 开启
set global long_query_time = 1; // 设置查询时间，再重新连接数据库
```

- 使用`explain`等工具分析sql

```sql
explain select t1.* from t1;
```

- explain查询的字段

- - type：值为 index、all 就需要优化
  - extra：filesort、temporary 表示无法用到索引，就需要优化

- 修改sql或者尽量让sql走索引

```sql
alter table t1 add index idx_name(col1); // 加索引
```

- 使用`force index`测试最优索引 

## 性能相关

### 短时间提高 MySQL 性能的方法

- 第一种：先处理掉那些占着连接但是不工作的线程。或者再考虑断开事务内空闲太久的连接

```
show processlist; # 查询数据库中正在执行的线程 kill query pid; # 断开当前线程中正在执行的语句，而不断开线程连接 kill connection pid; # connection可以省略，断开该线程的连接，如果线程中有正在执行的语句，那么也会停止这个语句
```

- 第二种：减少连接过程的消耗，解决慢查询性能问题在 MySQL 中，慢查询大体有以下三种可能：索引没有设计好；SQL 语句没写好；MySQL选错了索引（force index）。

### 为什么 MySQL 自增主键 ID 不连续？

- 唯一键冲突
- 事务回滚
- 自增主键的批量申请
- 深层次原因是：MySQL 不判断自增主键是否存在，从而减少加锁的时间范围和粒度，这样能保持更高的性能，确保自增主键不能回退，所以才有自增主键不连续

### 自增主键怎么做到唯一性？

自增值加1来通过自增锁控制并发

### InnoDB 为什么要用自增 ID 作为主键？

- 自增主键的插入模式，符合递增插入，每次都是追加操作，不涉及挪动记录，也不会触发叶子节点的分裂
- 每次插入新的记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页
- 有业务逻辑的字段做主键，不容易保证有序插入，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页的中间某个位置，频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，写数据成本较高

### 如何最快的复制一张表？

为了避免对源表加读锁，更稳妥的方案是先将数据写到外部文本文件，然后再写回目标表

- 方法一：使用 mysqldump 命令将数据导出成一组 INSERT 语句
- 方法二：直接将结果导出成.csv 文件。MySQL 提供语法，用来将查询结果导出到服务端本地目录：`select * from db1.t where a>900 into outfile '/server_tmp/t.csv'`，得到 .csv 导出文件后，可以用 load data 命令将数据导入到目标表 db2.t 中：`load data infile '/server_tmp/t.csv' into table db2.t;`
- 方法三：物理拷贝，在 MySQL 5.6 版本引入了可传输表空间(transportable tablespace) 的方法，可以通过导出导入表空间的方式，实现物理拷贝表的功能。

### grant 和 flush privileges语句

- grant语句会同时修改数据表和内存，判断权限的时候使用的内存数据，因此，规范使用是不需要加上 flush privileges 语句
- flush privileges 语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用

### 要不要使用分区表？

- 分区并不是越细越好。实际上，单表或者单分区的数据一千万行，只要没有特别大的索引，对于现在的硬件能力来说都已经是小表了。
- 分区也不要提前预留太多，在使用之前预先创建即可。比如，如果是按月分区，每年年底时再把下一年度的 12 个新分区创建上即可。对于没有数据的历史分区，要及时的 drop 掉。

### join 用法

- 使用 left join 左边的表不一定是驱动表
- 如果需要 left join 的语义，就不能把被驱动表的字段放在 where 条件里面做等值判断或不等值判断，必须都写在 on 里面

### MySQL 有哪些自增ID？各自场景是什么？

- 表的自增 ID 达到上限之后，再申请值不会变化，进而导致联系插入数据的时候报主键冲突错误。
- row_id 达到上限之后，归 0 再重新递增，如果出现相同的 row_id 后写的数据会覆盖之前的数据。
- Xid 只需要不在同一个 binlog 文件出现重复值即可，理论上会出现重复值，但概率极小可忽略不计。
- InnoDB 的 max_trx_id 递增值每次 MySQL 重启会保存起来。
- Xid 是由 server 层维护的。InnoDB 内部使用 Xid，就是为了能够在 InnoDB 事务和 server 之间做关联。但是，InnoDB 自己的 trx_id，是另外维护的。
- thread_id 是使用中最常见的，而且也是处理得最好的一个自增 id 逻辑了。使用了insert_unique 算法

### Xid 在 MySQL 内部是怎么生成的呢？

MySQL 内部维护了一个全局变量 global_query_id，每次执行语句（包括select语句）的时候将它赋值给 Query_id，然后给这个变量加 1。如果当前语句是这个事务执行的第一条语句，那么 MySQL 还会同时把 Query_id 赋值给这个事务的 Xid。而 global_query_id 是一个纯内存变量，重启之后就清零了。所以在同一个数据库实例中，不同事务的 Xid 也是有可能相同的。但是 MySQL 重启之后会重新生成新的 binlog 文件，这就保证了，同一个 binlog 文件里，Xid 一定是惟一的。

### 什么是幻读？

值在同一个事务中，存在前后两次查询同一个范围的数据，第二次看到了第一次没有查询到的数据。

幻读出现的场景：

- 事务的隔离级别是可重复读，且是当前读。
- 幻读指新插入的行。

幻读带来的问题：

- 对行锁语义的破坏
- 破坏了数据一致性

解决：

- 加间隙锁，锁住行与行之间的间隙，阻塞新插入的操作，带来的问题：降低并发度，可能导致死锁。

## 扩容

### 数据库集群

### 水平扩容

### 垂直扩容

### 主主备份

### 主从备份

#### MySQL 是如何保证主备同步

主备关系的建立：

- 一开始创建主备关系的时候，是由备库指定的，比如基于位点的主备关系，备库说“我要从binlog文件A的位置P”开始同步，主库就从这个指定的位置开始往后发。
- 而主备关系搭建之后，是主库决定要发给数据给备库的，所以主库有新的日志也会发给备库。

#### todo MySQL 主备切换流程：

- 客户端读写都是直接访问A，而节点B是备库，只要将A的更新都同步过来，到本地执行就可以保证数据是相同的。
- 当需要切换的时候就把节点换一下，节点A为备库，节点B为主库

#### 一个事务完整的同步过程：

- 备库B和主库A建立来了长链接，主库A内部专门线程用于维护了这个长链接。
- 在备库B上通过 changemaster 命令设置主库A的IP端口用户名密码以及从哪个位置开始请求binlog包括文件名和日志偏移量
- 在备库B上执行start-slave命令备库会启动两个线程：io_thread 和 sql_thread 分别负责建立连接和读取中转日志进行解析执行
- 备库读取主库传过来的binlog文件备库收到文件写到本地成为中转日志
- 后来由于多线程复制方案的引入，sql_thread演化成了多个线程。

#### 什么是主备延迟

主库和备库在执行同一个事务的时候出现时间差的问题，主要原因有：

- 有些部署条件下，备库所在机器的性能要比主库性能差。
- 备库的压力较大。
- 大事务，一个主库上语句执行10分钟，那么这个事务可能会导致从库延迟10分钟。

#### 为什么要有多线程复制策略？

- 因为单线程复制的能力全面低于多线程复制，对于更新压力较大的主库，备库可能是一直追不上主库的，带来的现象就是备库上 seconds_behind_master 值越来越大。
- 在实际应用中，建议使用可靠性优先策略，减少主备延迟，提升系统可用性，尽量减少大事务操作，把大事务拆分小事务。

#### MySQL 的并行策略有哪些？

- **按表分发策略：**如果两个事务更新不同的表，它们就可以并行。因为数据是存储在表里的，所以按表分发，可以保证两个 worker 不会更新同一行。缺点：如果碰到热点表，比如所有的更新事务都会涉及到某一个表的时候，所有事务都会被分配到同一个 worker 中，就变成单线程复制了。
- **按行分发策略：**如果两个事务没有更新相同的行，它们**在备库上**可以并行。显然，这个模式要求 binlog 格式必须是 row。缺点：相比于按表并行分发策略，按行并行策略在决定线程分发的时候，需要消耗更多的计算资源。

#### MySQL的一主一备和一主多从有什么区别？

在一主一备的双 M 架构里，主备切换只需要把客户端流量切到备库；而在一主多从架构里，主备切换除了要把客户端流量切到备库外，还需要把从库接到新主库上。

#### 主库出问题如何解决?

- 基于位点的主备切换：存在找同步位点这个问题，MySQL 5.6 版本引入了 GTID，彻底解决了这个困难
- GTID：全局事务 ID，是一个事务在提交的时候生成的，是这个事务的唯一标识；它由两部分组成，格式是：GTID = server_uuid:gno
- 每个 MySQL 实例都维护了一个 GTID 集合，用来对应“这个实例执行过的所有事务”
- 在基于 GTID 的主备关系里，系统认为只要建立主备关系，就必须保证主库发给备库的日志是完整的。因此，如果实例 B 需要的日志已经不存在，A 就拒绝把日志发给 B

#### MySQL 读写分离涉及到过期读问题的几种解决方案?

- 强制走主库方案
- sleep 方案
- 判断主备无延迟方案
- 配合 semi-sync 方案
- 等主库位点方案
- GTID 方案
- 实际生产中，先客户端对请求做分类，区分哪些请求可以接受过期读，而哪些请求完全不能接受过期读；然后，对于不能接受过期读的语句，再使用等 GTID 或等位点的方案。

### MySQL的并发链接和并发查询有什么区别？

- 在执行show processlist的结果里，看到了几千个连接，指的是并发连接。而"当前正在执行"的语句，才是并发查询
- 并发连接数多影响的是内存，并发查询太高对CPU不利。一个机器的CPU核数有限，线程全冲进来，上下文切换的成本就会太高
- 所以需要设置参数 innodb_thread_concurrency 用来限制线程数，当线程数达到该参数，InnoDB 就会认为线程数用完了，会阻止其他语句进入引擎执行

## 优化相关

### 数据库表结构的优化

数据库表结构的优化包括选择合适数据类型、表的范式的优化、表的垂直拆分和表的水平拆分等手段

#### 选择合适数据类型

- 使用较小的数据类型解决问题；
- 使用简单的数据类型(mysql处理int要比varchar容易)；
- 尽可能的使用not null 定义字段；
- 尽量避免使用text类型，非用不可时最好考虑分表；

#### 表的范式的优化

一般情况下，表的设计应该遵循三大范式

#### 表的垂直拆分

把含有多个列的表拆分成多个表，解决表宽度问题，具体包括以下几种拆分手段：

- 把不常用的字段单独放在同一个表中；
- 把大字段独立放入一个表中；
- 把经常使用的字段放在一起；
- 这样做的好处是非常明显的，具体包括：拆分后业务清晰，拆分规则明确、系统之间整合或扩展容易、数据维护简单；

#### 表的水平拆分

表的水平拆分用于解决数据表中数据过大的问题，水平拆分每一个表的结构都是完全一致的。一般地，将数据平分到N张表中的常用方法包括以下两种：

- 对ID进行hash运算，如果要拆分成5个表，mod(id,5)取出0~4个值；
- 针对不同的hashID将数据存入不同的表中；
- 表的水平拆分会带来一些问题和挑战，包括跨分区表的数据查询、统计及后台报表的操作等问题，但也带来了一些切实的好处： 

- - 表分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询速度；
  - 表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。

- 需要把数据存放到多个数据库中，提高系统的总体可用性(分库，鸡蛋不能放在同一个篮子里)

### 系统配置的优化

操作系统配置的优化：增加TCP支持的队列数

mysql配置文件优化：Innodb缓存池设置(innodb_buffer_pool_size，推荐总内存的75%)和缓存池的个数（innodb_buffer_pool_instances）

### 硬件的优化

CPU：核心数多并且主频高的
内存：增大内存
磁盘配置和选择：磁盘性能