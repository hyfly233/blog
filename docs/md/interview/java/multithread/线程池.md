## 基础

### 简述线程池

没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后复用已创建的线程，可以降低开销、控制最大并发数。
线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。
将任务派发给线程池时，会出现以下几种情况

-   核心线程池未满，创建一个新的线程执行任务。
-   如果核心线程池已满，工作队列未满，将线程存储在工作队列。
-   如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。
-   如果超过大小线程数，按照拒绝策略来处理任务。

线程池参数：

-   corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。
-   maximumPoolSize：线程池能够容纳同时执行的线程最大数。
-   keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。
-   workQueue：工作队列。
-   threadFactory：线程工厂，用来生产一组相同任务的线程。
-   handler：拒绝策略。

拒绝策略有以下几种：

-   AbortPolicy：丢弃任务并抛出异常
-   CallerRunsPolicy：重新尝试提交该任务
-   DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列
-   DiscardPolicy 表示直接抛弃当前任务但不抛出异常。

### 简述 Executor 框架

Executor 框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用 Executor 框架实现类的 Execute 方法就可以提交任务。

### 简述 Executor 的继承关系

-   Executor：一个接口，其定义了一个接收 Runnable 对象的方法 executor，该方法接收一个 Runable 实例执行这个任务。
-   ExecutorService：Executor 的子类接口，其定义了一个接收 Callable 对象的方法，返回 Future 对象，同时提供 execute 方法。
-   ScheduledExecutorService：ExecutorService 的子类接口，支持定期执行任务。
-   AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。
-   Executors：实现 ExecutorService 接口的静态工厂类，提供了一系列工厂方法用于创建线程池。
-   ThreadPoolExecutor：继承 AbstractExecutorService，用于创建线程池。
-   ForkJoinPool: 继承 AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于 map reduce。
-   ThreadPoolExecutor：继承 ThreadPoolExecutor，实现 ScheduledExecutorService，用于创建带定时任务的线程池。

### 简述线程池的状态

-   Running：能接受新提交的任务，也可以处理阻塞队列的任务。
-   Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于 running 时调用 shutdown 方法，会进入该状态。
-   Stop：不接受新任务，不处理存量任务，调用 shutdownnow 进入该状态。
-   Tidying：所有任务已经终止了，worker_count（有效线程数）为 0。
-   Terminated：线程池彻底终止。在 tidying 模式下调用 terminated 方法会进入该状态。

### 简述线程池类型

-   newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲 1 分钟后自动销毁。
-   newFixedThreadPool 指定工作线程数量线程池。
-   newSingleThreadExecutor 单线程 Executor。
-   newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。
-   newSingleThreadScheduledExecutor 支持定时任务的单线程 Executor。

### 简述阻塞队列

阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：

-   ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。
-   LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。
-   PriorityBlockingQueue：阻塞优先队列。
-   DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素
-   SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作
-   LinkedTransferQueue：与 LinkedBlockingQueue 相比多一个 transfer 方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。
-   LinkedBlockingDeque：双向阻塞队列。

### 什么是线程池

在面向对象编程中，创建和销毁对象是很费时间的，创建一个对象要获取内存资源或者其它更多资源。Java 虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是“池化资源”技术产生的原因
线程池，就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销
Java 5+ 中的 Executor 接口定义一个执行线程的工具，它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池：

-   newSingleThreadExecutor
    创建一个单线程的线程池，这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行
-   newFixedThreadPool
    创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
-   newCachedThreadPool
    创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小
-   newScheduledThreadPool
    创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求

### 为什么要使用线程池

避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。

### 线程池队列已满会发生什么

-   使用的 LinkedBlockingQueue，也就是无界队列的话，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务
-   使用的是有界队列，如 ArrayBlockingQueue，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue 满了，则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy

### 线程池有哪些参数？

-   corePoolSize：核心线程数，线程池中始终存活的线程数
-   maximumPoolSize：最大线程数，线程池中允许的最大线程数
-   keepAliveTime：存活时间，线程没有任务执行时最多保持多久时间会终止
-   unit：单位，参数 keepAliveTime 的时间单位，7 种可选
-   workQueue：一个阻塞队列，用来存储等待执行的任务，均为线程安全，7 种可选
-   threadFactory：线程工厂，主要用来创建线程，默及正常优先级、非守护线程
-   handler：拒绝策略，拒绝处理任务时的策略，4 种可选，默认为 AbortPolicy
    -   AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
    -   CallerRunsPolicy：只用调用者所在的线程来处理任务
    -   DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
    -   DiscardPolicy：直接丢弃任务，也不抛出异常

### 线程池的执行流程

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687053962-02fe8165-06c9-41c1-8d4b-63f03628fa58.png#averageHue=%23faf8f6&clientId=u00400ee8-e274-4&from=paste&id=uf6eb3d33&originHeight=1054&originWidth=1154&originalType=url&ratio=1&rotation=0&showTitle=false&size=209121&status=done&style=none&taskId=u30ef56a3-c059-4c9f-9167-6432e1b4614&title=)

-   判断线程池中的线程数是否大于设置的核心线程数
    -   如果小于，就创建一个核心线程来执行任务
    -   如果大于，就会判断缓冲队列是否满了
        -   如果没有满，则放入队列，等待线程空闲时执行任务
        -   如果队列已经满了，则判断是否达到了线程池设置的最大线程数
            -   如果没有达到，就创建新线程来执行任务
            -   如果已经达到了最大线程数，则执行指定的拒绝策略

### 线程池的拒绝策略有哪些

-   AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
-   CallerRunsPolicy：只用调用者所在的线程来处理任务
-   DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
-   DiscardPolicy：直接丢弃任务，也不抛出异常

### 讲讲线程池的实现原理

使用线程池的好处

-   线程是稀缺资源，不能频繁的创建。
-   应当将其放入一个池子中，可以给其他任务进行复用。
-   解耦作用，线程的创建于执行完全分开，方便维护。

创建一个线程池

```java
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler);
```

为例：

-   corePoolSize 为线程池的基本大小。
-   maximumPoolSize 为线程池最大线程大小。
-   keepAliveTime 和 unit 则是线程空闲后的存活时间。
-   workQueue 用于存放任务的阻塞队列。
-   handler 当队列和最大线程池都满了之后的饱和策略。

处理流程
当提交一个任务到线程池时它的执行流程是怎样的呢？
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687053872-c8d4bbec-3a1b-41bb-a7dc-96fabc906a8a.png#averageHue=%23fbfdfa&clientId=u00400ee8-e274-4&from=paste&id=u47de066c&originHeight=293&originWidth=500&originalType=url&ratio=1&rotation=0&showTitle=false&size=84049&status=done&style=none&taskId=ubd82d4b7-1812-4389-83c8-651f4b36fa8&title=)
首先第一步会判断核心线程数有没有达到上限，如果没有则创建线程(会获取全局锁)，满了则会将任务丢进阻塞队列。
如果队列也满了则需要判断最大线程数是否达到上限，如果没有则创建线程(获取全局锁)，如果最大线程数也满了则会根据饱和策略处理。
常用的饱和策略有:

-   直接丢弃任务。
-   调用者线程处理。
-   丢弃队列中的最近任务，执行当前任务。

所以当线程池完成预热之后都是将任务放入队列，接着由工作线程一个个从队列里取出执行。
合理配置线程池
线程池并不是配置越大越好，而是要根据任务的熟悉来进行划分： 如果是 CPU 密集型任务应当分配较少的线程，比如 CPU 个数相当的大小。
如果是 IO 密集型任务，由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 \* 2 。
当是一个混合型任务，可以将其拆分为 CPU 密集型任务以及 IO 密集型任务，这样来分别配置。

# Java 线程池技术详解

## 目录

1. [线程池基础概念](#线程池基础概念)
2. [Executor 框架体系](#executor框架体系)
3. [ThreadPoolExecutor 详解](#threadpoolexecutor详解)
4. [阻塞队列](#阻塞队列)
5. [线程池类型](#线程池类型)
6. [线程池状态管理](#线程池状态管理)
7. [参数配置与调优](#参数配置与调优)
8. [监控与最佳实践](#监控与最佳实践)
9. [面试常见问题](#面试常见问题)

## 线程池基础概念

### 什么是线程池

**线程池（Thread Pool）** 是一种**池化资源**技术，预先创建一定数量的线程放入池中，需要时从池中获取，使用完毕后归还到池中，从而避免频繁创建和销毁线程的开销。

### 为什么使用线程池

#### 问题背景

在面向对象编程中，创建和销毁对象是很费时间的：

-   创建对象需要获取内存资源
-   JVM 需要跟踪每个对象便于垃圾回收
-   线程创建涉及系统调用，开销更大

#### 线程池的优势

1. **降低资源消耗**：复用已创建的线程，降低线程创建和销毁造成的消耗
2. **提高响应速度**：任务到达时，无需等待线程创建即可立即执行
3. **提高线程的可管理性**：统一分配、调优和监控线程资源
4. **控制并发数量**：避免无限制创建线程导致系统资源耗尽

### 线程池核心工作原理

#### 基本组成

-   **核心线程（Core Threads）**：始终存活的线程
-   **工作队列（Work Queue）**：存储等待执行的任务
-   **最大线程（Maximum Threads）**：线程池允许的最大线程数
-   **拒绝策略（Reject Policy）**：队列和线程池都满时的处理策略

#### 任务执行流程

```
提交任务 → 核心线程池是否满？
            ↓ 否：创建核心线程执行任务
            ↓ 是
         工作队列是否满？
            ↓ 否：任务入队等待
            ↓ 是
         最大线程数是否满？
            ↓ 否：创建非核心线程执行任务
            ↓ 是
         执行拒绝策略
```

#### Worker 工作线程

```java
// 简化的Worker实现概念
class Worker implements Runnable {
    private Thread thread;
    private Runnable firstTask;

    public void run() {
        runWorker(this);
    }

    final void runWorker(Worker w) {
        Runnable task = w.firstTask;
        while (task != null || (task = getTask()) != null) {
            task.run(); // 执行任务
            task = null;
        }
    }
}
```

线程池将线程封装成 Worker，Worker 执行完任务后会循环从工作队列中获取新任务执行。

## Executor 框架体系

### 框架设计目标

Executor 框架的核心思想是**将任务提交与任务执行分离**，用户无需关心线程的创建、调度等细节，只需提交任务即可。

### 继承关系图

```
    Executor (interface)
        ↓
ExecutorService (interface)
        ↓                    ↓
ScheduledExecutorService  AbstractExecutorService (abstract class)
        ↓                    ↓
ScheduledThreadPoolExecutor  ThreadPoolExecutor
                           ForkJoinPool
```

### 核心接口与类详解

#### 1. Executor 接口

```java
public interface Executor {
    void execute(Runnable command);
}
```

-   **作用**：定义了执行任务的基本方法
-   **特点**：只能执行 Runnable 任务，无返回值

#### 2. ExecutorService 接口

```java
public interface ExecutorService extends Executor {
    // 提交Callable任务，返回Future
    <T> Future<T> submit(Callable<T> task);
    <T> Future<T> submit(Runnable task, T result);
    Future<?> submit(Runnable task);

    // 批量执行任务
    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks);
    <T> T invokeAny(Collection<? extends Callable<T>> tasks);

    // 关闭线程池
    void shutdown();
    List<Runnable> shutdownNow();
    boolean isShutdown();
    boolean isTerminated();
    boolean awaitTermination(long timeout, TimeUnit unit);
}
```

#### 3. ScheduledExecutorService 接口

```java
public interface ScheduledExecutorService extends ExecutorService {
    // 延迟执行
    ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit);
    <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit);

    // 周期性执行
    ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay,
                                          long period, TimeUnit unit);
    ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay,
                                             long delay, TimeUnit unit);
}
```

#### 4. AbstractExecutorService 抽象类

-   **作用**：提供 ExecutorService 执行方法的默认实现
-   **实现**：submit、invokeAll、invokeAny 等方法的通用逻辑

#### 5. 具体实现类

**ThreadPoolExecutor**

-   通用线程池实现
-   支持核心线程、最大线程、工作队列、拒绝策略等配置

**ScheduledThreadPoolExecutor**

-   继承 ThreadPoolExecutor
-   实现 ScheduledExecutorService 接口
-   支持延迟和周期性任务执行

**ForkJoinPool**

-   基于工作窃取算法
-   适用于 CPU 密集型的递归任务
-   Fork：将大任务分解为小任务
-   Join：合并小任务的结果

### Executors 工厂类

#### 常用工厂方法

```java
public class ExecutorsExample {
    public static void main(String[] args) {
        // 固定大小线程池
        ExecutorService fixedPool = Executors.newFixedThreadPool(5);

        // 缓存线程池
        ExecutorService cachedPool = Executors.newCachedThreadPool();

        // 单线程池
        ExecutorService singlePool = Executors.newSingleThreadExecutor();

        // 定时任务线程池
        ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(3);

        // 单线程定时任务池
        ScheduledExecutorService singleScheduled = Executors.newSingleThreadScheduledExecutor();

        // 工作窃取线程池
        ExecutorService workStealingPool = Executors.newWorkStealingPool();
    }
}
```

**注意**：生产环境中不推荐使用 Executors 工厂方法，建议直接使用 ThreadPoolExecutor 构造器，以便更好地控制参数。

## ThreadPoolExecutor 详解

### 构造函数参数

```java
public ThreadPoolExecutor(
    int corePoolSize,                   // 核心线程数
    int maximumPoolSize,                // 最大线程数
    long keepAliveTime,                 // 线程空闲存活时间
    TimeUnit unit,                      // 时间单位
    BlockingQueue<Runnable> workQueue,  // 工作队列
    ThreadFactory threadFactory,        // 线程工厂
    RejectedExecutionHandler handler    // 拒绝策略
)
```

### 核心参数详解

#### 1. corePoolSize（核心线程数）

-   **定义**：线程池中始终存活的线程数量
-   **特点**：
    -   即使空闲也不会被销毁（除非设置 allowCoreThreadTimeOut 为 true）
    -   线程池启动后会逐渐创建核心线程
    -   可以通过 prestartAllCoreThreads()方法预启动所有核心线程

#### 2. maximumPoolSize（最大线程数）

-   **定义**：线程池中允许存在的最大线程数
-   **作用**：当工作队列满时，可以创建额外的线程直到达到此数量
-   **注意**：使用无界队列时此参数无效

#### 3. keepAliveTime & unit（线程存活时间）

-   **作用**：非核心线程空闲超过此时间会被销毁
-   **单位**：TimeUnit 枚举值（NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS、MINUTES、HOURS、DAYS）
-   **优化**：合理设置可以在负载降低时回收资源

#### 4. workQueue（工作队列）

用于存储等待执行的任务，后续详细介绍。

#### 5. threadFactory（线程工厂）

```java
// 自定义线程工厂示例
public class CustomThreadFactory implements ThreadFactory {
    private final AtomicInteger threadNumber = new AtomicInteger(1);
    private final String namePrefix;

    public CustomThreadFactory(String namePrefix) {
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r, namePrefix + "-thread-" + threadNumber.getAndIncrement());
        t.setDaemon(false);                    // 设置为非守护线程
        t.setPriority(Thread.NORM_PRIORITY);   // 设置优先级
        return t;
    }
}
```

#### 6. handler（拒绝策略）

当线程池和队列都满时的处理策略，详见下文。

### 任务执行流程详解

#### 完整执行流程

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();

    int c = ctl.get();

    // 1. 如果当前线程数 < 核心线程数，创建新的核心线程
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }

    // 2. 如果线程池运行中且任务成功入队
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        // 双重检查：如果线程池不在运行状态，移除任务并拒绝
        if (!isRunning(recheck) && remove(command))
            reject(command);
        // 如果没有工作线程，创建一个非核心线程
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 3. 队列满了，尝试创建新的非核心线程
    else if (!addWorker(command, false))
        reject(command); // 创建失败，执行拒绝策略
}
```

#### 流程图表示

```
提交任务
    ↓
线程数 < corePoolSize？
    ↓ 是：创建核心线程执行任务
    ↓ 否
任务能否入队？
    ↓ 是：任务入队等待
    ↓ 否
线程数 < maximumPoolSize？
    ↓ 是：创建非核心线程执行任务
    ↓ 否
执行拒绝策略
```

### 拒绝策略详解

#### 1. AbortPolicy（默认策略）

```java
public static class AbortPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException("Task " + r.toString() +
                                           " rejected from " + e.toString());
    }
}
```

-   **行为**：直接抛出 RejectedExecutionException 异常
-   **适用**：希望快速失败，调用者能感知到任务被拒绝

#### 2. CallerRunsPolicy

```java
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run(); // 在调用者线程中执行任务
        }
    }
}
```

-   **行为**：在调用者线程中执行被拒绝的任务
-   **适用**：任务不能丢失，可以接受性能降低

#### 3. DiscardOldestPolicy

```java
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll(); // 丢弃队列中最旧的任务
            e.execute(r);        // 重新提交当前任务
        }
    }
}
```

-   **行为**：丢弃队列中最旧的任务，然后重新提交当前任务
-   **适用**：任务有时效性，新任务比旧任务更重要

#### 4. DiscardPolicy

```java
public static class DiscardPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // 静默丢弃任务，不做任何处理
    }
}
```

-   **行为**：静默丢弃任务，不抛异常
-   **适用**：任务丢失可以接受的场景

#### 5. 自定义拒绝策略

```java
public class CustomRejectedExecutionHandler implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 记录日志
        logger.warn("Task {} rejected from {}", r.toString(), executor.toString());

        // 尝试放入备用队列
        if (!backupQueue.offer(r)) {
            // 备用队列也满了，进行其他处理
            handleFinalReject(r);
        }
    }
}
```

## 阻塞队列

### 队列在线程池中的作用

阻塞队列是**生产者-消费者模式**的核心组件，在线程池中：

-   **生产者**：提交任务的线程
-   **消费者**：工作线程（Worker）
-   **缓冲区**：阻塞队列

### 阻塞队列特性

-   **阻塞插入**：队列满时，插入操作会阻塞直到有空间
-   **阻塞移除**：队列空时，移除操作会阻塞直到有元素
-   **线程安全**：所有操作都是线程安全的

### 常用阻塞队列详解

#### 1. ArrayBlockingQueue

```java
// 创建容量为100的有界数组队列
BlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(100);
```

-   **底层实现**：数组
-   **容量**：有界，创建时指定容量
-   **排序**：FIFO（先进先出）
-   **锁机制**：单锁（读写操作共用一把锁）
-   **适用场景**：内存有限，需要控制队列大小

#### 2. LinkedBlockingQueue

```java
// 无界队列（容量为Integer.MAX_VALUE）
BlockingQueue<Runnable> queue1 = new LinkedBlockingQueue<>();
// 有界队列
BlockingQueue<Runnable> queue2 = new LinkedBlockingQueue<>(100);
```

-   **底层实现**：链表
-   **容量**：可选有界，默认无界（Integer.MAX_VALUE）
-   **排序**：FIFO
-   **锁机制**：双锁（读写分离）
-   **性能特点**：高并发场景下性能优于 ArrayBlockingQueue
-   **注意**：无界队列可能导致内存溢出

#### 3. SynchronousQueue

```java
BlockingQueue<Runnable> queue = new SynchronousQueue<>();
```

-   **容量**：0，不存储元素
-   **同步机制**：每个插入操作必须等待对应的移除操作
-   **特点**：直接传递，没有缓冲
-   **适用场景**：任务处理速度快，不需要缓冲

#### 4. PriorityBlockingQueue

```java
// 使用自然排序
BlockingQueue<Task> queue1 = new PriorityBlockingQueue<>();
// 使用自定义比较器
BlockingQueue<Task> queue2 = new PriorityBlockingQueue<>(100,
    (t1, t2) -> Integer.compare(t1.getPriority(), t2.getPriority()));
```

-   **底层实现**：堆（优先队列）
-   **容量**：无界，可扩容
-   **排序**：按优先级排序
-   **适用场景**：任务有优先级要求

#### 5. DelayQueue

```java
public class DelayedTask implements Delayed {
    private final long executeTime;
    private final Runnable task;

    @Override
    public long getDelay(TimeUnit unit) {
        return unit.convert(executeTime - System.currentTimeMillis(),
                           TimeUnit.MILLISECONDS);
    }

    @Override
    public int compareTo(Delayed o) {
        return Long.compare(this.executeTime, ((DelayedTask) o).executeTime);
    }
}

BlockingQueue<DelayedTask> queue = new DelayQueue<>();
```

-   **特点**：元素只有在延迟期满后才能被取出
-   **适用场景**：定时任务、缓存过期

#### 6. LinkedTransferQueue

```java
BlockingQueue<Runnable> queue = new LinkedTransferQueue<>();
```

-   **特点**：如果有消费者在等待，生产者可以直接传递元素
-   **方法**：提供 transfer()方法实现直接传递
-   **性能**：在某些场景下性能更好

#### 7. LinkedBlockingDeque

```java
BlockingDeque<Runnable> deque = new LinkedBlockingDeque<>();
```

-   **特点**：双端阻塞队列，支持两端插入和移除
-   **适用场景**：工作窃取算法

### 队列选择指南

| 队列类型              | 容量     | 数据结构 | 排序     | 适用场景           |
| --------------------- | -------- | -------- | -------- | ------------------ |
| ArrayBlockingQueue    | 有界     | 数组     | FIFO     | 内存有限，需要背压 |
| LinkedBlockingQueue   | 可选有界 | 链表     | FIFO     | 高并发，大部分场景 |
| SynchronousQueue      | 0        | 无       | 无       | 快速处理，直接传递 |
| PriorityBlockingQueue | 无界     | 堆       | 优先级   | 任务有优先级       |
| DelayQueue            | 无界     | 堆       | 延迟时间 | 定时任务           |

### 队列与线程池的关系

#### 队列满时的处理策略

````java
## 线程池类型详解

### Executor框架提供的线程池

#### 1. newFixedThreadPool - 固定大小线程池
```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>());
}

// 使用示例
ExecutorService executor = Executors.newFixedThreadPool(5);
for (int i = 0; i < 10; i++) {
    final int taskId = i;
    executor.submit(() -> {
        System.out.println("Task " + taskId + " executed by " +
                          Thread.currentThread().getName());
        // 模拟任务执行
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    });
}
````

**特点分析：**

-   **核心线程数 = 最大线程数**：线程数量固定
-   **队列**：无界 LinkedBlockingQueue
-   **优点**：线程数量可控，适合负载较重的服务器
-   **缺点**：队列无界，可能导致内存溢出
-   **适用场景**：执行长期任务，性能要求不高

#### 2. newCachedThreadPool - 可缓存线程池

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue<Runnable>());
}

// 使用示例
ExecutorService executor = Executors.newCachedThreadPool();
for (int i = 0; i < 100; i++) {
    final int taskId = i;
    executor.submit(() -> {
        System.out.println("Task " + taskId + " - " +
                          Thread.currentThread().getName());
    });
}
```

**特点分析：**

-   **核心线程数**：0
-   **最大线程数**：Integer.MAX_VALUE（无限制）
-   **队列**：SynchronousQueue（不存储元素）
-   **空闲时间**：60 秒
-   **优点**：灵活性高，适合执行大量短期异步任务
-   **缺点**：线程数量不可控，可能创建大量线程导致资源耗尽
-   **适用场景**：执行很多短期异步任务的小程序

#### 3. newSingleThreadExecutor - 单线程线程池

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>()));
}

// 使用示例
ExecutorService executor = Executors.newSingleThreadExecutor();
for (int i = 0; i < 5; i++) {
    final int taskId = i;
    executor.submit(() -> {
        System.out.println("Task " + taskId + " executed sequentially");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    });
}
```

**特点分析：**

-   **线程数量**：始终只有一个工作线程
-   **队列**：无界 LinkedBlockingQueue
-   **执行顺序**：按任务提交顺序依次执行
-   **线程安全**：无需考虑同步问题
-   **适用场景**：需要保证任务执行顺序的场景

#### 4. newScheduledThreadPool - 定时任务线程池

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}

// 使用示例
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(3);

// 延迟执行
scheduler.schedule(() -> {
    System.out.println("延迟5秒执行");
}, 5, TimeUnit.SECONDS);

// 固定频率执行
scheduler.scheduleAtFixedRate(() -> {
    System.out.println("每3秒执行一次");
}, 0, 3, TimeUnit.SECONDS);

// 固定延迟执行
scheduler.scheduleWithFixedDelay(() -> {
    System.out.println("上次执行完成后等待2秒再执行");
}, 0, 2, TimeUnit.SECONDS);
```

**特点分析：**

-   **继承关系**：ScheduledThreadPoolExecutor extends ThreadPoolExecutor
-   **核心功能**：支持延迟执行和周期性执行
-   **队列**：DelayedWorkQueue（优先队列）
-   **适用场景**：需要定时执行任务

#### 5. newSingleThreadScheduledExecutor - 单线程定时任务线程池

```java
public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
    return new DelegatedScheduledExecutorService
        (new ScheduledThreadPoolExecutor(1));
}
```

**特点分析：**

-   **线程数量**：单线程
-   **功能**：支持定时和周期性任务执行
-   **适用场景**：单线程环境下的定时任务

## 线程池状态管理

### 线程池生命周期状态

ThreadPoolExecutor 使用一个**AtomicInteger**变量`ctl`来同时存储**线程池状态**和**工作线程数量**：

```java
// ctl的高3位存储线程池状态，低29位存储工作线程数量
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));

// COUNT_BITS = 29, 用于分离状态和数量
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

// 线程池状态存储在高3位
private static final int RUNNING    = -1 << COUNT_BITS;  // 111...
private static final int SHUTDOWN   =  0 << COUNT_BITS;  // 000...
private static final int STOP       =  1 << COUNT_BITS;  // 001...
private static final int TIDYING    =  2 << COUNT_BITS;  // 010...
private static final int TERMINATED =  3 << COUNT_BITS;  // 011...
```

### 五种状态详解

#### 1. RUNNING（运行状态）

```java
// 状态值：-1（高3位：111）
private static final int RUNNING = -1 << COUNT_BITS;
```

-   **特点**：能够接受新任务，也能处理阻塞队列中的任务
-   **创建时状态**：线程池创建后的初始状态
-   **状态转换**：只能转换到 SHUTDOWN 或 STOP

#### 2. SHUTDOWN（关闭状态）

```java
// 状态值：0（高3位：000）
private static final int SHUTDOWN = 0 << COUNT_BITS;

// 触发方式
executor.shutdown();
```

-   **特点**：不接受新任务，但会处理阻塞队列中的剩余任务
-   **线程行为**：空闲线程会被中断，正在执行的任务继续执行
-   **状态转换**：可以转换到 TIDYING

#### 3. STOP（停止状态）

```java
// 状态值：1（高3位：001）
private static final int STOP = 1 << COUNT_BITS;

// 触发方式
executor.shutdownNow();
```

-   **特点**：不接受新任务，不处理队列中的任务，中断正在执行的任务
-   **返回值**：shutdownNow()返回队列中未执行的任务列表
-   **状态转换**：可以转换到 TIDYING

#### 4. TIDYING（整理状态）

```java
// 状态值：2（高3位：010）
private static final int TIDYING = 2 << COUNT_BITS;
```

-   **特点**：所有任务都已终止，工作线程数为 0
-   **触发时机**：SHUTDOWN 状态下队列为空且工作线程数为 0，或 STOP 状态下工作线程数为 0
-   **状态转换**：自动转换到 TERMINATED

#### 5. TERMINATED（终止状态）

```java
// 状态值：3（高3位：011）
private static final int TERMINATED = 3 << COUNT_BITS;
```

-   **特点**：线程池完全终止
-   **触发时机**：terminated()钩子方法执行完成后
-   **最终状态**：不会再转换到其他状态

### 状态转换图

```
    +----------+
    | RUNNING  |
    +----------+
         |
         | shutdown()
         v
    +----------+     队列为空且     +----------+     terminated() +-------------+
    | SHUTDOWN |  工作线程数为0    | TIDYING  | ----------------> | TERMINATED  |
    +----------+ ----------------> +----------+     完成后        +-------------+
         |                             ^
         | shutdownNow()               |
         v                             | 工作线程数为0
    +----------+ -----------------------+
    |   STOP   |
    +----------+
```

### 状态检查方法

```java
public class ThreadPoolStateChecker {

    // 检查是否在运行状态
    private static boolean isRunning(int c) {
        return c < SHUTDOWN;
    }

    // 检查状态是否至少是指定状态
    private static boolean runStateAtLeast(int c, int s) {
        return c >= s;
    }

    // 检查状态是否小于指定状态
    private static boolean runStateLessThan(int c, int s) {
        return c < s;
    }

    // 获取线程池状态
    private static int runStateOf(int c) {
        return c & ~CAPACITY;
    }

    // 获取工作线程数
    private static int workerCountOf(int c) {
        return c & CAPACITY;
    }

    // 组合状态和线程数
    private static int ctlOf(int rs, int wc) {
        return rs | wc;
    }
}
```

### 状态转换代码示例

```java
public class ThreadPoolStateDemo {
    public static void main(String[] args) throws InterruptedException {
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            2, 4, 60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(10),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );

        // RUNNING状态
        System.out.println("初始状态: " + getState(executor));

        // 提交任务
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    System.out.println("Task " + taskId + " executing");
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    System.out.println("Task " + taskId + " interrupted");
                    Thread.currentThread().interrupt();
                }
            });
        }

        Thread.sleep(1000);
        System.out.println("提交任务后: " + getState(executor));

        // 转换到SHUTDOWN状态
        executor.shutdown();
        System.out.println("shutdown后: " + getState(executor));

        // 等待所有任务完成
        if (executor.awaitTermination(10, TimeUnit.SECONDS)) {
            System.out.println("所有任务完成: " + getState(executor));
        }
    }

    private static String getState(ThreadPoolExecutor executor) {
        if (executor.isRunning()) return "RUNNING";
        if (executor.isShutdown() && !executor.isTerminating() && !executor.isTerminated()) {
            return "SHUTDOWN";
        }
        if (executor.isTerminating()) return "TIDYING";
        if (executor.isTerminated()) return "TERMINATED";
        return "UNKNOWN";
    }
}
```

### 优雅关闭线程池

```java
public class GracefulShutdown {

    public static void shutdownGracefully(ExecutorService executor) {
        executor.shutdown(); // 不再接受新任务

        try {
            // 等待已提交任务完成
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                // 超时后强制关闭
                List<Runnable> unfinishedTasks = executor.shutdownNow();
                System.out.println("强制关闭，未完成任务数: " + unfinishedTasks.size());

                // 再次等待
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    System.err.println("线程池未能正常关闭");
                }
            }
        } catch (InterruptedException ie) {
            // 当前线程被中断，强制关闭线程池
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}
```

## 线程池参数调优

### 核心参数配置原则

#### 1. 核心线程数（corePoolSize）确定

```java
// CPU密集型任务
int cpuCores = Runtime.getRuntime().availableProcessors();
int corePoolSize = cpuCores + 1;

// IO密集型任务（经验公式）
int corePoolSize = cpuCores * 2;

// 混合型任务（更精确的计算）
// corePoolSize = cpuCores * (1 + waitTime/cpuTime)
// waitTime: 线程等待时间，cpuTime: 线程CPU执行时间
```

#### 2. 最大线程数（maximumPoolSize）设置

```java
// 保守设置：避免创建过多线程
int maximumPoolSize = corePoolSize * 2;

// 根据系统资源动态调整
public static int calculateMaxPoolSize() {
    long maxMemory = Runtime.getRuntime().maxMemory(); // 最大内存
    long threadStackSize = 1024 * 1024; // 假设每个线程栈大小1MB
    int maxThreadsByMemory = (int) (maxMemory / threadStackSize / 4); // 预留内存

    int cpuCores = Runtime.getRuntime().availableProcessors();
    int maxThreadsByCpu = cpuCores * 4; // CPU核心数的4倍

    return Math.min(maxThreadsByMemory, maxThreadsByCpu);
}
```

#### 3. 队列容量（queueCapacity）选择

```java
// 基于响应时间要求
// 如果要求快速响应，队列容量应该较小
int queueCapacity = corePoolSize * 2;

// 基于内存使用
// 估算每个任务占用内存，计算队列容量
public static int calculateQueueCapacity(int taskMemorySize, long availableMemory) {
    return (int) (availableMemory * 0.1 / taskMemorySize); // 预留90%内存给其他用途
}
```

### 性能调优策略

#### 1. 基于系统指标的动态调优

```java
public class DynamicThreadPoolTuner {
    private final ThreadPoolExecutor executor;
    private final ScheduledExecutorService monitor;

    public DynamicThreadPoolTuner(ThreadPoolExecutor executor) {
        this.executor = executor;
        this.monitor = Executors.newScheduledThreadPool(1);
        startMonitoring();
    }

    private void startMonitoring() {
        monitor.scheduleAtFixedRate(this::adjustThreadPool, 0, 30, TimeUnit.SECONDS);
    }

    private void adjustThreadPool() {
        ThreadPoolMetrics metrics = collectMetrics();

        // 根据队列使用率调整
        if (metrics.getQueueUtilization() > 0.8) {
            // 队列使用率过高，增加核心线程数
            int newCoreSize = Math.min(executor.getCorePoolSize() + 1,
                                     executor.getMaximumPoolSize());
            executor.setCorePoolSize(newCoreSize);
            System.out.println("增加核心线程数到: " + newCoreSize);
        } else if (metrics.getQueueUtilization() < 0.2 &&
                   executor.getCorePoolSize() > 1) {
            // 队列使用率过低，减少核心线程数
            executor.setCorePoolSize(executor.getCorePoolSize() - 1);
            System.out.println("减少核心线程数到: " + executor.getCorePoolSize());
        }

        // 根据线程利用率调整
        if (metrics.getThreadUtilization() > 0.9) {
            // 线程利用率过高，增加最大线程数
            int newMaxSize = Math.min(executor.getMaximumPoolSize() + 2,
                                    calculateMaxPoolSize());
            executor.setMaximumPoolSize(newMaxSize);
        }
    }

    private ThreadPoolMetrics collectMetrics() {
        BlockingQueue<Runnable> queue = executor.getQueue();
        double queueUtilization = (double) queue.size() /
                                 (queue.size() + queue.remainingCapacity());

        double threadUtilization = (double) executor.getActiveCount() /
                                  executor.getPoolSize();

        return new ThreadPoolMetrics(queueUtilization, threadUtilization);
    }

    private static class ThreadPoolMetrics {
        private final double queueUtilization;
        private final double threadUtilization;

        public ThreadPoolMetrics(double queueUtilization, double threadUtilization) {
            this.queueUtilization = queueUtilization;
            this.threadUtilization = threadUtilization;
        }

        public double getQueueUtilization() { return queueUtilization; }
        public double getThreadUtilization() { return threadUtilization; }
    }
}
```

#### 2. 压力测试与参数验证

```java
public class ThreadPoolLoadTest {

    public static void performLoadTest(ThreadPoolExecutor executor,
                                     int taskCount,
                                     int taskDurationMs) {
        long startTime = System.currentTimeMillis();
        CountDownLatch latch = new CountDownLatch(taskCount);
        AtomicInteger completedTasks = new AtomicInteger(0);
        AtomicLong totalResponseTime = new AtomicLong(0);

        // 提交任务
        for (int i = 0; i < taskCount; i++) {
            long submitTime = System.currentTimeMillis();
            executor.submit(() -> {
                try {
                    // 模拟任务执行
                    Thread.sleep(taskDurationMs);

                    // 记录响应时间
                    long responseTime = System.currentTimeMillis() - submitTime;
                    totalResponseTime.addAndGet(responseTime);
                    completedTasks.incrementAndGet();

                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown();
                }
            });
        }

        try {
            // 等待所有任务完成或超时
            boolean completed = latch.await(30, TimeUnit.SECONDS);
            long endTime = System.currentTimeMillis();

            // 输出测试结果
            System.out.println("=== 负载测试结果 ===");
            System.out.println("总任务数: " + taskCount);
            System.out.println("完成任务数: " + completedTasks.get());
            System.out.println("总耗时: " + (endTime - startTime) + "ms");
            System.out.println("平均响应时间: " +
                             totalResponseTime.get() / completedTasks.get() + "ms");
            System.out.println("吞吐量: " +
                             (completedTasks.get() * 1000.0 / (endTime - startTime)) + " tasks/s");
            System.out.println("任务完成率: " +
                             (completedTasks.get() * 100.0 / taskCount) + "%");

            // 线程池统计
            System.out.println("最大线程数: " + executor.getLargestPoolSize());
            System.out.println("当前线程数: " + executor.getPoolSize());
            System.out.println("队列最大长度: " + executor.getQueue().size());

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

### 监控与告警

#### 1. 线程池监控指标

```java
public class ThreadPoolMonitor {
    private final ThreadPoolExecutor executor;
    private final String poolName;

    public ThreadPoolMonitor(ThreadPoolExecutor executor, String poolName) {
        this.executor = executor;
        this.poolName = poolName;
    }

    public ThreadPoolMetrics getMetrics() {
        return ThreadPoolMetrics.builder()
            .poolName(poolName)
            .corePoolSize(executor.getCorePoolSize())
            .maximumPoolSize(executor.getMaximumPoolSize())
            .currentPoolSize(executor.getPoolSize())
            .activeCount(executor.getActiveCount())
            .largestPoolSize(executor.getLargestPoolSize())
            .taskCount(executor.getTaskCount())
            .completedTaskCount(executor.getCompletedTaskCount())
            .queueSize(executor.getQueue().size())
            .queueRemainingCapacity(executor.getQueue().remainingCapacity())
            .isShutdown(executor.isShutdown())
            .isTerminated(executor.isTerminated())
            .build();
    }

    public void startPeriodicMonitoring(int intervalSeconds) {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(() -> {
            ThreadPoolMetrics metrics = getMetrics();
            logMetrics(metrics);
            checkAlerts(metrics);
        }, 0, intervalSeconds, TimeUnit.SECONDS);
    }

    private void logMetrics(ThreadPoolMetrics metrics) {
        System.out.printf("[%s] Pool: %d/%d, Active: %d, Queue: %d/%d, Tasks: %d/%d%n",
            metrics.getPoolName(),
            metrics.getCurrentPoolSize(), metrics.getMaximumPoolSize(),
            metrics.getActiveCount(),
            metrics.getQueueSize(),
            metrics.getQueueSize() + metrics.getQueueRemainingCapacity(),
            metrics.getCompletedTaskCount(), metrics.getTaskCount()
        );
    }

    private void checkAlerts(ThreadPoolMetrics metrics) {
        // 队列使用率告警
        double queueUtilization = (double) metrics.getQueueSize() /
            (metrics.getQueueSize() + metrics.getQueueRemainingCapacity());
        if (queueUtilization > 0.9) {
            System.err.printf("警告: [%s] 队列使用率过高: %.2f%%%n",
                            metrics.getPoolName(), queueUtilization * 100);
        }

        // 线程利用率告警
        if (metrics.getCurrentPoolSize() > 0) {
            double threadUtilization = (double) metrics.getActiveCount() /
                                     metrics.getCurrentPoolSize();
            if (threadUtilization > 0.95) {
                System.err.printf("警告: [%s] 线程利用率过高: %.2f%%%n",
                                metrics.getPoolName(), threadUtilization * 100);
            }
        }

        // 任务积压告警
        long pendingTasks = metrics.getTaskCount() - metrics.getCompletedTaskCount();
        if (pendingTasks > metrics.getMaximumPoolSize() * 10) {
            System.err.printf("警告: [%s] 任务积压严重: %d个待处理任务%n",
                            metrics.getPoolName(), pendingTasks);
        }
    }
}
```

#### 2. JMX 监控集成

```java
public class ThreadPoolJMXMonitor implements ThreadPoolJMXMonitorMBean {
    private final ThreadPoolExecutor executor;

    public ThreadPoolJMXMonitor(ThreadPoolExecutor executor, String jmxName) {
        this.executor = executor;
        try {
            MBeanServer server = ManagementFactory.getPlatformMBeanServer();
            ObjectName objectName = new ObjectName("ThreadPool:type=" + jmxName);
            server.registerMBean(this, objectName);
        } catch (Exception e) {
            throw new RuntimeException("Failed to register JMX MBean", e);
        }
    }

    @Override
    public int getCorePoolSize() {
        return executor.getCorePoolSize();
    }

    @Override
    public int getMaximumPoolSize() {
        return executor.getMaximumPoolSize();
    }

    @Override
    public int getCurrentPoolSize() {
        return executor.getPoolSize();
    }

    @Override
    public int getActiveCount() {
        return executor.getActiveCount();
    }

    @Override
    public long getTaskCount() {
        return executor.getTaskCount();
    }

    @Override
    public long getCompletedTaskCount() {
        return executor.getCompletedTaskCount();
    }

    @Override
    public int getQueueSize() {
        return executor.getQueue().size();
    }

    // JMX接口
    public interface ThreadPoolJMXMonitorMBean {
        int getCorePoolSize();
        int getMaximumPoolSize();
        int getCurrentPoolSize();
        int getActiveCount();
        long getTaskCount();
        long getCompletedTaskCount();
        int getQueueSize();
    }
}
```

### 调优最佳实践

#### 1. 参数设置建议

```java
public class ThreadPoolBestPractices {

    /**
     * Web服务器线程池配置
     */
    public static ThreadPoolExecutor createWebServerPool() {
        int coreSize = Runtime.getRuntime().availableProcessors() * 2;
        int maxSize = coreSize * 4;

        return new ThreadPoolExecutor(
            coreSize, maxSize,
            60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(1000),
            new NamedThreadFactory("WebServer"),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }

    /**
     * 数据处理线程池配置
     */
    public static ThreadPoolExecutor createDataProcessingPool() {
        int coreSize = Runtime.getRuntime().availableProcessors();

        return new ThreadPoolExecutor(
            coreSize, coreSize,
            0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<>(500),
            new NamedThreadFactory("DataProcessor"),
            new ThreadPoolExecutor.AbortPolicy()
        );
    }

    /**
     * 异步任务线程池配置
     */
    public static ThreadPoolExecutor createAsyncTaskPool() {
        int coreSize = Runtime.getRuntime().availableProcessors();
        int maxSize = coreSize * 2;

        return new ThreadPoolExecutor(
            coreSize, maxSize,
            300L, TimeUnit.SECONDS,
            new PriorityBlockingQueue<>(100),
            new NamedThreadFactory("AsyncTask"),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
}
```

## 线程池最佳实践

### 1. 线程池设计原则

#### 单一职责原则

```java
// 推荐：不同类型的任务使用不同的线程池
public class ThreadPoolManager {

    // CPU密集型任务线程池
    private static final ThreadPoolExecutor CPU_POOL = new ThreadPoolExecutor(
        Runtime.getRuntime().availableProcessors() + 1,
        Runtime.getRuntime().availableProcessors() + 1,
        0L, TimeUnit.MILLISECONDS,
        new ArrayBlockingQueue<>(100),
        new NamedThreadFactory("CPU-Task"),
        new ThreadPoolExecutor.CallerRunsPolicy()
    );

    // IO密集型任务线程池
    private static final ThreadPoolExecutor IO_POOL = new ThreadPoolExecutor(
        Runtime.getRuntime().availableProcessors() * 2,
        Runtime.getRuntime().availableProcessors() * 4,
        60L, TimeUnit.SECONDS,
        new LinkedBlockingQueue<>(200),
        new NamedThreadFactory("IO-Task"),
        new ThreadPoolExecutor.CallerRunsPolicy()
    );

    // 异步消息处理线程池
    private static final ThreadPoolExecutor MESSAGE_POOL = new ThreadPoolExecutor(
        5, 10,
        300L, TimeUnit.SECONDS,
        new ArrayBlockingQueue<>(1000),
        new NamedThreadFactory("Message"),
        new ThreadPoolExecutor.DiscardOldestPolicy()
    );

    public static void submitCpuTask(Runnable task) {
        CPU_POOL.submit(task);
    }

    public static void submitIoTask(Runnable task) {
        IO_POOL.submit(task);
    }

    public static void submitMessage(Runnable task) {
        MESSAGE_POOL.submit(task);
    }
}
```

#### 合理的资源隔离

```java
// 推荐：为不同业务模块创建独立的线程池
public class BusinessThreadPools {

    // 用户服务线程池
    public static final ThreadPoolExecutor USER_SERVICE_POOL =
        createBusinessPool("UserService", 10, 20, 500);

    // 订单服务线程池
    public static final ThreadPoolExecutor ORDER_SERVICE_POOL =
        createBusinessPool("OrderService", 15, 30, 1000);

    // 支付服务线程池
    public static final ThreadPoolExecutor PAYMENT_SERVICE_POOL =
        createBusinessPool("PaymentService", 5, 10, 200);

    private static ThreadPoolExecutor createBusinessPool(String name,
                                                       int core,
                                                       int max,
                                                       int queueSize) {
        return new ThreadPoolExecutor(
            core, max,
            60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(queueSize),
            new NamedThreadFactory(name),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
}
```

### 2. 异常处理最佳实践

#### 全局异常处理

```java
public class SafeThreadFactory implements ThreadFactory {
    private final String namePrefix;
    private final AtomicInteger threadNumber = new AtomicInteger(1);

    public SafeThreadFactory(String namePrefix) {
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread thread = new Thread(r, namePrefix + "-" + threadNumber.getAndIncrement());

        // 设置为非守护线程
        thread.setDaemon(false);

        // 设置线程优先级
        thread.setPriority(Thread.NORM_PRIORITY);

        // 设置未捕获异常处理器
        thread.setUncaughtExceptionHandler((t, e) -> {
            System.err.printf("线程 %s 发生未捕获异常: %s%n", t.getName(), e.getMessage());
            e.printStackTrace();

            // 可以在这里添加日志记录、告警等逻辑
            // logger.error("Uncaught exception in thread: " + t.getName(), e);
            // alertService.sendAlert("Thread exception", e);
        });

        return thread;
    }
}
```

#### 任务包装与异常隔离

```java
public class SafeTaskWrapper {

    public static Runnable wrap(Runnable task, String taskName) {
        return () -> {
            try {
                System.out.println("开始执行任务: " + taskName);
                long startTime = System.currentTimeMillis();

                task.run();

                long duration = System.currentTimeMillis() - startTime;
                System.out.println("任务 " + taskName + " 执行完成，耗时: " + duration + "ms");

            } catch (Exception e) {
                System.err.println("任务 " + taskName + " 执行失败: " + e.getMessage());
                e.printStackTrace();

                // 异常处理逻辑
                handleTaskException(taskName, e);
            }
        };
    }

    public static <T> Callable<T> wrap(Callable<T> task, String taskName) {
        return () -> {
            try {
                System.out.println("开始执行任务: " + taskName);
                long startTime = System.currentTimeMillis();

                T result = task.call();

                long duration = System.currentTimeMillis() - startTime;
                System.out.println("任务 " + taskName + " 执行完成，耗时: " + duration + "ms");

                return result;

            } catch (Exception e) {
                System.err.println("任务 " + taskName + " 执行失败: " + e.getMessage());
                e.printStackTrace();

                handleTaskException(taskName, e);
                throw e; // 重新抛出异常
            }
        };
    }

    private static void handleTaskException(String taskName, Exception e) {
        // 记录异常日志
        // logger.error("Task {} failed", taskName, e);

        // 发送告警
        // alertService.sendAlert("Task execution failed: " + taskName, e);

        // 更新监控指标
        // metrics.incrementFailedTaskCount(taskName);
    }
}

// 使用示例
executor.submit(SafeTaskWrapper.wrap(() -> {
    // 业务逻辑
    processData();
}, "数据处理任务"));
```

### 3. 性能优化技巧

#### 预热线程池

```java
public class ThreadPoolWarmer {

    public static void warmUp(ThreadPoolExecutor executor) {
        int coreSize = executor.getCorePoolSize();

        // 提交空任务来创建核心线程
        List<Future<?>> futures = new ArrayList<>();
        for (int i = 0; i < coreSize; i++) {
            futures.add(executor.submit(() -> {
                // 空任务，用于触发线程创建
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }));
        }

        // 等待预热完成
        for (Future<?> future : futures) {
            try {
                future.get(1, TimeUnit.SECONDS);
            } catch (Exception e) {
                // 忽略异常
            }
        }

        System.out.println("线程池预热完成，当前线程数: " + executor.getPoolSize());
    }
}
```

#### 任务优先级处理

```java
public class PriorityTask implements Runnable, Comparable<PriorityTask> {
    private final Runnable task;
    private final int priority;
    private final long submitTime;

    public PriorityTask(Runnable task, int priority) {
        this.task = task;
        this.priority = priority;
        this.submitTime = System.currentTimeMillis();
    }

    @Override
    public void run() {
        task.run();
    }

    @Override
    public int compareTo(PriorityTask other) {
        // 优先级高的任务先执行（数字越小优先级越高）
        int result = Integer.compare(this.priority, other.priority);
        if (result == 0) {
            // 优先级相同时，提交时间早的先执行
            result = Long.compare(this.submitTime, other.submitTime);
        }
        return result;
    }

    // 创建带优先级的线程池
    public static ThreadPoolExecutor createPriorityPool() {
        return new ThreadPoolExecutor(
            5, 10,
            60L, TimeUnit.SECONDS,
            new PriorityBlockingQueue<>(100),
            new NamedThreadFactory("Priority"),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
    }
}

// 使用示例
ThreadPoolExecutor priorityPool = PriorityTask.createPriorityPool();
priorityPool.submit(new PriorityTask(() -> System.out.println("高优先级任务"), 1));
priorityPool.submit(new PriorityTask(() -> System.out.println("普通任务"), 5));
priorityPool.submit(new PriorityTask(() -> System.out.println("低优先级任务"), 10));
```

### 4. 线程池生命周期管理

#### Spring 集成

```java
@Configuration
@EnableAsync
public class ThreadPoolConfig implements AsyncConfigurer {

    @Bean("taskExecutor")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();

        // 核心线程数
        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());
        // 最大线程数
        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 2);
        // 队列容量
        executor.setQueueCapacity(500);
        // 线程空闲时间
        executor.setKeepAliveSeconds(60);
        // 线程名前缀
        executor.setThreadNamePrefix("Async-");
        // 拒绝策略
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        // 等待所有任务完成后再关闭
        executor.setWaitForTasksToCompleteOnShutdown(true);
        // 等待时间
        executor.setAwaitTerminationSeconds(60);

        executor.initialize();
        return executor;
    }

    @Override
    public Executor getAsyncExecutor() {
        return taskExecutor();
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (ex, method, params) -> {
            System.err.printf("异步方法 %s 执行异常: %s%n", method.getName(), ex.getMessage());
            ex.printStackTrace();
        };
    }
}
```

#### 优雅关闭

```java
public class GracefulShutdownManager {
    private final List<ThreadPoolExecutor> threadPools = new ArrayList<>();

    public void registerThreadPool(ThreadPoolExecutor executor) {
        threadPools.add(executor);
    }

    @PreDestroy
    public void shutdown() {
        System.out.println("开始关闭线程池...");

        // 第一步：停止接收新任务
        for (ThreadPoolExecutor executor : threadPools) {
            executor.shutdown();
        }

        // 第二步：等待现有任务完成
        for (ThreadPoolExecutor executor : threadPools) {
            try {
                if (!executor.awaitTermination(30, TimeUnit.SECONDS)) {
                    System.out.println("强制关闭线程池");
                    List<Runnable> pendingTasks = executor.shutdownNow();
                    System.out.println("丢弃任务数: " + pendingTasks.size());

                    // 再次等待
                    if (!executor.awaitTermination(10, TimeUnit.SECONDS)) {
                        System.err.println("线程池未能正常关闭");
                    }
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
            }
        }

        System.out.println("所有线程池已关闭");
    }
}
```

### 5. 常见陷阱与避免方法

#### 避免内存泄漏

```java
public class ThreadLocalCleanup {

    // 错误示例：可能导致内存泄漏
    private static final ThreadLocal<ExpensiveObject> THREAD_LOCAL =
        new ThreadLocal<ExpensiveObject>() {
            @Override
            protected ExpensiveObject initialValue() {
                return new ExpensiveObject();
            }
        };

    // 正确示例：使用后及时清理
    public static void processWithThreadLocal() {
        try {
            ExpensiveObject obj = THREAD_LOCAL.get();
            // 使用obj进行处理
            obj.process();
        } finally {
            // 清理ThreadLocal
            THREAD_LOCAL.remove();
        }
    }
}
```

#### 避免任务泄漏

```java
public class TaskLeakPrevention {

    public static void submitTaskSafely(ThreadPoolExecutor executor,
                                      Callable<String> task,
                                      int timeoutSeconds) {
        Future<String> future = executor.submit(task);

        try {
            // 设置超时时间，避免任务永远不返回
            String result = future.get(timeoutSeconds, TimeUnit.SECONDS);
            System.out.println("任务执行结果: " + result);

        } catch (TimeoutException e) {
            System.err.println("任务执行超时，取消任务");
            future.cancel(true); // 中断任务

        } catch (Exception e) {
            System.err.println("任务执行异常: " + e.getMessage());

        }
    }
}
```

### 6. 监控与告警实践

#### 完整监控方案

```java
@Component
public class ComprehensiveThreadPoolMonitor {

    private final Map<String, ThreadPoolExecutor> pools = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler =
        Executors.newScheduledThreadPool(1,
            new SafeThreadFactory("Monitor"));

    public void registerPool(String name, ThreadPoolExecutor executor) {
        pools.put(name, executor);
    }

    @PostConstruct
    public void startMonitoring() {
        scheduler.scheduleAtFixedRate(this::collectAndReportMetrics,
                                    0, 30, TimeUnit.SECONDS);
    }

    private void collectAndReportMetrics() {
        for (Map.Entry<String, ThreadPoolExecutor> entry : pools.entrySet()) {
            String poolName = entry.getKey();
            ThreadPoolExecutor executor = entry.getValue();

            // 收集指标
            ThreadPoolMetrics metrics = buildMetrics(poolName, executor);

            // 记录日志
            logMetrics(metrics);

            // 检查告警条件
            checkAlerts(metrics);

            // 发送到监控系统（如Prometheus）
            reportToMonitoringSystem(metrics);
        }
    }

    private void checkAlerts(ThreadPoolMetrics metrics) {
        // 队列积压告警
        if (metrics.getQueueUtilization() > 0.9) {
            sendAlert("队列使用率过高", metrics);
        }

        // 线程利用率告警
        if (metrics.getThreadUtilization() > 0.95) {
            sendAlert("线程利用率过高", metrics);
        }

        // 任务执行时间告警
        if (metrics.getAverageTaskDuration() > 5000) { // 5秒
            sendAlert("任务执行时间过长", metrics);
        }

        // 拒绝任务告警
        if (metrics.getRejectedTaskRate() > 0.01) { // 1%
            sendAlert("任务拒绝率过高", metrics);
        }
    }

    private void sendAlert(String message, ThreadPoolMetrics metrics) {
        System.err.printf("告警: %s - 线程池: %s%n", message, metrics.getPoolName());
        // 集成告警系统
        // alertService.send(message, metrics);
    }

    @PreDestroy
    public void shutdown() {
        scheduler.shutdown();
    }
}
```

## 常见面试问题

### 1. 基础概念问题

#### Q: 什么是线程池？为什么要使用线程池？

**A:** 线程池是一种线程使用模式，它预先创建若干个线程，这些线程在循环中等待任务的到来并执行任务。

**使用线程池的原因：**

-   **降低资源消耗**：避免频繁创建和销毁线程的开销
-   **提高响应速度**：任务到达时可以立即执行，无需等待线程创建
-   **提高线程可管理性**：统一分配、调优和监控线程资源
-   **提供更多功能**：支持定时执行、周期执行、线程中断等

#### Q: 线程池的核心参数有哪些？

**A:** ThreadPoolExecutor 有 7 个核心参数：

1. **corePoolSize**：核心线程数
2. **maximumPoolSize**：最大线程数
3. **keepAliveTime**：线程空闲存活时间
4. **unit**：时间单位
5. **workQueue**：阻塞队列
6. **threadFactory**：线程工厂
7. **handler**：拒绝策略

### 2. 执行流程问题

#### Q: 描述线程池的任务执行流程

**A:**

```
1. 判断核心线程数是否已满
   ├─ 未满 → 创建核心线程执行任务
   └─ 已满 → 进入步骤2

2. 判断工作队列是否已满
   ├─ 未满 → 任务加入队列等待
   └─ 已满 → 进入步骤3

3. 判断最大线程数是否已满
   ├─ 未满 → 创建非核心线程执行任务
   └─ 已满 → 执行拒绝策略
```

#### Q: 什么时候会创建非核心线程？

**A:** 当满足以下**三个条件**时才会创建非核心线程：

1. 当前线程数 ≥ 核心线程数
2. 工作队列已满
3. 当前线程数 < 最大线程数

### 3. 队列选择问题

#### Q: 不同阻塞队列的选择场景？

**A:**

| 队列类型                  | 特点             | 适用场景                     |
| ------------------------- | ---------------- | ---------------------------- |
| **ArrayBlockingQueue**    | 有界数组队列     | 内存限制严格的场景           |
| **LinkedBlockingQueue**   | 可选有界链表队列 | 高并发场景，默认选择         |
| **SynchronousQueue**      | 无容量直接传递   | 任务处理速度快，实时性要求高 |
| **PriorityBlockingQueue** | 优先级队列       | 任务有优先级要求             |
| **DelayQueue**            | 延迟队列         | 定时任务，缓存过期           |

#### Q: 为什么不推荐使用无界队列？

**A:**

-   **内存风险**：可能导致 OOM
-   **参数失效**：maximumPoolSize 参数失效
-   **响应变慢**：任务堆积导致响应时间增长
-   **监控困难**：难以评估系统负载

### 4. 拒绝策略问题

#### Q: JDK 提供了哪些拒绝策略？各自的使用场景？

**A:**

```java
// 1. AbortPolicy（默认）- 抛出异常
new ThreadPoolExecutor.AbortPolicy()
// 场景：需要立即知道任务被拒绝的情况

// 2. CallerRunsPolicy - 调用者执行
new ThreadPoolExecutor.CallerRunsPolicy()
// 场景：任务重要，不能丢失，可以接受调用者阻塞

// 3. DiscardPolicy - 静默丢弃
new ThreadPoolExecutor.DiscardPolicy()
// 场景：任务不重要，可以接受丢失

// 4. DiscardOldestPolicy - 丢弃最老任务
new ThreadPoolExecutor.DiscardOldestPolicy()
// 场景：处理最新任务更重要
```

### 5. 参数配置问题

#### Q: 如何确定线程池的核心参数？

**A:**

**CPU 密集型任务：**

```java
corePoolSize = CPU核心数 + 1
```

**IO 密集型任务：**

```java
corePoolSize = CPU核心数 * (1 + 等待时间/计算时间)
// 或简化为：CPU核心数 * 2
```

**队列容量：**

```java
// 基于内存和响应时间要求
queueCapacity = (可用内存 * 0.1) / 单任务内存占用
```

#### Q: 为什么阿里巴巴规约不推荐使用 Executors 创建线程池？

**A:**

-   **FixedThreadPool**：队列长度 Integer.MAX_VALUE，可能 OOM
-   **CachedThreadPool**：最大线程数 Integer.MAX_VALUE，可能创建大量线程
-   **SingleThreadExecutor**：队列长度 Integer.MAX_VALUE，可能 OOM
-   **ScheduledThreadPool**：最大线程数 Integer.MAX_VALUE，可能创建大量线程

**推荐手动创建 ThreadPoolExecutor，明确指定各项参数。**

### 6. 线程池状态问题

#### Q: 线程池有哪些状态？如何转换？

**A:**

```
RUNNING → SHUTDOWN → TIDYING → TERMINATED
    ↓
   STOP → TIDYING → TERMINATED
```

-   **RUNNING**：接受新任务，处理队列任务
-   **SHUTDOWN**：不接受新任务，处理队列剩余任务
-   **STOP**：不接受新任务，不处理队列任务，中断正在执行的任务
-   **TIDYING**：所有任务终止，工作线程数为 0
-   **TERMINATED**：terminated()方法执行完成

#### Q: shutdown()和 shutdownNow()的区别？

**A:**

| 方法           | shutdown()       | shutdownNow()        |
| -------------- | ---------------- | -------------------- |
| **新任务**     | 拒绝接受         | 拒绝接受             |
| **队列任务**   | 继续处理         | 停止处理并返回       |
| **执行中任务** | 等待完成         | 尝试中断             |
| **返回值**     | void             | List&lt;Runnable&gt; |
| **状态转换**   | RUNNING→SHUTDOWN | RUNNING→STOP         |

### 7. 性能优化问题

#### Q: 如何监控线程池的运行状态？

**A:**

```java
// 关键监控指标
executor.getPoolSize()           // 当前线程数
executor.getActiveCount()        // 活跃线程数
executor.getTaskCount()          // 任务总数
executor.getCompletedTaskCount() // 已完成任务数
executor.getQueue().size()       // 队列大小

// 计算利用率
double threadUtilization = activeCount / poolSize
double queueUtilization = queueSize / (queueSize + remainingCapacity)
```

#### Q: 线程池出现性能问题如何排查？

**A:**

1. **响应时间长**：

    - 检查线程利用率和队列使用率
    - 增加核心线程数或减少队列容量

2. **CPU 利用率低**：

    - 可能线程数过多或任务等待时间长
    - 减少线程数或优化任务逻辑

3. **内存占用高**：

    - 检查队列大小和任务对象大小
    - 使用有界队列，优化任务对象

4. **任务被拒绝**：
    - 调整队列容量或拒绝策略
    - 考虑增加最大线程数

### 8. 源码理解问题

#### Q: 线程池如何实现线程复用？

**A:**
线程池通过**Worker 内部类**实现线程复用：

```java
// Worker继承AQS，实现Runnable
private final class Worker extends AbstractQueuedSynchronizer implements Runnable {
    final Thread thread;
    Runnable firstTask;

    public void run() {
        runWorker(this); // 循环获取任务执行
    }
}

// runWorker方法的核心逻辑
final void runWorker(Worker w) {
    Runnable task = w.firstTask;
    while (task != null || (task = getTask()) != null) {
        // 执行任务
        task.run();
        task = null; // 执行完毕，准备获取下一个任务
    }
}
```

#### Q: 线程池如何保证线程安全？

**A:**

1. **状态管理**：使用 AtomicInteger 的 CAS 操作
2. **Worker 管理**：使用 ReentrantLock 保护 workers 集合
3. **任务提交**：队列操作本身是线程安全的
4. **统计信息**：使用 volatile 变量和原子操作

### 9. 实际应用问题

#### Q: 在 Spring Boot 中如何配置异步线程池？

**A:**

```java
@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Bean
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(500);
        executor.setThreadNamePrefix("Async-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.setWaitForTasksToCompleteOnShutdown(true);
        executor.setAwaitTerminationSeconds(60);
        executor.initialize();
        return executor;
    }
}
```

#### Q: 如何实现线程池的优雅关闭？

**A:**

```java
public void gracefulShutdown(ExecutorService executor) {
    executor.shutdown(); // 停止接收新任务

    try {
        if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
            executor.shutdownNow(); // 强制关闭
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                System.err.println("Pool did not terminate");
            }
        }
    } catch (InterruptedException ie) {
        executor.shutdownNow();
        Thread.currentThread().interrupt();
    }
}
```

这些是 Java 线程池相关的核心面试问题，掌握这些内容能够应对大部分线程池相关的技术面试。

````

#### 无界队列的问题
```java
// 危险的配置
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 5, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(),  // 无界队列
    new ThreadPoolExecutor.AbortPolicy()
);

// 问题：
// 1. maximumPoolSize参数无效（永远不会创建超过corePoolSize的线程）
// 2. 可能导致内存溢出
// 3. 任务堆积，响应时间变长
````

### 什么是线程池

在面向对象编程中，创建和销毁对象是很费时间的，创建一个对象要获取内存资源或者其它更多资源。Java 虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是“池化资源”技术产生的原因
线程池，就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销
Java 5+ 中的 Executor 接口定义一个执行线程的工具，它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池：

-   newSingleThreadExecutor
    创建一个单线程的线程池，这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行
-   newFixedThreadPool
    创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
-   newCachedThreadPool
    创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小
-   newScheduledThreadPool
    创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求

### 为什么要使用线程池

避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。

### 线程池队列已满会发生什么

-   使用的 LinkedBlockingQueue，也就是无界队列的话，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务
-   使用的是有界队列，如 ArrayBlockingQueue，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue 满了，则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy

### 线程池有哪些参数？

-   corePoolSize：核心线程数，线程池中始终存活的线程数
-   maximumPoolSize：最大线程数，线程池中允许的最大线程数
-   keepAliveTime：存活时间，线程没有任务执行时最多保持多久时间会终止
-   unit：单位，参数 keepAliveTime 的时间单位，7 种可选
-   workQueue：一个阻塞队列，用来存储等待执行的任务，均为线程安全，7 种可选
-   threadFactory：线程工厂，主要用来创建线程，默及正常优先级、非守护线程
-   handler：拒绝策略，拒绝处理任务时的策略，4 种可选，默认为 AbortPolicy
    -   AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
    -   CallerRunsPolicy：只用调用者所在的线程来处理任务
    -   DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
    -   DiscardPolicy：直接丢弃任务，也不抛出异常

### 线程池的执行流程

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687053962-02fe8165-06c9-41c1-8d4b-63f03628fa58.png#averageHue=%23faf8f6&clientId=u00400ee8-e274-4&from=paste&id=uf6eb3d33&originHeight=1054&originWidth=1154&originalType=url&ratio=1&rotation=0&showTitle=false&size=209121&status=done&style=none&taskId=u30ef56a3-c059-4c9f-9167-6432e1b4614&title=)

-   判断线程池中的线程数是否大于设置的核心线程数
    -   如果小于，就创建一个核心线程来执行任务
    -   如果大于，就会判断缓冲队列是否满了
        -   如果没有满，则放入队列，等待线程空闲时执行任务
        -   如果队列已经满了，则判断是否达到了线程池设置的最大线程数
            -   如果没有达到，就创建新线程来执行任务
            -   如果已经达到了最大线程数，则执行指定的拒绝策略

### 线程池的拒绝策略有哪些

-   AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
-   CallerRunsPolicy：只用调用者所在的线程来处理任务
-   DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
-   DiscardPolicy：直接丢弃任务，也不抛出异常

### 讲讲线程池的实现原理

使用线程池的好处

-   线程是稀缺资源，不能频繁的创建。
-   应当将其放入一个池子中，可以给其他任务进行复用。
-   解耦作用，线程的创建于执行完全分开，方便维护。

创建一个线程池

```java
ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler);
```

为例：

-   corePoolSize 为线程池的基本大小。
-   maximumPoolSize 为线程池最大线程大小。
-   keepAliveTime 和 unit 则是线程空闲后的存活时间。
-   workQueue 用于存放任务的阻塞队列。
-   handler 当队列和最大线程池都满了之后的饱和策略。

处理流程
当提交一个任务到线程池时它的执行流程是怎样的呢？
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687053872-c8d4bbec-3a1b-41bb-a7dc-96fabc906a8a.png#averageHue=%23fbfdfa&clientId=u00400ee8-e274-4&from=paste&id=u47de066c&originHeight=293&originWidth=500&originalType=url&ratio=1&rotation=0&showTitle=false&size=84049&status=done&style=none&taskId=ubd82d4b7-1812-4389-83c8-651f4b36fa8&title=)
首先第一步会判断核心线程数有没有达到上限，如果没有则创建线程(会获取全局锁)，满了则会将任务丢进阻塞队列。
如果队列也满了则需要判断最大线程数是否达到上限，如果没有则创建线程(获取全局锁)，如果最大线程数也满了则会根据饱和策略处理。
常用的饱和策略有:

-   直接丢弃任务。
-   调用者线程处理。
-   丢弃队列中的最近任务，执行当前任务。

所以当线程池完成预热之后都是将任务放入队列，接着由工作线程一个个从队列里取出执行。
合理配置线程池
线程池并不是配置越大越好，而是要根据任务的熟悉来进行划分： 如果是 CPU 密集型任务应当分配较少的线程，比如 CPU 个数相当的大小。
如果是 IO 密集型任务，由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 \* 2 。
当是一个混合型任务，可以将其拆分为 CPU 密集型任务以及 IO 密集型任务，这样来分别配置。
