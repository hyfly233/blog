## 基础

### 进程

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位

### 线程

线程是进程的一个实体，是 CPU 调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存

### 进程与线程区别

-   进程
    是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是指令、数据及其组织形式的描述，进程是程序的实体。总结：进程是指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程——资源分配的最小单位
-   线程
    操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。总结：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。线程——程序执行的最小单位

### 多线程编程

通常使用多线程的编程通常能够带来更好的性能。也不是线程越多性能越好，因为线程之间的调度和切换也会浪费 CPU 时间

### 什么是线程安全

如果代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么代码就是线程安全的

-   不可变
    像 String、Integer、Long 这些，都是 final 类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用
-   绝对线程安全
    不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java 中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java 中也有，比方说 CopyOnWriteArrayList、CopyOnWriteArraySet
-   相对线程安全
    相对线程安全也就是我们通常意义上所说的线程安全，像 Vector 这种，add、remove 方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个 Vector、有个线程同时在 add 这个 Vector，99%的情况下都会出现 ConcurrentModificationException，也就是 fail-fast 机制。
-   线程非安全
    ArrayList、LinkedList、HashMap 等都是线程非安全的类

### 同步和异步

同步和异步是计算机编程中两个重要的概念，它们指的是不同的执行方式和协调方式。

-   **同步
    **指的是程序**按照顺序依次执行**，每个操作必须等待上一个操作完成后才能执行。在同步模式下，程序执行时会**阻塞**，直到前一个操作完成，才会继续执行后续操作。同步模式适用于**数据量较小、执行时间较短**的操作。
-   **异步
    **指的是程序执行时**不需要等待上一个操作完成**，可以继续执行后续操作。在异步模式下，程序执行**不会阻塞**，可以在后台执行多个操作，提高程序的效率。异步模式适用于**数据量较大、执行时间较长**的操作，比如网络请求、文件读取等。

在实际编程中，同步和异步的选择取决于程序的具体需求。如果程序需要按照固定的顺序依次执行操作，可以选择同步模式；如果程序需要执行多个操作，而且这些操作相互独立，可以选择异步模式。同时，也可以使用异步模式来提高程序的响应速度，避免因为等待某个操作而造成程序的阻塞。

### String s1 = "hello"; s1 = "world"; 这两部是线程安全的吗

在 Java 中，String 是不可变类（immutable class），一旦创建了一个 String 对象，就无法修改该对象的值。因此，String s1 = "hello"创建了一个 String 对象，而 s1 = "world"又创建了一个新的 String 对象，而不是修改原来的 String 对象。这个过程是线程安全的，因为每个线程都是在自己的栈帧中操作，不会影响其他线程的执行。
值得注意的是，虽然这个过程是线程安全的，但是如果多个线程同时修改同一个 String 对象的值，就会出现线程安全问题。例如，如果一个线程执行 s1 = "hello"，另一个线程执行 s1 = "world"，就可能出现竞态条件（race condition），导致 s1 的值不确定。

### 常见线程安全类

线程安全类的每个方法是原子的，但多个原子方法组合调用时不是原子的，不能保证线程安全

-   String
-   StringBuffer
-   原子类
-   Random
-   Vector
-   Hashtable
-   java.util.concurrent

### 线程安全的基本数据结构

-   HashTable: 哈希表的线程安全版，效率低
-   ConcurrentHashMap：哈希表的线程安全版，效率高，用于替代 HashTable
-   Vector：线程安全版 Arraylist
-   Stack：线程安全版栈
-   BlockingQueue 及其子类：线程安全版队列

### 启动一个线程是调用 run() 还是 start() 方法

启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。

### 为什么需要 run()和 start()方法，可以只用 run()方法来完成任务吗

需要 run()和 start()这两个方法：因为 JVM 创建一个单独的线程不同于普通方法的调用，所以这项工作由线程的 start()方法来完成，start()由本地方法实现，需要显示地被调用，使用这俩个方法的另外一个好处是任何一个对象都可以作为线程运行，只要实现了 Runnable 接口，这就避免因继承了 Thread 类而造成的 Java 的多继承问题。

### 描述一下 Java 线程的生命周期

1. 大致包括 5 个阶段
    1. 新建
       刚使用 new 方法，new 出来的线程
    2. 就绪
       调用的线程的 Thread#start()方法后，这时候线程处于等待 CPU 分配资源阶段，谁先抢到 CPU 资源，谁开始执行
    3. 运行
       当就绪的线程被调度并获得 CPU 资源时，便进入运行状态，run 方法定义了线程的操作和功能
    4. 阻塞
       在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如 sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用 notify()或者 notifyAll()方法。唤醒的线程不会立刻执行 run 方法，它们要再次等待 CPU 分配资源进入运行状态
    5. 销毁
       如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源
2. 按 JDK 的源码分析来看，Thread 的状态分为
    1. NEW
       尚未启动的线程的线程状态
    2. RUNNABLE
       处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自操作系统（例如处理器）的其他资源
    3. BLOCKED
       线程的线程状态被阻塞，等待监视器锁定。处于阻塞状态的线程正在等待 监视器锁定以输入同步的块方法或在调用后重新输入同步的块方法，通过 Object#wait() 进入阻塞
    4. WAITING
       处于等待状态的线程正在等待另一个线程执行特定操作，例如: 在对象上调用了 Object#wait() 的线程正在等待另一个线程调用 Object#notify() 或者 Object#notifyAll()，调用了 Thread#join() 的线程正在等待指定的线程终止
    5. TIMED_WAITING
       具有指定等待时间的等待线程的线程状态。由于以指定的正等待时间调用以下方法之一，因此线程处于定时等待状态：
        1. Thread#sleep(long)
        2. Object#wait(long)
        3. Thread#join(long)
        4. LockSupport#parkNanos(long...)
        5. LockSupport#parkUntil(long...)
    6. TERMINATED
       终止线程的线程状态，线程已完成执行

### 线程的基本状态以及状态之间的关系

![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051706-9fefe5bc-4ca2-4e1f-8e7c-2ce086a3a6cc.png#averageHue=%23f7f7f7&clientId=u00400ee8-e274-4&from=paste&id=u92ec9f69&originHeight=428&originWidth=757&originalType=url&ratio=1&rotation=0&showTitle=false&size=79014&status=done&style=none&taskId=u4b6a98e7-320b-4f34-a48b-6d1128ab04c&title=)

-   Running 表示运行状态，Runnable 表示就绪状态（万事俱备，只欠 CPU）
-   Blocked 表示阻塞状态，阻塞状态又有多种情况，可能是因为调用 wait() 方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了 sleep() 方法或 join() 方法等待休眠或其他线程结束，或是因为发生了 I/O 中断

### 什么是线程饥饿、线程饿死

所谓线程饥饿（Starvation）：指的是在多线程的资源竞争中，存在贪婪的线程一直锁定资源不释放，其他的线程则始终处于等待状态，然而这个等待是没有结果的，它们会被活活地饿死。 当获得锁的线程需要执行无限时间长的操作时（比如 IO 或者无限循环），那么后面的线程将会被无限阻塞，导致被饿死。

### 什么是活锁

活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试、失败、尝试、失败。活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。活锁可以认为是一种特殊的饥饿。

### 什么导致线程阻塞

阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），Java 提供了大量方法来支持阻塞

| 方法                  | 说明                                                                                                                                                                                                                            |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| sleep()               | sleep() 允许指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到 CPU 时间，指定的时间一过，线程重新进入可执行状态                                                                                 |
| suspend() 和 resume() | 两个方法配套使用，suspend() 使得线程进入阻塞状态，并且不会自动恢复，必须其对应的 resume() 被调用，才能使得线程重新进入可执行状态                                                                                                |
| yield()               | yield() 使当前线程放弃当前已经分得的 CPU 时间，但不使当前线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程                           |
| wait() 和 notify()    | 两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用 |

### 怎么检测一个线程是否持有对象监视器

Thread 类提供了一个 holdsLock(Object obj) 方法，当且仅当对象 obj 的监视器被当前线程持有的时候才会返回 true，这是一个 static 方法

### 说出与线程同步以及线程调度相关的方法

-   wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；
-   sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；
-   notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；
-   notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；

### sleep()、join()、yield()有什么区别 todo

-   sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
-   线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
-   sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
-   sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。

### wait()、notify()和 suspend()、resume()之间的区别 todo

### 为什么 wait()方法和 notify()/notifyAll()方法要在同步块中被调用

这是 JDK 强制的，wait()方法和 notify()/notifyAll()方法在调用前都必须先获得对象的锁

### wait()方法和 notify()/notifyAll()方法在放弃对象监视器时有什么区别

区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器

### Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别？

-   sleep()方法（休眠）是 Thread 线程类的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复
-   wait()是 Object 类的方法，调用对象的 wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的 notify()方法（或 notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。

### 线程的 sleep()方法和 yield()方法有什么区别 todo

1. sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
2. 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
3. sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
4. sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。

### 为什么 wait、nofity 和 nofityAll 这些方法不放在 Thread 类当中

一个很明显的原因是 JAVA 提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的 wait()方法就有意义了。如果 wait()方法定义在 Thread 类中，线程正在等待的是哪个锁就不明显了。简单的说，由于 wait，notify 和 notifyAll 都是锁级别的操作，所以把他们定义在 Object 类中因为锁属于对象。

### 怎么唤醒一个阻塞的线程

如果线程是因为调用了 wait()、sleep()或者 join()方法而导致的阻塞，可以中断线程，并且通过抛出 InterruptedException 来唤醒它；如果线程遇到了 IO 阻塞，无能为力，因为 IO 是操作系统实现的，Java 代码并没有办法直接接触到操作系统

### 什么是多线程的上下文切换

多线程的上下文切换：指 CPU 控制权由一个已经正在运行的线程切换到另外一个就绪，并等待获取 CPU 执行权的线程的过程

### 一个线程如果出现了运行时异常怎么办？

如果这个异常没有被捕获的话，这个线程就停止执行了。另外如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放

## Wait、Notify

### 如何正确的使用 wait()，使用 if 还是 while？

wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好

```java
synchronized (obj) {
  while (condition does not hold) {
  	obj.wait();

  }
}
```

### 描述一下 notify 和 notifyAll 的区别 todo

## Lock

## Future

### FutureTask 是什么

FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。

## 虚拟线程

### 如何在两个线程间共享数据

可以通过在线程之间共享对象，然后通过 wait/notify/notifyAll、await/signal/signalAll 进行唤起和等待，比如阻塞队列 BlockingQueue 就是为线程之间共享数据而设计的

### Java 中用到的线程调度算法是什么

抢占式，一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行

### Thread.sleep(0)的作用是什么

由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU 控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用 Thread.sleep(0) 手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制权的一种操作

### 什么是 CAS

CAS，全称为 Compare and Swap，即比较-替换。假设有三个操作数：内存值 V、旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false。当然 CAS 一定要 volatile 变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功

### ConcurrentHashMap 的并发度是什么？

ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有 16 条线程操作 ConcurrentHashMap，这也是 ConcurrentHashMap 对 Hashtable 的最大优势

### 任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗？ todo

### ConcurrentHashMap 的工作原理

ConcurrentHashMap 在 jdk 1.6 和 jdk 1.8 实现原理是不同的

-   jdk 1.6：ConcurrentHashMap 是线程安全的，但是与 Hashtable 相比，实现线程安全的方式不同。Hashtable 是通过对 hash 表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap 是采用分离锁的方式，它并没有对整个 hash 表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对 hash 表其他地方的访问。具体实现: ConcurrentHashMap 内部有一个 Segment
-   jdk 1.8：在 jdk 8 中，ConcurrentHashMap 不再使用 Segment 分离锁，而是采用一种乐观锁 CAS 算法来实现同步问题，但其底层还是“数组 + 链表 -> 红黑树”的实现

### java 中的++操作符线程安全么

不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差

### 有三个线程 T1，T2，T3，怎么确保它们按顺序执行？

在多线程中有多种方法让线程按特定顺序执行，可以用 Thread#join() 方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序应该先启动最后一个(T3 调用 T2，T2 调用 T1)，这样 T1 就会先完成而 T3 最后完成

### 有哪些多线程开发良好的实践

-   给线程命名
-   最小化同步的范围，而不是将整个方法同步，只对关键部分做同步
-   优先使用 volatile 而不是 synchronized
-   尽可能使用更高层次的并发工具而非 wait 和 notify() 来实现线程通信，如 BlockingQueue、CountDownLatch、Semeaphore
-   优先使用并发容器而非同步容器
-   考虑使用线程池

### 作业(进程)调度算法 todo

1. 先来先服务调度算法(FCFS) 每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。
2. 短作业(进程)优先调度算法(SPF) 短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。缺点:长作业的运行得不到保证
3. 优先权调度算法(HPF) 当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。 可以分为:
    - 非抢占式优先权算法
    - 抢占式优先权调度算法
4. 高响应比优先调度算法(HRN) 每次选择高响应比最大的作业执行，响应比=(等待时间+要求服务时间)/要求服务时间。该算法同时考虑了短作业优先和先来先服务。
    - 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。
    - 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。
    - 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。
5. 时间片轮转法（RR） 在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。
6. 多级反馈队列调度算法 它是目前被公认的一种较好的进程调度算法。
    - 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。
    - 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。
    - 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1 ～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1 ～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。

### 描述一下线程安全活跃态问题，竞态条件 todo

读写锁会造成饥饿

1. 线程安全的活跃性问题分为死锁、活锁、饥饿
    1. 活锁：就是有时线程虽然没有发生阻塞，但是仍然会存在执行不下去的情况，活锁不会阻 塞线程，线程会一直重复执行某个相同的操作，并且一直失败重试
        1. 我们开发中使用的异步消息队列就有可能造成活锁的问题，在消息队列的消费端如 果没有正确的 ack 消息，并且执行过程中报错了，就会再次放回消息头，然后再拿 出来执行，一直循环往复的失败。这个问题除了正确的 ack 之外，往往是通过将失 败的消息放入到延时队列中，等到一定的延时再进行重试来解决。
        2. 解决活锁的方案很简单，尝试等待一个随机的时间就可以，会按时间轮去重试 1. 饥饿 就是 线程因无法访问所需资源而无法执行下去的情况
    2. 饥饿：分为两种情况解决方案
        1. 一种是其他的线程在临界区做了无限循环或无限制等待资源的操作，让其他的 线程一直不能拿到锁进入临界区，对其他线程来说，就进入了饥饿状态
        2. 另一种是因为线程优先级不合理的分配，导致部分线程始终无法获取到 CPU 资 源而一直无法执行
        3. 保证资源充足，很多场景下，资源的稀缺性无法解决
        4. 公平分配资源，在并发编程里使用公平锁，例如 FIFO 策略，线程等待是有顺 序的，排在等待队列前面的线程会优先获得资源
        5. 避免持有锁的线程长时间执行，很多场景下，持有锁的线程的执行时间也很难 缩短
    3. 死锁：线程在对同一把锁进行竞争的时候，未抢占到锁的线程会等待持有锁的线程释放锁 后继续抢占，如果两个或两个以上的线程互相持有对方将要抢占的锁，互相等待对方先 行释放锁就会进入到一个循环等待的过程，这个过程就叫做死锁
2. 线程安全的竞态条件问题
    1. 同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件， 代码区成为临界区。 大多数并发错误一样，竞态条件不总是会产生问题，还需要不恰当 的执行时序
    2. 最常见的竞态条件为
        1. 先检测后执行执行依赖于检测的结果，而检测结果依赖于多个线程的执行时序，而 多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现各种 问题，见一种可能 的解决办法就是：在一个线程修改访问一个状态时，要防止其他 线程访问修改，也就是加锁机制，保证原子性
        2. 延迟初始化（典型为单例）
        ###

### Java 中的 wait 和 sleep 的区别与联系

-   区别：
    1. 所属类
       首先，这两个方法来自不同的类分别是 Thread 和 Object ，wait() 是 Object 的方法， sleep() 是 Thread 的方法 sleep() 针对的是线程，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了 sleep() 方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。但在 sleep() 的过程中过程中有可能被其他对象调用它的 interrupt()，产生 InterruptedException 异常，如果你的程序不捕获这个异常，线程就会异常终止，进入 TERMINATED 状态，如果你的程序捕获了这个异常，那么 程序就会继续执行 catch 语句块（可能还有 finally 语句块）以及以后的代码
    2. 作用范围：sleep() 没有释放锁，只是休眠，而 wait() 释放了锁，使得其他线程可以使用同步控制块或方法
    3. 使用范围：wait()、notify() 和 notifyAll() 只能在同步控制方法或者同步控制块里面使用，而 sleep() 可以在任何地方使用
    4. 异常范围：sleep() 必须捕获异常，而 wait()、notify() 和 notifyAll() 不需要捕获异常
-   联系：都阻塞，都可被中断唤醒

### 简述一下 ABA 问题

1. 有两个线程同时去修改一个变量的值，比如线程 1、线程 2，都更新变量值，将变量值从 A 更新成 B
2. 首先线程 1 获取到 CPU 的时间片，线程 2 由于某些原因发生阻塞进行等待，此时线程 1 进行比较更新（CompareAndSwap），成功将变量的值从 A 更新成 B
3. 更新完毕之后，恰好又有线程 3 进来想要把变量的值从 B 更新成 A，线程 3 进行比较更新，成功将变量的值从 B 更新成 A
4. 线程 2 获取到 CPU 的时间片，然后进行比较更新，发现值是预期的 A，然后有更新成了 B。但是线程 1 并不知道，该值已经有了 A->B->A 这个过程，这也就是我们常说的 ABA 问题
5. 可以通过加版本号或者加时间戳解决，或者保证单向递增或者递减就不会存在此类问题
6. CAS 的 ABA 问题，通过加版本号控制，只要有变更，就更新版本号

### 实现一下 DCL

```java
public class Singleton {
    //volatile是防止指令重排
    private static volatile Singleton singleton;
    private Singleton() {}
    public static Singleton getInstance() {
        //第一层判断singleton是不是为null
        //如果不为null直接返回，这样就不必加锁了
        if (singleton == null) {
            //现在再加锁
            synchronized (Singleton.class) {
                //第二层判断
                //如果A,B两个线程都在synchronized等待
                //A创建完对象之后，B还会再进入，如果不再检查一遍，B又会创建一个对象
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

### 实现一个阻塞队列（用 Condition 写生产者与消费者就）

```java
public class ProviderConsumer<T> {
    private int length;
    private Queue<T> queue;
    private ReentrantLock lock = new ReentrantLock();
    private Condition provideCondition = lock.newCondition();
    private Condition consumeCondition = lock.newCondition();

    public ProviderConsumer(int length){
        this.length = length;
        this.queue = new LinkedList<T>();
    }

    public void provide(T product){
        lock.lock();
        try {
            while (queue.size() >= length) {
                provideCondition.await();
            }
            queue.add(product);
            consumeCondition.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public T consume() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                consumeCondition.await();
            }
            T product = queue.remove();
            provideCondition.signal();
            return product;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return null;
    }
}
```

### 实现多个线程顺序打印 abc

```java
public class PrintABC {
    ReentrantLock lock = new ReentrantLock();
    Condition conditionA = lock.newCondition();
    Condition conditionB = lock.newCondition();
    Condition conditionC = lock.newCondition();
    volatile int value = 0;
    //打印多少遍
    private int count;
    public PrintABC (int count) {
        this.count = count;
    }

    public void printABC() {
        new Thread(new ThreadA()).start();
        new Thread(new ThreadB()).start();
        new Thread(new ThreadC()).start();
    }

    class ThreadA implements Runnable{
        @Override
        public void run() {
            lock.lock();
            try {
                for (int i = 0; i < count; i++) {
                    while (value % 3 != 0) {
                        conditionA.await();
                    }
                    System.out.print("A");
                    conditionB.signal();
                    value ++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    class ThreadB implements Runnable{
        @Override
        public void run() {
            lock.lock();
            try {
                for (int i = 0; i < count; i++) {
                    while (value % 3 != 1) {
                        conditionB.await();
                    }
                    System.out.print("B");
                    conditionC.signal();
                    value ++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
    class ThreadC implements Runnable{
        @Override
        public void run() {
            lock.lock();
            try {
                for (int i = 0; i < count; i++) {
                    while ( value % 3 != 2) {
                        conditionC.await();
                    }
                    System.out.println("C");
                    conditionA.signal();
                    value ++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        PrintABC printABC = new PrintABC(15);
        printABC.printABC();
    }
}
```

### 服务器 CPU 数量及线程池线程数量的关系 todo

### 多线程之间是如何通信的？

1. 通过共享变量，变量需要 volatile 修饰
2. 使用 wait() 和 notifyAll() 方法，但是由于需要使用同一把锁，所以必须通知线程释放锁，被通知线程才能获取到锁，这样导致通知不及时
3. 使用 CountDownLatch 实现，通知线程到指定条件，调用 countDownLatch.countDown()，被通知线程进行 countDownLatch.await()
4. 使用 Condition 的 await() 和 signalAll() 方法

## 线程相关

### 程序开多少线程合适

-   CPU 密集型程序
    一个完整请求，I/O 操作可以在很短时间内完成，CPU 还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分，线程等待时间接近 0
    -   单核：单核 CPU 处理 CPU 密集型程序，这种情况并不太适合使用多线程
    -   多核：多核 CPU 处理 CPU 密集型程序，完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率。最佳线程数就是：对于 CPU 密集型来说理论上线程数量 = CPU 核数（逻辑），但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1（经验值），CPU 密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下 CPU 周期不会中断工作
-   I/O 密集型程序
    与 CPU 密集型程序相对，一个完整请求，CPU 运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分，等待时间较长，线程等待时间所占比例越高，需要越多线程；线程 CPU 时间所占比例越高，需要越少线程
    -   最佳线程数 = CPU 核心数 (1/CPU 利用率) = CPU 核心数 (1 + (I/O 耗时/CPU 耗时))
    -   如果几乎全是 I/O 耗时，那么 CPU 耗时就无限趋近于 0，所以纯理论你就可以说是 2N（N=CPU 核数），当然也有说 2N + 1 的，1 应该是 backup
    -   一般来说 2N + 1 就即可

```java
// 获取 CPU 核心个数
Runtime.getRuntime().availableProcessors();
```

### 多线程的创建方式有哪些？ todo

-   1、继承 Thread 类，重写 run()方法

```java
public class Demo extends Thread {
    //重写父类Thread的run()
    public void run() {
    }
    public static void main(String[] args) {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        d1.start();
        d2.start();
    }
}
```

-   2.实现 Runnable 接口，重写 run()

```java
public class Demo2 implements Runnable{

    //重写Runnable接口的run()
    public void run() {
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new Demo2());
        Thread t2 = new Thread(new Demo2());
        t1.start();
        t2.start();
    }
}
```

-   3.实现 Callable 接口

```java
public class Demo implements Callable<String> {

    public String call() throws Exception {
        System.out.println("正在执行新建线程任务");
        Thread.sleep(2000);
        return "结果";
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        Demo d = new Demo();
        FutureTask<String> task = new FutureTask<>(d);
        Thread t = new Thread(task);
        t.start();
        //获取任务执行后返回的结果
        String result = task.get();
    }

}
```

-   4.使用线程池创建

```java
public class Demo {
    public static void main(String[] args) {
        Executor threadPool = Executors.newFixedThreadPool(5);
        for(int i = 0 ;i < 10 ; i++) {
            threadPool.execute(new Runnable() {
                public void run() {
                    //todo
                }
            });
        }
    }
}
```

### Runnable 和 Callable 的区别

-   Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已
-   Callable 接口中的 call() 方法是有返回值，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。Callable + Future / FutureTask 却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务

## 线程安全相关

### 怎么保证线程安全？

-   synchronized 关键字
    -   可以用于代码块，方法（静态方法，同步锁是当前字节码对象；实例方法，同步锁是实例对象）
-   lock 锁机制

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    System.out.println("获得锁");
} catch (Exception e) {

} finally {
    System.out.println("释放锁");
	lock.unlock();
}
```

## Volatile

### Volatile 的功能

-   保证线程可见性
-   防止指令重排序

### Volatile 的可见性和禁止指令重排序怎么实现的

-   可见性：被修饰的变量在被修改后可以立即同步到主内存，被修饰的变量在每次是用之前都从主内存刷新。本质也是通过内存屏障来实现可见性
    -   写内存屏障（Store Memory Barrier）可以促使处理器将当前 store buffer（存储缓存）的值写回主存
    -   读内存屏障（Load Memory Barrier）可以促使处理器处理 invalidate queue（失效队列）。进而避免由于 Store Buffer 和 Invalidate Queue 的非实时性带来的问题
-   禁止指令重排序： volatile 是通过内存屏障来禁止指令重排序，JMM 内存屏障的策略在每个 volatile 写操作的前面插入一个 Store Store 屏障。 在每个 volatile 写操作的后面插入一个 Store Load 屏障。 在每个 volatile 读操作的后面插入一个 Load Load 屏障。 在每个 volatile 读操作的后面插入一个 Load Store 屏障

### 可以创建 Volatile 数组吗

Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到保护作用

### volatile 能使得一个非原子操作变成原子操作吗？todo

一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。
一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是 64 位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。

# Java 多线程技术详解

## 目录

1. [基础概念](#基础概念)
2. [线程的创建与生命周期](#线程的创建与生命周期)
3. [线程安全与同步](#线程安全与同步)
4. [线程间通信](#线程间通信)
5. [Java 并发工具类](#java并发工具类)
6. [线程池与性能优化](#线程池与性能优化)
7. [高级主题](#高级主题)
8. [面试常见问题](#面试常见问题)
9. [实践案例](#实践案例)

## 基础概念

### 进程（Process）

进程是\*\*具有一定独立功能的## 线程安全与同步

### 什么是线程安全

**线程安全定义：** 如果代码在多线程环境下执行和在单线程环境下执行永远都能获得一样的结果，那么这个代码就是线程安全的。

### 线程安全级别

#### 1. 不可变（Immutable）

像`String`、`Integer`、`Long`等，都是 final 类型的类，任何线程都无法改变它们的值。要改变只能新创建对象。

```java
// String是不可变的，天然线程安全
String str1 = "hello";
String str2 = str1.concat(" world"); // 创建新对象，不修改原对象
```

#### 2. 绝对线程安全

不管运行环境如何，调用者都不需要额外的同步措施。Java 中很少有绝对线程安全的类，例如：

-   `CopyOnWriteArrayList`
-   `CopyOnWriteArraySet`

#### 3. 相对线程安全

通常意义上的线程安全，单个方法是原子的，但方法组合调用不保证原子性。

```java
// Vector的单个方法是线程安全的
Vector<String> vector = new Vector<>();
vector.add("hello"); // 线程安全

// 但组合操作不是原子的
if (!vector.isEmpty()) {
    vector.remove(0); // 可能抛出异常，因为其他线程可能已经清空了vector
}
```

#### 4. 线程不安全

`ArrayList`、`LinkedList`、`HashMap`等都是线程不安全的类。

### 常见线程安全类与非安全类

| 线程安全                        | 线程不安全      | 备注         |
| ------------------------------- | --------------- | ------------ |
| `Vector`                        | `ArrayList`     | 动态数组     |
| `Hashtable`                     | `HashMap`       | 哈希表       |
| `ConcurrentHashMap`             | `HashMap`       | 高性能哈希表 |
| `StringBuffer`                  | `StringBuilder` | 字符串缓冲区 |
| `Collections.synchronizedXxx()` | 原始集合类      | 同步包装器   |

### 同步机制

#### synchronized 关键字

**1. 同步方法**

```java
public class Counter {
    private int count = 0;

    // 实例方法同步，锁是this对象
    public synchronized void increment() {
        count++;
    }

    // 静态方法同步，锁是Class对象
    public static synchronized void staticMethod() {
        // 静态方法的同步逻辑
    }
}
```

**2. 同步代码块**

```java
public class Counter {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) { // 使用自定义锁对象
            count++;
        }
    }

    public void decrement() {
        synchronized (this) { // 使用this作为锁
            count--;
        }
    }
}
```

#### Lock 接口

```java
import java.util.concurrent.locks.ReentrantLock;

public class LockExample {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock(); // 必须在finally块中释放锁
        }
    }

    // 尝试获取锁
    public boolean tryIncrement() {
        if (lock.tryLock()) {
            try {
                count++;
                return true;
            } finally {
                lock.unlock();
            }
        }
        return false;
    }
}
```

### synchronized vs Lock

| 特征           | synchronized            | Lock                       |
| -------------- | ----------------------- | -------------------------- | ------------------------------------------------------------------------------ |
| **获取锁**     | 自动获取和释放          | 手动获取和释放             |
| **异常处理**   | 自动释放锁              | 需要在 finally 中释放      |
| **尝试获取锁** | 不支持                  | 支持 tryLock()             |
| **超时获取锁** | 不支持                  | 支持 tryLock(time, unit)   |
| **可中断性**   | 不可中断                | 可中断 lockInterruptibly() |
| **公平性**     | 非公平                  | 可选择公平或非公平         |
| **条件变量**   | 只有一个（wait/notify） | 可以有多个 Condition       |
| **性能**       | JVM 优化，性能好        | 功能丰富，适合复杂场景     | 关于某个数据集合上的一次运行活动，是**操作系统进行资源分配和调度的独立单位**。 |

**特点：**

-   独立的内存空间
-   系统资源分配的基本单位
-   进程间通信需要特殊机制（IPC）
-   创建和切换开销较大

### 线程（Thread）

线程是**进程的一个实体**，是**CPU 调度和分派的基本单位**，是比进程更小的能独立运行的基本单位。

**特点：**

-   共享进程的内存空间
-   程序执行的最小单位
-   线程间通信方便（共享内存）
-   创建和切换开销较小

### 进程与线程的区别

| 特征         | 进程                               | 线程                           |
| ------------ | ---------------------------------- | ------------------------------ |
| **资源分配** | 系统资源分配的基本单位             | 不拥有资源，只是使用进程的资源 |
| **调度单位** | 可以独立调度                       | CPU 调度的基本单位             |
| **内存空间** | 拥有独立的虚拟地址空间             | 共享进程的地址空间             |
| **通信机制** | 需要进程间通信（管道、消息队列等） | 可以直接读写进程数据段进行通信 |
| **创建开销** | 创建新进程开销大                   | 创建新线程开销小               |
| **影响范围** | 一个进程崩溃不会影响其他进程       | 一个线程崩溃可能影响整个进程   |

### 多线程编程的优势与挑战

**优势：**

-   提高程序的并发性和响应性
-   充分利用多核 CPU 资源
-   改善用户体验（UI 不卡顿）
-   提高系统吞吐量

**挑战：**

-   线程安全问题
-   死锁风险
-   调试困难
-   性能调优复杂

## 线程的创建与生命周期

### 多线程创建方式

#### 1. 继承 Thread 类

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("线程执行：" + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        t1.start(); // 注意使用start()而不是run()
        t2.start();
    }
}
```

#### 2. 实现 Runnable 接口

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("线程执行：" + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new MyRunnable());
        Thread t2 = new Thread(new MyRunnable());
        t1.start();
        t2.start();
    }
}
```

#### 3. 实现 Callable 接口

```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println("正在执行任务：" + Thread.currentThread().getName());
        Thread.sleep(2000);
        return "任务完成，返回结果";
    }

    public static void main(String[] args) throws Exception {
        MyCallable callable = new MyCallable();
        FutureTask<String> task = new FutureTask<>(callable);
        Thread t = new Thread(task);
        t.start();

        // 获取任务执行结果
        String result = task.get(); // 会阻塞直到任务完成
        System.out.println("结果：" + result);
    }
}
```

#### 4. 使用线程池创建

```java
public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService threadPool = Executors.newFixedThreadPool(5);

        for (int i = 0; i < 10; i++) {
            final int taskId = i;
            threadPool.execute(() -> {
                System.out.println("执行任务：" + taskId + "，线程：" + Thread.currentThread().getName());
            });
        }

        threadPool.shutdown(); // 关闭线程池
    }
}
```

### Runnable vs Callable

| 特征         | Runnable         | Callable             |
| ------------ | ---------------- | -------------------- |
| **方法名**   | run()            | call()               |
| **返回值**   | void             | 泛型 T               |
| **异常处理** | 无法抛出检查异常 | 可以抛出 Exception   |
| **配合使用** | Thread           | Future/FutureTask    |
| **获取结果** | 无法直接获取     | 可以通过 Future 获取 |

### start() vs run() 方法

**start()方法：**

-   启动新线程，使线程进入就绪状态
-   由 JVM 调用 run()方法
-   只能调用一次，重复调用会抛出 IllegalThreadStateException

**run()方法：**

-   线程的执行体，包含线程要执行的代码
-   直接调用 run()只是普通方法调用，不会创建新线程
-   在当前线程中执行

```java
public class StartVsRun {
    public static void main(String[] args) {
        Thread t = new Thread(() -> {
            System.out.println("当前线程：" + Thread.currentThread().getName());
        });

        t.run();   // 输出：当前线程：main
        t.start(); // 输出：当前线程：Thread-0
    }
}
```

### Java 线程生命周期

#### 线程状态详解

根据 JDK 源码，Thread 的状态分为 6 种：

```java
public enum State {
    NEW,           // 新建
    RUNNABLE,      // 可运行
    BLOCKED,       // 阻塞
    WAITING,       // 等待
    TIMED_WAITING, // 定时等待
    TERMINATED     // 终止
}
```

#### 状态转换图

```
NEW → RUNNABLE → BLOCKED → RUNNABLE → TERMINATED
 ↓       ↓                              ↑
 ↓    WAITING ↔ RUNNABLE                ↑
 ↓       ↓                              ↑
 ↓    TIMED_WAITING ↔ RUNNABLE          ↑
 ↓                                      ↑
 └─────────── TERMINATED ───────────────┘
```

#### 各状态详细说明

**1. NEW（新建状态）**

-   线程对象已创建，但尚未调用 start()方法
-   此时线程不会被 CPU 调度

**2. RUNNABLE（可运行状态）**

-   包含两个子状态：READY（就绪）和 RUNNING（运行）
-   READY：等待 CPU 分配时间片
-   RUNNING：正在 CPU 上执行

**3. BLOCKED（阻塞状态）**

-   等待监视器锁（synchronized）
-   尝试获取锁时被阻塞

**4. WAITING（等待状态）**

-   无限期等待，直到被其他线程唤醒
-   触发条件：
    -   Object.wait()（无超时）
    -   Thread.join()（无超时）
    -   LockSupport.park()

**5. TIMED_WAITING（定时等待状态）**

-   等待指定时间后自动返回
-   触发条件：
    -   Thread.sleep(long)
    -   Object.wait(long)
    -   Thread.join(long)
    -   LockSupport.parkNanos()
    -   LockSupport.parkUntil()

**6. TERMINATED（终止状态）**

-   线程执行完毕或异常退出
-   无法再次启动

#### 状态检测示例

```java
public class ThreadStateDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -> {
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });

        System.out.println("创建后：" + t.getState()); // NEW

        t.start();
        System.out.println("启动后：" + t.getState()); // RUNNABLE

        Thread.sleep(100);
        System.out.println("睡眠中：" + t.getState()); // TIMED_WAITING

        t.join(); // 等待线程结束
        System.out.println("结束后：" + t.getState()); // TERMINATED
    }
}
```

### 什么是线程饥饿、线程饿死

所谓线程饥饿（Starvation）：指的是在多线程的资源竞争中，存在贪婪的线程一直锁定资源不释放，其他的线程则始终处于等待状态，然而这个等待是没有结果的，它们会被活活地饿死。 当获得锁的线程需要执行无限时间长的操作时（比如 IO 或者无限循环），那么后面的线程将会被无限阻塞，导致被饿死。

### 什么是活锁

活锁：指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试、失败、尝试、失败。活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。活锁可以认为是一种特殊的饥饿。

## 线程间通信

### 基本概念

**同步与异步：**

-   **同步：** 程序按顺序依次执行，每个操作必须等待上一个操作完成后才能执行，会阻塞当前线程
-   **异步：** 程序执行时不需要等待上一个操作完成，可以继续执行后续操作，不会阻塞当前线程

### wait()和 notify()机制

#### 基本用法

```java
public class WaitNotifyExample {
    private final Object lock = new Object();
    private boolean condition = false;

    public void waitingMethod() throws InterruptedException {
        synchronized (lock) {
            while (!condition) { // 使用while而不是if
                lock.wait(); // 释放锁并等待
            }
            // 条件满足，继续执行
            System.out.println("条件满足，继续执行");
        }
    }

    public void notifyingMethod() {
        synchronized (lock) {
            condition = true;
            lock.notify(); // 唤醒一个等待的线程
            // lock.notifyAll(); // 唤醒所有等待的线程
        }
    }
}
```

#### 为什么要在 while 循环中使用 wait()？

```java
// 错误的做法
if (!condition) {
    lock.wait(); // 如果被虚假唤醒，条件可能仍然不满足
}

// 正确的做法
while (!condition) {
    lock.wait(); // 即使被虚假唤醒，也会重新检查条件
}
```

#### notify() vs notifyAll()

-   **notify()：** 随机唤醒一个等待线程，可能导致线程饥饿
-   **notifyAll()：** 唤醒所有等待线程，让它们竞争锁，更安全但开销更大

### sleep() vs wait() vs yield()

| 方法        | 所属类 | 锁的处理 | 用途               | 唤醒方式                     |
| ----------- | ------ | -------- | ------------------ | ---------------------------- |
| **sleep()** | Thread | 不释放锁 | 让线程休眠指定时间 | 时间到期或被中断             |
| **wait()**  | Object | 释放锁   | 等待条件满足       | notify()/notifyAll()或被中断 |
| **yield()** | Thread | 不释放锁 | 让出 CPU 时间片    | 重新竞争 CPU                 |

```java
public class SleepWaitYieldDemo {
    private final Object lock = new Object();

    public void sleepExample() throws InterruptedException {
        synchronized (lock) {
            System.out.println("开始睡眠，不释放锁");
            Thread.sleep(1000); // 持有锁的情况下睡眠
            System.out.println("睡眠结束");
        }
    }

    public void waitExample() throws InterruptedException {
        synchronized (lock) {
            System.out.println("开始等待，释放锁");
            lock.wait(); // 释放锁并等待
            System.out.println("等待结束");
        }
    }

    public void yieldExample() {
        for (int i = 0; i < 10; i++) {
            System.out.println("执行任务：" + i);
            Thread.yield(); // 建议让出CPU
        }
    }
}
```

### join()方法

等待其他线程执行完毕：

```java
public class JoinExample {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("T1: " + i);
                try { Thread.sleep(100); } catch (InterruptedException e) {}
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("T2: " + i);
                try { Thread.sleep(100); } catch (InterruptedException e) {}
            }
        });

        t1.start();
        t2.start();

        t1.join(); // 等待t1执行完毕
        t2.join(); // 等待t2执行完毕

        System.out.println("所有线程执行完毕");
    }
}
```

### 阻塞原因及解决方法

| 阻塞原因         | 描述             | 解决方法               |
| ---------------- | ---------------- | ---------------------- |
| **sleep()**      | 线程休眠指定时间 | 时间到期或 interrupt() |
| **wait()**       | 等待条件满足     | notify()/notifyAll()   |
| **join()**       | 等待其他线程结束 | 目标线程执行完毕       |
| **synchronized** | 等待获取锁       | 锁被释放               |
| **I/O 操作**     | 等待 I/O 完成    | I/O 操作完成           |

### 线程通信的几种方式

1. **共享变量（需要 volatile 修饰）**

```java
public class SharedVariableExample {
    private volatile boolean flag = false;

    public void writer() {
        flag = true; // 写线程
    }

    public void reader() {
        while (!flag) { // 读线程
            // 等待flag变为true
        }
        System.out.println("Flag is true!");
    }
}
```

2. **wait/notify 机制**
3. **CountDownLatch**
4. **Condition 接口**
5. **BlockingQueue**

这些高级工具将在后续章节详细介绍。

## Java 并发工具类

### volatile 关键字

#### 功能特性

1. **保证可见性：** 被 volatile 修饰的变量在被修改后立即同步到主内存，读取时从主内存刷新
2. **防止指令重排序：** 通过内存屏障防止编译器和 CPU 的指令重排序优化

#### 实现原理

```java
public class VolatileExample {
    private volatile boolean flag = false;
    private int count = 0;

    public void writer() {
        count = 100;      // 1
        flag = true;      // 2 volatile写
    }

    public void reader() {
        if (flag) {       // 3 volatile读
            int i = count; // 4 保证能看到count=100
        }
    }
}
```

**内存屏障策略：**

-   volatile 写前插入 StoreStore 屏障
-   volatile 写后插入 StoreLoad 屏障
-   volatile 读后插入 LoadLoad 屏障
-   volatile 读后插入 LoadStore 屏障

#### volatile 的局限性

```java
public class VolatileLimitation {
    private volatile int count = 0;

    // 这个方法不是线程安全的！
    public void increment() {
        count++; // 包含读取、计算、写入三个操作，不是原子的
    }

    // 正确的做法：使用synchronized或AtomicInteger
    public synchronized void safeIncrement() {
        count++;
    }
}
```

### 原子类（Atomic Classes）

#### 基本原子类型

```java
import java.util.concurrent.atomic.*;

public class AtomicExample {
    private AtomicInteger count = new AtomicInteger(0);
    private AtomicBoolean flag = new AtomicBoolean(false);
    private AtomicReference<String> ref = new AtomicReference<>("initial");

    public void atomicOperations() {
        // 原子递增
        int newValue = count.incrementAndGet();

        // CAS操作
        boolean success = count.compareAndSet(10, 20);

        // 原子更新
        int oldValue = count.getAndSet(100);

        // 引用类型的原子操作
        String oldRef = ref.getAndSet("new value");
    }
}
```

#### 什么是 CAS

**CAS（Compare And Swap）** 是一种无锁的原子操作：

-   **比较：** 比较内存值 V 与预期值 A
-   **交换：** 如果相等，将内存值更新为新值 B
-   **返回：** 返回操作是否成功

```java
public class CASExample {
    private AtomicInteger value = new AtomicInteger(0);

    public boolean increment() {
        int current;
        int next;
        do {
            current = value.get();    // 获取当前值
            next = current + 1;       // 计算新值
        } while (!value.compareAndSet(current, next)); // CAS操作
        return true;
    }
}
```

#### ABA 问题及解决方案

```java
// ABA问题演示
public class ABADemo {
    private AtomicInteger value = new AtomicInteger(1);

    // 线程1: A->B
    // 线程2: B->A
    // 线程3: 看到的还是A，但实际已经变化过了
}

// 解决方案：使用版本号
public class ABAProblermSolution {
    private AtomicStampedReference<Integer> value =
        new AtomicStampedReference<>(1, 0);

    public boolean updateValue(int expectedValue, int newValue) {
        int[] stamp = new int[1];
        int currentValue = value.get(stamp);

        return value.compareAndSet(
            expectedValue, newValue,
            stamp[0], stamp[0] + 1  // 版本号+1
        );
    }
}
```

### CountDownLatch

用于等待多个线程完成某个操作：

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    private static final int THREAD_COUNT = 3;

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);

        for (int i = 0; i < THREAD_COUNT; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    System.out.println("任务" + taskId + "开始执行");
                    Thread.sleep(1000); // 模拟任务执行
                    System.out.println("任务" + taskId + "执行完成");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    latch.countDown(); // 完成一个任务，计数器-1
                }
            }).start();
        }

        latch.await(); // 等待所有任务完成
        System.out.println("所有任务完成，主线程继续执行");
    }
}
```

### CyclicBarrier

让多个线程在屏障处等待，所有线程都到达后一起继续：

```java
import java.util.concurrent.CyclicBarrier;

public class CyclicBarrierExample {
    private static final int THREAD_COUNT = 3;

    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT, () -> {
            System.out.println("所有线程都到达屏障，开始执行后续任务");
        });

        for (int i = 0; i < THREAD_COUNT; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    System.out.println("线程" + taskId + "开始执行");
                    Thread.sleep(1000 + taskId * 1000); // 模拟不同执行时间
                    System.out.println("线程" + taskId + "到达屏障");

                    barrier.await(); // 等待其他线程

                    System.out.println("线程" + taskId + "继续执行");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

### Semaphore

控制同时访问某个资源的线程数量：

```java
import java.util.concurrent.Semaphore;

public class SemaphoreExample {
    private static final Semaphore semaphore = new Semaphore(2); // 允许2个线程同时访问

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    semaphore.acquire(); // 获取许可
                    System.out.println("线程" + taskId + "获得许可，开始执行");
                    Thread.sleep(2000); // 模拟任务执行
                    System.out.println("线程" + taskId + "执行完成，释放许可");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    semaphore.release(); // 释放许可
                }
            }).start();
        }
    }
}
```

### ConcurrentHashMap

#### JDK 1.7 vs JDK 1.8

**JDK 1.7：** 使用 Segment 分段锁

-   默认 16 个 Segment，并发度为 16
-   每个 Segment 内部是 HashEntry 数组
-   锁的是整个 Segment

**JDK 1.8：** 使用 CAS + synchronized

-   锁的粒度更细，锁的是单个桶的头节点
-   使用红黑树优化长链表
-   性能更好，并发度理论上无限制

```java
// JDK 1.8 ConcurrentHashMap 关键源码结构
public class ConcurrentHashMap<K,V> {
    // 使用CAS操作
    static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,
                                       Node<K,V> c, Node<K,V> v) {
        return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);
    }

    // put操作的简化逻辑
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        for (Node<K,V>[] tab = table;;) {
            if (tab == null || (n = tab.length) == 0) {
                tab = initTable(); // 初始化表
            } else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                    break; // CAS成功，结束循环
            } else {
                synchronized (f) { // 锁住头节点
                    // 链表或红黑树操作
                }
            }
        }
    }
}
```

## Lock

## Future

### FutureTask 是什么

FutureTask 表示一个异步运算的任务。FutureTask 里面可以传入一个 Callable 的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于 FutureTask 也是 Runnable 接口的实现类，所以 FutureTask 也可以放入线程池中。

## 虚拟线程

### 如何在两个线程间共享数据

可以通过在线程之间共享对象，然后通过 wait/notify/notifyAll、await/signal/signalAll 进行唤起和等待，比如阻塞队列 BlockingQueue 就是为线程之间共享数据而设计的

### Java 中用到的线程调度算法是什么

抢占式，一个线程用完 CPU 之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行

### Thread.sleep(0)的作用是什么

由于 Java 采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到 CPU 控制权的情况，为了让某些优先级比较低的线程也能获取到 CPU 控制权，可以使用 Thread.sleep(0) 手动触发一次操作系统分配时间片的操作，这也是平衡 CPU 控制权的一种操作

### 什么是 CAS

CAS，全称为 Compare and Swap，即比较-替换。假设有三个操作数：内存值 V、旧的预期值 A、要修改的值 B，当且仅当预期值 A 和内存值 V 相同时，才会将内存值修改为 B 并返回 true，否则什么都不做并返回 false。当然 CAS 一定要 volatile 变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值 A 对某条线程来说，永远是一个不会变的值 A，只要某次 CAS 操作失败，永远都不可能成功

### ConcurrentHashMap 的并发度是什么？

ConcurrentHashMap 的并发度就是 segment 的大小，默认为 16，这意味着最多同时可以有 16 条线程操作 ConcurrentHashMap，这也是 ConcurrentHashMap 对 Hashtable 的最大优势

### 任何情况下，Hashtable 能同时有两条线程获取 Hashtable 中的数据吗？ todo

### ConcurrentHashMap 的工作原理

ConcurrentHashMap 在 jdk 1.6 和 jdk 1.8 实现原理是不同的

-   jdk 1.6：ConcurrentHashMap 是线程安全的，但是与 Hashtable 相比，实现线程安全的方式不同。Hashtable 是通过对 hash 表结构进行锁定，是阻塞式的，当一个线程占有这个锁时，其他线程必须阻塞等待其释放锁。ConcurrentHashMap 是采用分离锁的方式，它并没有对整个 hash 表进行锁定，而是局部锁定，也就是说当一个线程占有这个局部锁时，不影响其他线程对 hash 表其他地方的访问。具体实现: ConcurrentHashMap 内部有一个 Segment
-   jdk 1.8：在 jdk 8 中，ConcurrentHashMap 不再使用 Segment 分离锁，而是采用一种乐观锁 CAS 算法来实现同步问题，但其底层还是“数组 + 链表 -> 红黑树”的实现

### java 中的++操作符线程安全么

不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差

## 线程池与性能优化

### 线程数量配置

#### CPU 密集型任务

**特点：** 主要进行计算操作，I/O 操作很少
**推荐线程数：** CPU 核心数 + 1

```java
// 获取CPU核心数
int coreCount = Runtime.getRuntime().availableProcessors();
int threadCount = coreCount + 1;
```

#### I/O 密集型任务

**特点：** 大量 I/O 操作（网络、磁盘等），CPU 计算较少
**推荐线程数：** CPU 核心数 × 2 或 CPU 核心数 ÷ (1 - 阻塞系数)

```java
// 阻塞系数 = 阻塞时间 / (阻塞时间 + 计算时间)
// 如果阻塞系数为0.8，则线程数 = 核心数 ÷ (1 - 0.8) = 核心数 × 5
int threadCount = coreCount * 2; // 简化计算
```

### 线程池创建方式

#### 1. Executors 工厂方法（不推荐）

```java
// 固定大小线程池
ExecutorService fixedPool = Executors.newFixedThreadPool(5);

// 缓存线程池（危险：可能创建过多线程）
ExecutorService cachedPool = Executors.newCachedThreadPool();

// 单线程池
ExecutorService singlePool = Executors.newSingleThreadExecutor();

// 定时任务线程池
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(2);
```

#### 2. ThreadPoolExecutor（推荐）

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    5,                      // corePoolSize: 核心线程数
    10,                     // maximumPoolSize: 最大线程数
    60L,                    // keepAliveTime: 空闲线程存活时间
    TimeUnit.SECONDS,       // timeUnit: 时间单位
    new LinkedBlockingQueue<>(100), // workQueue: 工作队列
    new ThreadPoolExecutor.DefaultThreadFactory(), // threadFactory: 线程工厂
    new ThreadPoolExecutor.AbortPolicy()  // handler: 拒绝策略
);
```

### 线程池参数详解

#### 核心参数

-   **corePoolSize：** 核心线程数，会一直存活
-   **maximumPoolSize：** 最大线程数，包括核心线程和非核心线程
-   **keepAliveTime：** 非核心线程空闲存活时间
-   **workQueue：** 任务队列，存放待执行的任务
-   **threadFactory：** 线程工厂，用于创建线程
-   **handler：** 拒绝策略，当线程池和队列都满时的处理策略

#### 任务执行流程

```
1. 提交任务
   ↓
2. 核心线程数未满？ → 是 → 创建核心线程执行
   ↓ 否
3. 队列未满？ → 是 → 加入队列等待
   ↓ 否
4. 最大线程数未满？ → 是 → 创建非核心线程执行
   ↓ 否
5. 执行拒绝策略
```

### 拒绝策略

```java
// 1. AbortPolicy（默认）：抛出RejectedExecutionException
new ThreadPoolExecutor.AbortPolicy()

// 2. CallerRunsPolicy：调用者线程执行任务
new ThreadPoolExecutor.CallerRunsPolicy()

// 3. DiscardPolicy：静默丢弃任务
new ThreadPoolExecutor.DiscardPolicy()

// 4. DiscardOldestPolicy：丢弃队列中最旧的任务
new ThreadPoolExecutor.DiscardOldestPolicy()

// 5. 自定义拒绝策略
new RejectedExecutionHandler() {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 记录日志、降级处理等
        System.out.println("任务被拒绝：" + r.toString());
    }
}
```

### 队列类型选择

```java
// 1. ArrayBlockingQueue：有界队列，基于数组
new ArrayBlockingQueue<>(100)

// 2. LinkedBlockingQueue：可选有界队列，基于链表
new LinkedBlockingQueue<>(100) // 有界
new LinkedBlockingQueue<>()    // 无界（Integer.MAX_VALUE）

// 3. SynchronousQueue：同步队列，不存储元素
new SynchronousQueue<>()

// 4. PriorityBlockingQueue：优先级队列
new PriorityBlockingQueue<>()

// 5. DelayQueue：延时队列
new DelayQueue<>()
```

### 线程池监控

```java
public class ThreadPoolMonitor {
    private ThreadPoolExecutor executor;

    public ThreadPoolMonitor(ThreadPoolExecutor executor) {
        this.executor = executor;
    }

    public void printStats() {
        System.out.println("=== 线程池状态 ===");
        System.out.println("核心线程数: " + executor.getCorePoolSize());
        System.out.println("最大线程数: " + executor.getMaximumPoolSize());
        System.out.println("当前线程数: " + executor.getPoolSize());
        System.out.println("活跃线程数: " + executor.getActiveCount());
        System.out.println("任务总数: " + executor.getTaskCount());
        System.out.println("已完成任务数: " + executor.getCompletedTaskCount());
        System.out.println("队列大小: " + executor.getQueue().size());
        System.out.println("队列剩余容量: " + executor.getQueue().remainingCapacity());
    }
}
```

### Future 和 FutureTask

```java
public class FutureExample {
    private ExecutorService executor = Executors.newFixedThreadPool(3);

    public void futureDemo() throws Exception {
        // 1. 使用Callable提交任务
        Future<String> future = executor.submit(() -> {
            Thread.sleep(2000);
            return "任务完成";
        });

        // 2. 检查任务状态
        System.out.println("任务是否完成：" + future.isDone());
        System.out.println("任务是否取消：" + future.isCancelled());

        // 3. 获取结果（阻塞）
        String result = future.get(); // 无限等待
        // String result = future.get(3, TimeUnit.SECONDS); // 限时等待

        // 4. 取消任务
        // boolean cancelled = future.cancel(true); // true表示中断正在执行的任务

        System.out.println("结果：" + result);
    }

    public void futureTaskDemo() {
        // FutureTask既是Future也是Runnable
        FutureTask<Integer> task = new FutureTask<>(() -> {
            int sum = 0;
            for (int i = 1; i <= 100; i++) {
                sum += i;
            }
            return sum;
        });

        // 可以直接用Thread执行
        new Thread(task).start();

        try {
            Integer result = task.get();
            System.out.println("计算结果：" + result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 高级主题

### 线程安全的活跃性问题

#### 1. 死锁（Deadlock）

**定义：** 多个线程互相持有对方需要的锁，形成循环等待

```java
public class DeadlockExample {
    private static Object lock1 = new Object();
    private static Object lock2 = new Object();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (lock1) {
                System.out.println("Thread1 获得 lock1");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (lock2) { // 等待lock2
                    System.out.println("Thread1 获得 lock2");
                }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (lock2) {
                System.out.println("Thread2 获得 lock2");
                try { Thread.sleep(100); } catch (InterruptedException e) {}
                synchronized (lock1) { // 等待lock1
                    System.out.println("Thread2 获得 lock1");
                }
            }
        });

        t1.start();
        t2.start();
    }
}
```

**死锁产生的四个必要条件：**

1. **互斥条件：** 资源不能被多个线程同时使用
2. **占有且等待：** 线程已获得一些资源，同时等待其他资源
3. **不可抢占：** 资源不能被强制从线程中抢夺
4. **循环等待：** 存在线程等待环路

**死锁预防与解决：**

```java
// 1. 避免嵌套锁
// 2. 避免无限等待
// 3. 按顺序获取锁
public class DeadlockPrevention {
    private static Object lock1 = new Object();
    private static Object lock2 = new Object();

    // 按照固定顺序获取锁
    public void method1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // 业务逻辑
            }
        }
    }

    public void method2() {
        synchronized (lock1) { // 同样先获取lock1
            synchronized (lock2) {
                // 业务逻辑
            }
        }
    }
}
```

#### 2. 活锁（Livelock）

**定义：** 线程没有被阻塞，但由于某些条件没有满足，一直重复尝试、失败

```java
public class LivelockExample {
    static class Spoon {
        private Diner owner;

        public synchronized void use() {
            System.out.printf("%s 正在用餐\n", owner.name);
        }

        public synchronized void setOwner(Diner diner) { this.owner = diner; }
        public synchronized Diner getOwner() { return owner; }
    }

    static class Diner {
        private String name;
        private boolean isHungry;

        public Diner(String name) {
            this.name = name;
            this.isHungry = true;
        }

        public void eatWith(Spoon spoon, Diner spouse) {
            while (isHungry) {
                if (spoon.getOwner() != this) {
                    try { Thread.sleep(1); } catch (InterruptedException e) {}
                    continue;
                }

                if (spouse.isHungry) {
                    System.out.printf("%s: 你先吃吧\n", name);
                    spoon.setOwner(spouse);
                    continue; // 活锁：一直谦让
                }

                spoon.use();
                isHungry = false;
                spoon.setOwner(spouse);
            }
        }
    }
}
```

**解决活锁：** 引入随机性，避免同步的重试模式

#### 3. 饥饿（Starvation）

**定义：** 线程因无法访问所需资源而无法执行

```java
public class StarvationExample {
    private final Object lock = new Object();

    // 高优先级任务
    public void highPriorityTask() {
        Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
        while (true) {
            synchronized (lock) {
                // 持续占用锁，导致低优先级线程饥饿
                try { Thread.sleep(1); } catch (InterruptedException e) {}
            }
        }
    }

    // 低优先级任务（可能饥饿）
    public void lowPriorityTask() {
        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);
        synchronized (lock) {
            System.out.println("低优先级任务执行"); // 可能永远执行不到
        }
    }
}
```

**解决饥饿：** 使用公平锁

```java
ReentrantLock fairLock = new ReentrantLock(true); // 公平锁
```

### 竞态条件（Race Condition）

**定义：** 多个线程访问共享资源时，执行结果依赖于执行时序

```java
public class RaceConditionExample {
    private int count = 0;

    // 竞态条件：count++不是原子操作
    public void increment() {
        count++; // 读取 -> 计算 -> 写入
    }

    // 解决方案1：synchronized
    public synchronized void safeIncrement1() {
        count++;
    }

    // 解决方案2：AtomicInteger
    private AtomicInteger atomicCount = new AtomicInteger(0);
    public void safeIncrement2() {
        atomicCount.incrementAndGet();
    }

    // 解决方案3：Lock
    private final ReentrantLock lock = new ReentrantLock();
    public void safeIncrement3() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }
}
```

### 线程调度与上下文切换

#### 线程调度算法

Java 使用**抢占式调度算法**：

-   操作系统根据线程优先级、饥饿情况等分配 CPU 时间片
-   高优先级线程可以抢占低优先级线程的 CPU
-   同优先级线程采用时间片轮转

#### 上下文切换

**定义：** CPU 控制权从一个线程切换到另一个线程的过程

**开销包括：**

-   保存当前线程状态（寄存器、程序计数器等）
-   恢复目标线程状态
-   更新内存管理信息

**减少上下文切换的方法：**

```java
// 1. 减少线程数量，使用线程池
// 2. 使用协程（Kotlin、Go语言的概念）
// 3. 使用无锁并发编程
// 4. 使用最少线程：避免创建不必要的线程
```

### 最佳实践

#### 多线程开发原则

1. **给线程命名：** 便于调试和监控

```java
Thread thread = new Thread(() -> {
    // 任务逻辑
}, "MyTask-Thread");

// 或者使用ThreadFactory
ThreadFactory factory = new ThreadFactoryBuilder()
    .setNameFormat("MyPool-%d")
    .setDaemon(true)
    .build();
```

2. **最小化同步范围：** 只对关键部分加锁

```java
public void badExample() {
    synchronized (this) { // 锁定范围过大
        doNonCriticalWork();
        doCriticalWork();
        doMoreNonCriticalWork();
    }
}

public void goodExample() {
    doNonCriticalWork();
    synchronized (this) { // 只锁定关键部分
        doCriticalWork();
    }
    doMoreNonCriticalWork();
}
```

3. **优先使用高级工具：**

    - 优先使用`java.util.concurrent`包的工具
    - 优先使用线程池而不是直接创建线程
    - 优先使用并发容器而不是同步容器

4. **异常处理：**

```java
Thread thread = new Thread(() -> {
    try {
        // 任务逻辑
    } catch (Exception e) {
        // 记录日志，不要让异常终止线程
        log.error("线程执行异常", e);
    }
});

// 设置未捕获异常处理器
thread.setUncaughtExceptionHandler((t, e) -> {
    log.error("线程 {} 发生未捕获异常", t.getName(), e);
});
```

### Thread.sleep(0)的作用

触发操作系统重新进行线程调度，让其他线程有机会获得 CPU 时间片：

```java
public void cpuIntensiveTask() {
    for (int i = 0; i < 1000000; i++) {
        // CPU密集型操作
        doComputation();

        if (i % 1000 == 0) {
            Thread.sleep(0); // 让出CPU，允许其他线程执行
        }
    }
}
```

### 实现一下 DCL

```java
public class Singleton {
    //volatile是防止指令重排
    private static volatile Singleton singleton;
    private Singleton() {}
    public static Singleton getInstance() {
        //第一层判断singleton是不是为null
        //如果不为null直接返回，这样就不必加锁了
        if (singleton == null) {
            //现在再加锁
            synchronized (Singleton.class) {
                //第二层判断
                //如果A,B两个线程都在synchronized等待
                //A创建完对象之后，B还会再进入，如果不再检查一遍，B又会创建一个对象
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

### 实现一个阻塞队列（用 Condition 写生产者与消费者就）

```java
public class ProviderConsumer<T> {
    private int length;
    private Queue<T> queue;
    private ReentrantLock lock = new ReentrantLock();
    private Condition provideCondition = lock.newCondition();
    private Condition consumeCondition = lock.newCondition();

    public ProviderConsumer(int length){
        this.length = length;
        this.queue = new LinkedList<T>();
    }

    public void provide(T product){
        lock.lock();
        try {
            while (queue.size() >= length) {
                provideCondition.await();
            }
            queue.add(product);
            consumeCondition.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    public T consume() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                consumeCondition.await();
            }
            T product = queue.remove();
            provideCondition.signal();
            return product;
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        return null;
    }
}
```

### 实现多个线程顺序打印 abc

```java
public class PrintABC {
    ReentrantLock lock = new ReentrantLock();
    Condition conditionA = lock.newCondition();
    Condition conditionB = lock.newCondition();
    Condition conditionC = lock.newCondition();
    volatile int value = 0;
    //打印多少遍
    private int count;
    public PrintABC (int count) {
        this.count = count;
    }

    public void printABC() {
        new Thread(new ThreadA()).start();
        new Thread(new ThreadB()).start();
        new Thread(new ThreadC()).start();
    }

    class ThreadA implements Runnable{
        @Override
        public void run() {
            lock.lock();
            try {
                for (int i = 0; i < count; i++) {
                    while (value % 3 != 0) {
                        conditionA.await();
                    }
                    System.out.print("A");
                    conditionB.signal();
                    value ++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    class ThreadB implements Runnable{
        @Override
        public void run() {
            lock.lock();
            try {
                for (int i = 0; i < count; i++) {
                    while (value % 3 != 1) {
                        conditionB.await();
                    }
                    System.out.print("B");
                    conditionC.signal();
                    value ++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }
    class ThreadC implements Runnable{
        @Override
        public void run() {
            lock.lock();
            try {
                for (int i = 0; i < count; i++) {
                    while ( value % 3 != 2) {
                        conditionC.await();
                    }
                    System.out.println("C");
                    conditionA.signal();
                    value ++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }
    }

    public static void main(String[] args) {
        PrintABC printABC = new PrintABC(15);
        printABC.printABC();
    }
}
```

### 服务器 CPU 数量及线程池线程数量的关系 todo

### 多线程之间是如何通信的？

1. 通过共享变量，变量需要 volatile 修饰
2. 使用 wait() 和 notifyAll() 方法，但是由于需要使用同一把锁，所以必须通知线程释放锁，被通知线程才能获取到锁，这样导致通知不及时
3. 使用 CountDownLatch 实现，通知线程到指定条件，调用 countDownLatch.countDown()，被通知线程进行 countDownLatch.await()
4. 使用 Condition 的 await() 和 signalAll() 方法

## 线程相关

### 程序开多少线程合适

-   CPU 密集型程序
    一个完整请求，I/O 操作可以在很短时间内完成，CPU 还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分，线程等待时间接近 0
    -   单核：单核 CPU 处理 CPU 密集型程序，这种情况并不太适合使用多线程
    -   多核：多核 CPU 处理 CPU 密集型程序，完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率。最佳线程数就是：对于 CPU 密集型来说理论上线程数量 = CPU 核数（逻辑），但是实际上，数量一般会设置为 CPU 核数（逻辑）+ 1（经验值），CPU 密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下 CPU 周期不会中断工作
-   I/O 密集型程序
    与 CPU 密集型程序相对，一个完整请求，CPU 运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分，等待时间较长，线程等待时间所占比例越高，需要越多线程；线程 CPU 时间所占比例越高，需要越少线程
    -   最佳线程数 = CPU 核心数 (1/CPU 利用率) = CPU 核心数 (1 + (I/O 耗时/CPU 耗时))
    -   如果几乎全是 I/O 耗时，那么 CPU 耗时就无限趋近于 0，所以纯理论你就可以说是 2N（N=CPU 核数），当然也有说 2N + 1 的，1 应该是 backup
    -   一般来说 2N + 1 就即可

```java
// 获取 CPU 核心个数
Runtime.getRuntime().availableProcessors();
```

### 多线程的创建方式有哪些？ todo

-   1、继承 Thread 类，重写 run()方法

```java
public class Demo extends Thread {
    //重写父类Thread的run()
    public void run() {
    }
    public static void main(String[] args) {
        Demo d1 = new Demo();
        Demo d2 = new Demo();
        d1.start();
        d2.start();
    }
}
```

-   2.实现 Runnable 接口，重写 run()

```java
public class Demo2 implements Runnable{

    //重写Runnable接口的run()
    public void run() {
    }

    public static void main(String[] args) {
        Thread t1 = new Thread(new Demo2());
        Thread t2 = new Thread(new Demo2());
        t1.start();
        t2.start();
    }
}
```

-   3.实现 Callable 接口

```java
public class Demo implements Callable<String> {

    public String call() throws Exception {
        System.out.println("正在执行新建线程任务");
        Thread.sleep(2000);
        return "结果";
    }

    public static void main(String[] args) throws InterruptedException, ExecutionException {
        Demo d = new Demo();
        FutureTask<String> task = new FutureTask<>(d);
        Thread t = new Thread(task);
        t.start();
        //获取任务执行后返回的结果
        String result = task.get();
    }

}
```

-   4.使用线程池创建

```java
public class Demo {
    public static void main(String[] args) {
        Executor threadPool = Executors.newFixedThreadPool(5);
        for(int i = 0 ;i < 10 ; i++) {
            threadPool.execute(new Runnable() {
                public void run() {
                    //todo
                }
            });
        }
    }
}
```

### Runnable 和 Callable 的区别

-   Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是纯粹地去执行 run() 方法中的代码而已
-   Callable 接口中的 call() 方法是有返回值，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。Callable + Future / FutureTask 却可以方便获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务

## 线程安全相关

### 怎么保证线程安全？

-   synchronized 关键字
    -   可以用于代码块，方法（静态方法，同步锁是当前字节码对象；实例方法，同步锁是实例对象）
-   lock 锁机制

```java
Lock lock = new ReentrantLock();
lock.lock();
try {
    System.out.println("获得锁");
} catch (Exception e) {

} finally {
    System.out.println("释放锁");
	lock.unlock();
}
```

## Volatile

### Volatile 的功能

-   保证线程可见性
-   防止指令重排序

### Volatile 的可见性和禁止指令重排序怎么实现的

-   可见性：被修饰的变量在被修改后可以立即同步到主内存，被修饰的变量在每次是用之前都从主内存刷新。本质也是通过内存屏障来实现可见性
    -   写内存屏障（Store Memory Barrier）可以促使处理器将当前 store buffer（存储缓存）的值写回主存
    -   读内存屏障（Load Memory Barrier）可以促使处理器处理 invalidate queue（失效队列）。进而避免由于 Store Buffer 和 Invalidate Queue 的非实时性带来的问题
-   禁止指令重排序： volatile 是通过内存屏障来禁止指令重排序，JMM 内存屏障的策略在每个 volatile 写操作的前面插入一个 Store Store 屏障。 在每个 volatile 写操作的后面插入一个 Store Load 屏障。 在每个 volatile 读操作的后面插入一个 Load Load 屏障。 在每个 volatile 读操作的后面插入一个 Load Store 屏障

### 可以创建 Volatile 数组吗

Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到保护作用

### volatile 能使得一个非原子操作变成原子操作吗？

**部分可以。** volatile 对 long 和 double 变量的读写提供原子性保证：

```java
public class VolatileAtomicity {
    // 64位的long和double读写在32位系统上不是原子的
    private long count = 0;          // 可能看到"撕裂"的值
    private volatile long vCount = 0; // volatile保证原子性

    // 但volatile不能让复合操作变成原子的
    private volatile int counter = 0;

    public void increment() {
        counter++; // 仍然不是原子操作！包含读取、计算、写入三步
    }

    // 正确的原子操作
    private AtomicInteger atomicCounter = new AtomicInteger(0);
    public void atomicIncrement() {
        atomicCounter.incrementAndGet(); // 这是原子的
    }
}
```

**要点：**

-   volatile 保证 64 位 long/double 的读写原子性
-   volatile 不能保证复合操作（如++、--）的原子性
-   需要原子操作时，应使用 Atomic 类或 synchronized

---

## 总结

Java 多线程技术涉及面广泛，是 Java 开发中的重要主题。本文档涵盖了：

### 核心概念

-   **进程与线程：** 基本概念、区别、生命周期
-   **线程创建：** 四种创建方式及其优缺点
-   **线程安全：** 定义、级别、保障机制

### 同步机制

-   **synchronized：** 使用方式、锁机制、性能特点
-   **Lock 接口：** 高级锁功能、与 synchronized 对比
-   **volatile：** 可见性、防重排序、使用限制

### 线程通信

-   **wait/notify：** 经典通信机制
-   **sleep/yield/join：** 线程协调方法
-   **高级工具：** CountDownLatch、CyclicBarrier、Semaphore

### 并发工具类

-   **原子类：** CAS 机制、ABA 问题解决
-   **并发容器：** ConcurrentHashMap 原理演进
-   **线程池：** 参数配置、监控、最佳实践

### 高级主题

-   **死锁预防：** 四个必要条件、避免策略
-   **活锁处理：** 随机性解决方案
-   **性能优化：** 线程数配置、上下文切换减少

### 最佳实践

1. **优先使用高级并发工具** 而非底层同步原语
2. **给线程命名** 便于调试和监控
3. **最小化同步范围** 避免过度加锁
4. **异常处理** 设置 UncaughtExceptionHandler
5. **性能监控** 关注线程池指标和并发性能

### 面试重点

-   线程安全的实现方式
-   synchronized 与 Lock 的区别
-   volatile 的作用和限制
-   CAS 机制和 ABA 问题
-   线程池参数和工作原理
-   死锁的产生和预防
