## 锁相关

### 什么是乐观锁和悲观锁

乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。
悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。

### 聊聊 ReentrantLock 吧

ReentrantLock 意为可重入锁，说起 ReentrantLock 就不得不说 AQS ，因为其底层就是使用 AQS 去实现的。
ReentrantLock 有两种模式，一种是公平锁，一种是非公平锁。

-   公平模式下等待线程入队列后会严格按照队列顺序去执行
-   非公平模式下等待线程入队列后有可能会出现插队情况

公平锁
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687052025-2bf96a70-b543-496a-9fbc-2a6a8fbab5dc.png#averageHue=%23f2f2f2&clientId=u00400ee8-e274-4&from=paste&id=u95b6a12d&originHeight=822&originWidth=1138&originalType=url&ratio=1&rotation=0&showTitle=false&size=369367&status=done&style=none&taskId=u5bf59363-75e7-4c56-b3cc-d24229613f5&title=)

-   第一步：获取状态的 state 的值
    -   如果 state=0 即代表锁没有被其它线程占用，执行第二步。
    -   如果 state!=0 则代表锁正在被其它线程占用，执行第三步。
-   第二步：判断队列中是否有线程在排队等待
    -   如果不存在则直接将锁的所有者设置成当前线程，且更新状态 state 。
    -   如果存在就入队。
-   第三步：判断锁的所有者是不是当前线程
    -   如果是则更新状态 state 的值。
    -   如果不是，线程进入队列排队等待。

非公平锁
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051916-02b67ed2-b1b3-4391-9200-9f9f7d1c5836.png#averageHue=%23eeeeeb&clientId=u00400ee8-e274-4&from=paste&id=ufcbce09a&originHeight=1264&originWidth=1148&originalType=url&ratio=1&rotation=0&showTitle=false&size=209415&status=done&style=none&taskId=u9aa5c2d5-3552-44bc-9ae8-5cc38c335d7&title=)

-   获取状态的 state 的值
    -   如果 state=0 即代表锁没有被其它线程占用，则设置当前锁的持有者为当前线程，该操作用 CAS 完成。
    -   如果不为 0 或者设置失败，代表锁被占用进行下一步。
-   此时获取 state 的值
    -   如果是，则给 state+1，获取锁
    -   如果不是，则进入队列等待
    -   如果是 0，代表刚好线程释放了锁，此时将锁的持有者设为自己
    -   如果不是 0，则查看线程持有者是不是自己

### 24.synchronized 锁升级的过程

在 Java1.6 之前的版本中，synchronized 属于重量级锁，效率低下，锁是 cpu 一个总量级的资源，每次获取锁都要和 cpu 申请，非常消耗性能。
在 jdk1.6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Jdk1.6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁，增加了锁升级的过程，由无锁->偏向锁->自旋锁->重量级锁 ![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687052049-ef2ad665-a5b2-4845-9565-4e19613f7568.png#averageHue=%23f9f9f9&clientId=u00400ee8-e274-4&from=paste&id=ucbace034&originHeight=650&originWidth=1188&originalType=url&ratio=1&rotation=0&showTitle=false&size=361660&status=done&style=none&taskId=u83be01ee-cd90-4b67-a772-95453bd41c7&title=)
增加锁升级的过程主要是减少用户态到核心态的切换，提高锁的效率，从 jvm 层面优化锁

### synchronized 关键字的用法？

synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用 synchronized(对象) { … }定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。

### 简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？

Lock 是 Java 5 以后引入的新的 API，和关键字 synchronized 相比主要相同点：Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。

### 当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

### synchronized 和 ReentrantLock 的区别

synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上：

1. ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁
2. ReentrantLock 可以获取各种锁的信息
3. ReentrantLock 可以灵活地实现多路通知

另外，二者的锁机制其实也是不一样的:ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word.

### synchronized 关键字加在静态方法和实例方法的区别?

修饰静态方法，是对类进行加锁，如果该类中有 methodA 和 methodB 都是被 synchronized 修饰的静态 方法，此时有两个线程 T1、T2 分别调用 methodA()和 methodB()，则 T2 会阻塞等待直到 T1 执行完成之后 才能执行。 修饰实例方法时，是对实例进行加锁，锁的是实例对象的对象头，如果调用同一个对象的两个不同的被 synchronized 修饰的实例方法时，看到的效果和上面的一样，如果调用不同对象的两个不同的被 synchronized 修饰的实例方法时，则不会阻塞。

### 18.countdownlatch 的用法？

两种用法： 1、让主线程 await，业务线程进行业务处理，处理完成时调用 countdownLatch.countDown()， CountDownLatch 实例化的时候需要根据业务去选择 CountDownLatch 的 count; 2、让业务线程 await，主线程处理完数据之后进行 countdownLatch.countDown()，此时业务线程被唤 醒，然后去主线程拿数据，或者执行自己的业务逻辑。

### synchronize 实现原理

[以下资源来源](https://github.com/crossoverJie/Java-Interview/blob/master/MD/Synchronize.md)
众所周知 Synchronize 关键字是解决并发问题常用解决方案，有以下三种使用方式:

-   同步普通方法，锁的是当前对象。
-   同步静态方法，锁的是当前 Class 对象。
-   同步块，锁的是 {} 中的对象。

实现原理： JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。
具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。
其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。
而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。
流程图如下:
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051874-faa73eb9-9a6a-4678-bbea-e0b517629b14.png#averageHue=%23f7f7f7&clientId=u00400ee8-e274-4&from=paste&id=uaa1c338b&originHeight=646&originWidth=1808&originalType=url&ratio=1&rotation=0&showTitle=false&size=185410&status=done&style=none&taskId=u13b68d7b-3637-491c-bff0-46ad3237caa&title=)
synchronize 很多都称之为重量锁，JDK1.6 中对 synchronize 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁。
轻量锁
当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。
如果更新成功，当前线程就获得了锁。
如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。
如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。
不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，轻量锁就会膨胀为重量锁。
解锁
轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁)
轻量锁能提升性能的原因是：
认为大多数锁在整个同步周期都不存在竞争，所以使用 CAS 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，甚至比重量锁更慢。
偏向锁
为了进一步的降低获取锁的代价，JDK1.6 之后还引入了偏向锁。
偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。
当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。
释放锁
当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。
偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 -XX:-userBiasedLocking=false 来关闭偏向锁，并默认进入轻量锁。

### 23.Sychornized 是否是公平锁？

不是公平锁 26.描述一下锁的四种状态及升级过程？
以下是 32 位的对象头描述 public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } synchronized 锁的膨胀过程： 当线程访问同步代码块。首先查看当前锁状态是否是偏向锁(可偏向状态) 1、如果是偏向锁： 1.1、检查当前 mark word 中记录是否是当前线程 id，如果是当前线程 id，则获得偏向锁执行同步代码 块。 1.2、如果不是当前线程 id，cas 操作替换线程 id，替换成功获得偏向锁(线程复用)，替换失败锁撤销升 级轻量锁(同一类对象多次撤销升级达到阈值 20，则批量重偏向,这个点可以稍微提一下,详见下面的注意) 2、升级轻量锁

### 如何预防死锁

1. 首先需要将死锁发生的是个必要条件讲出来：
    1. 互斥条件：同一时间只能有一个线程获取资源
    2. 不可剥夺条件：一个线程已经占有的资源，在释放之前不会被其它线程抢占
    3. 请求和保持条件：线程等待过程中不会释放已占有的资源
    4. 循环等待条件：多个线程互相等待对方释放资源
2. 预防死锁，就是需要破坏这四个必要条件
    1. 由于资源互斥是资源使用的固有特性，无法改变，不讨论
    2. 破坏不可剥夺条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将 被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进 程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行
    3. 破坏请求与保持条件：
        1. 第一种方法是，静态分配即每个进程在开始执行时就申请他所需要的全部资源
        2. 第二种是，动态分配即每个进程在申请所需要的资源时，他本身不占用系统资源
    4. 破坏循环等待条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的 采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小 编号的进程才能申请较大编号的进程

### 产生死锁的条件

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### Java 当中有哪几种锁

自旋锁: 自旋锁在 JDK1.6 之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在 jdk6 之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定
偏向锁: 在 JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。
轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在 Java SE1.6 里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁

### 简述 Java 偏向锁

JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。
其申请流程为：

-   首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；
-   判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤 4；
-   判断是否需要重偏向。如果不用的话，直接获得偏向锁；
-   利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。

### 简述轻量级锁

轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。
其申请流程为：

-   如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。
-   虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针
-   如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。
-   如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧
-   如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行
-   如果不是则说明锁对象已经被其他线程抢占。
-   如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时 Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。

### 简述锁优化策略

即自适应自旋、锁消除、锁粗化、锁升级等策略偏。

### 简述 Java 的自旋锁

线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。

### 简述自适应自旋锁

自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。

### 简述锁粗化

锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。

### 简述锁消除

锁消除是一种更为彻底的优化，在编译时，Java 编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。

### 简述 Lock 与 ReentrantLock

Lock 接口是 Java 并发包的顶层接口。
可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。

# 变量的线程安全问题

## 成员变量和静态变量

-   没有共享，线程安全
-   被共享，分两种情况：
    -   只读，线程安全
    -   有写操作，该变量是临界区，则需要考虑线程安全

## 局部变量

-   局部变量本身是线程安全的
-   局部变量引用的对象不一定是线程安全的
    -   如果该引用的对象只存在于该函数的作用域中，则是线程安全

```java
public static void test1() {
    int i = 10;
    i++;
}
```

-   如果使用`return 语句`返回该引用对象，则需要考虑线程安全问题

### 简述 as-if-serial

编译器会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致

### 简述 happens-before 八大规则

-   程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
-   锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作；
-   volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
-   传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C；
-   线程启动规则：Thread 对象的 start()方法先行发生于此线程的每个一个动作；
-   线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
-   线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
-   对象终结规则：一个对象的初始化完成先行发生于他的 finalize()方法的开始；

### as-if-serial 和 happens-before 的区别

as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。

### 简述原子性操作

一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。

### 简述线程的可见性

可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile、synchronized、final 关键字都能保证可见性。

### 简述有序性

虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。

### 简述 Java 中 volatile 关键字作用

-   保证变量对所有线程的可见性。当一个线程修改了变量值，新值对于其他线程来说是立即可以得知的。
-   禁止指令重排。使用 volatile 变量进行写操作，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器进行重排序。

### Java 线程的实现方式

-   实现 Runnable 接口
-   继承 Thread 类
-   实现 Callable 接口

### 简述 Java 线程的状态

线程状态有 NEW、RUNNABLE、BLOCK、WAITING、TIMED_WAITING、THERMINATED

-   NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。
-   RUNNABLE：运行状态。表示线程正在 JVM 中执行，但是这个执行，不一定真的在跑，也可能在排队等 CPU。
-   BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。
-   WAITING：等待状态。线程内 run 方法执行完 Object.wait()/Thread.join()进入该状态。
-   TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用 Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。
-   TERMINATED：结束状态。线程调用完 run 方法进入该状态。

### 简述线程通信的方式

-   volatile 关键词修饰变量，保证所有线程对变量访问的可见性。
-   synchronized 关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。
-   wait/notify 方法
-   IO 通信

###

###

### 聊聊你对 Java 并发包下 unsafe 类的理解

对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。
Java 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。

### Java 中的乐观锁与 CAS 算法

乐观锁认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。
到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。
乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。
CAS 算法的思路如下：

-   该算法认为不同线程对变量的操作时产生竞争的情况比较少。
-   该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。
-   如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。
-   如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。

###

###

###

###

### synchronized 底层实现原理

Java 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。
synchronized 在 JVM 编译后会产生 monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。
执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。

### synchronized 关键词使用方法

-   直接修饰某个实例方法
-   直接修饰某个静态方法
-   修饰代码块

###

###

### 导致 Java 的线程池被瞬间占满的原因是什么

导致 Java 线程池被瞬间占满的原因有很多，以下是一些常见的原因： 1.任务队列满了：当任务队列中的任务数量超过了线程池的最大容量，新提交的任务将会被拒绝执行。这时如果不进行适当的处理，就会导致线程池被瞬间占满。 2.任务执行时间过长：当某个任务执行的时间过长时，该任务会一直占用一个线程，这会导致该线程无法执行其他任务，从而使线程池中的其他线程都处于等待状态，最终导致线程池被占满。 3.线程池配置不当：如果线程池的核心线程数和最大线程数都设置得过小，当有大量任务提交时，线程池就会被瞬间占满。 4.线程阻塞：当线程在执行任务时被阻塞，例如等待 I/O 操作或者等待某个锁时，该线程会一直占用一个线程资源，如果这种情况发生在多个线程上，就会导致线程池被占满。 5.资源不足：如果系统中的资源不足，例如内存不足或者文件句柄数达到了上限，就可能导致线程池被占满。
为了避免线程池被瞬间占满，可以通过合理的线程池配置、任务队列大小的调整、任务执行时间的优化等方式进行处理。同时，应该对任务的性质和系统资源的状况进行充分的了解和评估，以便对线程池的配置进行合理的调整。

### 在 Spring Boot 的 Web 项目中，通过 controller 调用 service 操作数据库，需要考虑多线程问题吗

在 Spring Boot 的 Web 项目中，如果在 controller 中调用 service 操作数据库，一般不需要考虑多线程问题，因为 Spring 框架本身就是线程安全的。
Spring 框架使用了一种称为"Dependency Injection（依赖注入）"的技术，这种技术可以确保在同一时间只有一个线程访问每个 Bean 实例，避免了多线程并发访问时可能会出现的数据不一致或线程安全问题。
当然，如果在 service 层中有共享变量或全局变量等需要被多个线程访问的情况下，就需要考虑线程安全问题了，可以使用 synchronized 关键字或 Lock 接口来保证线程安全。
总之，在 Spring Boot 的 Web 项目中，如果使用了 Spring 框架的依赖注入功能，通常不需要过多考虑多线程问题，但是对于一些需要跨线程共享变量或全局状态的场景，需要考虑线程安全问题。

## cas 是什么

cas 叫做 CompareAndSwap，比较并交换，很多地方使用到了它，比如锁升级中自旋锁就有用到，主要是通过处理器的指令来保证操作的原子性，它主要包含三个变量：

-   1.变量内存地址
-   2.旧的预期值 A
-   3.准备设置的新值 B

当一个线程需要修改一个共享变量的值，完成这个操作需要先取出共享变量的值，赋给 A，基于 A 进行计算，得到新值 B，在用预期原值 A 和内存中的共享变量值进行比较，如果相同就认为其他线程没有进行修改，而将新值写入内存
![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1677824948632-47e0c41c-3cb4-4408-8ff8-3ae459bbe756.png#averageHue=%23f4f3f4&clientId=ubefa1022-28d2-4&id=wxBpv&originHeight=288&originWidth=774&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18065&status=done&style=none&taskId=ucfb5e705-fae9-4633-aa31-20b488eec84&title=)

CAS 的缺点

-   CPU 开销比较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，又因为自旋的时候会一直占用 CPU，如果 CAS 一直更新不成功就会一直占用，造成 CPU 的浪费。
-   ABA 问题：比如线程 A 去修改 1 这个值，修改成功了，但是中间 线程 B 也修改了这个值，但是修改后的结果还是 1，所以不影响 A 的操作，这就会有问题。可以用版本号来解决这个问题。
-   只能保证一个共享变量的原子性

# Java 锁机制详解

## 目录

1. [锁的基础概念](#锁的基础概念)
2. [synchronized 详解](#synchronized详解)
3. [ReentrantLock 详解](#reentrantlock详解)
4. [锁的分类与特性](#锁的分类与特性)
5. [JVM 锁优化机制](#jvm锁优化机制)
6. [死锁问题](#死锁问题)
7. [线程安全与内存模型](#线程安全与内存模型)
8. [并发工具类](#并发工具类)
9. [实际应用场景](#实际应用场景)
10. [常见面试问题](#常见面试问题)

---

## 锁的基础概念

### 乐观锁与悲观锁

#### 悲观锁

**定义：** 悲观锁认为并发冲突总是会发生，因此在操作共享资源时，总是先获取锁再执行操作。

**特点：**

-   每次操作都会获取独占锁
-   阻塞其他线程访问
-   适用于写操作较多的场景
-   代表：`synchronized`、`ReentrantLock`

```java
// 悲观锁示例
public class PessimisticLockExample {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) {  // 悲观锁
            count++;  // 假设这里有复杂的操作
        }
    }

    public int getCount() {
        synchronized (lock) {
            return count;
        }
    }
}
```

#### 乐观锁

**定义：** 乐观锁认为并发冲突不常发生，操作时不加锁，而是在更新数据时检查是否有其他线程修改了数据。

**特点：**

-   不会阻塞其他线程
-   使用 CAS（Compare And Swap）机制
-   适用于读操作较多的场景
-   代表：`AtomicInteger`、`AtomicReference`

```java
// 乐观锁示例
public class OptimisticLockExample {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        int current;
        int updated;
        do {
            current = count.get();     // 获取当前值
            updated = current + 1;     // 计算新值
        } while (!count.compareAndSet(current, updated)); // CAS操作
    }

    public int getCount() {
        return count.get();
    }
}
```

### 公平锁与非公平锁

#### 公平锁

-   **定义：** 按照线程请求锁的顺序来分配锁
-   **优点：** 避免线程饥饿，所有线程都能获得锁
-   **缺点：** 性能较低，需要维护队列顺序

#### 非公平锁

-   **定义：** 不按照请求顺序分配锁，新来的线程可能直接获得锁
-   **优点：** 性能更高，减少线程切换
-   **缺点：** 可能导致某些线程长时间获取不到锁

```java
// 公平锁与非公平锁示例
public class FairVsUnfairLock {
    // 公平锁
    private final ReentrantLock fairLock = new ReentrantLock(true);

    // 非公平锁（默认）
    private final ReentrantLock unfairLock = new ReentrantLock(false);

    public void fairMethod() {
        fairLock.lock();
        try {
            // 临界区代码
            System.out.println(Thread.currentThread().getName() + " 获得公平锁");
        } finally {
            fairLock.unlock();
        }
    }

    public void unfairMethod() {
        unfairLock.lock();
        try {
            // 临界区代码
            System.out.println(Thread.currentThread().getName() + " 获得非公平锁");
        } finally {
            unfairLock.unlock();
        }
    }
}
```

### 可重入锁

**定义：** 同一个线程可以多次获取同一把锁，每次获取都会增加重入计数。

```java
public class ReentrantExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void methodA() {
        lock.lock();
        try {
            System.out.println("执行方法A");
            methodB(); // 重入调用
        } finally {
            lock.unlock();
        }
    }

    public void methodB() {
        lock.lock(); // 重入锁，不会死锁
        try {
            System.out.println("执行方法B");
        } finally {
            lock.unlock();
        }
    }
}
```

---

## synchronized 详解

### synchronized 基本概念

`synchronized` 是 Java 中最基本的同步机制，它可以确保在同一时刻只有一个线程可以执行某个方法或代码块。

### synchronized 使用方式

#### 1. 修饰实例方法

```java
public class SynchronizedExample {
    private int count = 0;

    // 锁的是当前对象实例
    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

#### 2. 修饰静态方法

```java
public class SynchronizedExample {
    private static int staticCount = 0;

    // 锁的是当前Class对象
    public static synchronized void staticIncrement() {
        staticCount++;
    }

    public static synchronized int getStaticCount() {
        return staticCount;
    }
}
```

#### 3. 修饰代码块

```java
public class SynchronizedExample {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        // 锁的是指定的对象
        synchronized (lock) {
            count++;
        }
    }

    public void increment2() {
        // 锁的是当前对象
        synchronized (this) {
            count++;
        }
    }

    public void staticMethod() {
        // 锁的是Class对象
        synchronized (SynchronizedExample.class) {
            staticCount++;
        }
    }
}
```

### synchronized 实现原理

#### Monitor 机制

`synchronized` 基于 JVM 的 Monitor（监视器）机制实现：

```java
// 编译后的字节码
public void synchronizedMethod() {
    // monitorenter  // 获取monitor
    try {
        // 同步代码块
    } catch (Exception e) {
        // monitorexit   // 异常时释放monitor
        throw e;
    }
    // monitorexit       // 正常时释放monitor
}
```

**Monitor 工作流程：**

1. 线程尝试获取对象的 Monitor
2. 如果 Monitor 没有被占用，线程获得 Monitor 并执行同步代码
3. 如果 Monitor 已被占用，线程进入等待队列
4. 当持有 Monitor 的线程执行完毕，释放 Monitor
5. 等待队列中的线程竞争获取 Monitor

#### 对象头结构

Java 对象头包含 Mark Word，存储锁信息：

| 锁状态   | 25bit                      | 4bit         | 1bit 是否是偏向锁 | 2bit 锁标志位 |
| -------- | -------------------------- | ------------ | ----------------- | ------------- |
| 无锁     | 对象的 hashCode            | 对象分代年龄 | 0                 | 01            |
| 偏向锁   | 线程 ID                    | Epoch        | 1                 | 01            |
| 轻量级锁 | 指向栈中锁记录的指针       |              |                   | 00            |
| 重量级锁 | 指向互斥量(重量级锁)的指针 |              |                   | 10            |

### synchronized 特点分析

#### 优点

-   **简单易用**：语法简洁，不需要手动释放锁
-   **自动释放**：即使发生异常也会自动释放锁
-   **可重入**：同一线程可以多次获取同一把锁
-   **内置条件等待**：配合 wait/notify 使用

#### 缺点

-   **不可中断**：无法中断正在等待锁的线程
-   **无超时机制**：无法设置获取锁的超时时间
-   **非公平锁**：无法保证线程获取锁的公平性
-   **功能相对简单**：无法实现复杂的同步需求

### synchronized 与锁升级

synchronized 在 JDK 1.6 后引入了锁升级机制，提高性能：

```
无锁 → 偏向锁 → 轻量级锁 → 重量级锁
```

这个升级过程是不可逆的，锁只能升级不能降级。

### 实际应用示例

#### 单例模式（双重检查锁）

```java
public class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### 生产者消费者模式

```java
public class ProducerConsumer {
    private final Object lock = new Object();
    private final Queue<Integer> queue = new LinkedList<>();
    private final int maxSize = 10;

    public void produce(int item) throws InterruptedException {
        synchronized (lock) {
            while (queue.size() == maxSize) {
                lock.wait(); // 队列满，等待消费
            }
            queue.offer(item);
            System.out.println("生产: " + item);
            lock.notifyAll(); // 通知消费者
        }
    }

    public int consume() throws InterruptedException {
        synchronized (lock) {
            while (queue.isEmpty()) {
                lock.wait(); // 队列空，等待生产
            }
            int item = queue.poll();
            System.out.println("消费: " + item);
            lock.notifyAll(); // 通知生产者
            return item;
        }
    }
}
```

---

## ReentrantLock 详解

### 基本概念

`ReentrantLock` 是基于 AQS（AbstractQueuedSynchronizer）实现的可重入锁，提供了比 synchronized 更丰富的功能。

### 核心特性

#### 1. 可重入性

同一个线程可以多次获取同一把锁：

```java
public class ReentrantExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void method1() {
        lock.lock();
        try {
            System.out.println("Method1");
            method2(); // 重入调用
        } finally {
            lock.unlock();
        }
    }

    public void method2() {
        lock.lock(); // 重入获取锁
        try {
            System.out.println("Method2");
        } finally {
            lock.unlock();
        }
    }
}
```

#### 2. 公平性选择

```java
public class FairLockExample {
    // 公平锁：按照请求顺序获取锁
    private final ReentrantLock fairLock = new ReentrantLock(true);

    // 非公平锁：允许插队（默认）
    private final ReentrantLock unfairLock = new ReentrantLock(false);

    public void fairMethod() {
        fairLock.lock();
        try {
            // 业务逻辑
        } finally {
            fairLock.unlock();
        }
    }
}
```

### 公平锁与非公平锁实现原理

#### 公平锁获取流程

```java
// 公平锁获取过程
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 公平锁需要检查是否有前驱节点
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        // 重入逻辑
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

#### 非公平锁获取流程

```java
// 非公平锁获取过程
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 非公平锁直接尝试CAS，不检查队列
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    } else if (current == getExclusiveOwnerThread()) {
        // 重入逻辑
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

### ReentrantLock 高级功能

#### 1. 可中断锁

```java
public class InterruptibleLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void interruptibleMethod() throws InterruptedException {
        // 可被中断的锁获取
        lock.lockInterruptibly();
        try {
            // 长时间运行的任务
            Thread.sleep(10000);
        } finally {
            lock.unlock();
        }
    }

    public void demonstrateInterrupt() {
        Thread t1 = new Thread(() -> {
            try {
                interruptibleMethod();
            } catch (InterruptedException e) {
                System.out.println("线程被中断");
            }
        });

        t1.start();

        // 2秒后中断线程
        new Thread(() -> {
            try {
                Thread.sleep(2000);
                t1.interrupt();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

#### 2. 超时锁

```java
public class TimeoutLockExample {
    private final ReentrantLock lock = new ReentrantLock();

    public boolean tryLockWithTimeout(long timeout, TimeUnit unit) {
        try {
            // 尝试在指定时间内获取锁
            if (lock.tryLock(timeout, unit)) {
                try {
                    // 执行业务逻辑
                    System.out.println("获取锁成功，执行业务逻辑");
                    return true;
                } finally {
                    lock.unlock();
                }
            } else {
                System.out.println("获取锁超时");
                return false;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
    }
}
```

#### 3. 条件变量（Condition）

```java
public class ConditionExample {
    private final ReentrantLock lock = new ReentrantLock();
    private final Condition notEmpty = lock.newCondition();
    private final Condition notFull = lock.newCondition();
    private final Object[] items = new Object[100];
    private int putptr, takeptr, count;

    public void put(Object x) throws InterruptedException {
        lock.lock();
        try {
            while (count == items.length) {
                notFull.await(); // 队列满，等待notFull条件
            }
            items[putptr] = x;
            if (++putptr == items.length) putptr = 0;
            ++count;
            notEmpty.signal(); // 通知notEmpty条件
        } finally {
            lock.unlock();
        }
    }

    public Object take() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await(); // 队列空，等待notEmpty条件
            }
            Object x = items[takeptr];
            if (++takeptr == items.length) takeptr = 0;
            --count;
            notFull.signal(); // 通知notFull条件
            return x;
        } finally {
            lock.unlock();
        }
    }
}
```

### synchronized vs ReentrantLock

| 特性         | synchronized            | ReentrantLock          |
| ------------ | ----------------------- | ---------------------- |
| **实现方式** | JVM 内置关键字          | Java 类库              |
| **性能**     | JDK6 后优化，性能接近   | 略高于 synchronized    |
| **功能**     | 基础功能                | 功能丰富               |
| **可中断性** | 不可中断                | 支持中断               |
| **超时获取** | 不支持                  | 支持超时               |
| **公平性**   | 非公平                  | 可选择公平/非公平      |
| **条件变量** | 单一条件（wait/notify） | 多个条件变量           |
| **锁释放**   | 自动释放                | 手动释放（finally 块） |
| **可重入**   | 支持                    | 支持                   |

### 选择建议

**使用 synchronized 的场景：**

-   简单的同步需求
-   代码简洁性要求高
-   JVM 自动优化

**使用 ReentrantLock 的场景：**

-   需要可中断的锁操作
-   需要超时获取锁
-   需要公平锁
-   需要多个条件变量
-   对锁的操作需要更精细的控制

```java
// 推荐的ReentrantLock使用模式
public class ReentrantLockBestPractice {
    private final ReentrantLock lock = new ReentrantLock();

    public void safeMethod() {
        lock.lock();
        try {
            // 业务逻辑
        } finally {
            lock.unlock(); // 确保在finally块中释放锁
        }
    }

    public boolean tryDoSomething() {
        if (lock.tryLock()) {
            try {
                // 业务逻辑
                return true;
            } finally {
                lock.unlock();
            }
        }
        return false; // 获取锁失败
    }
}
```

---

## 锁的分类与特性

### 按锁的特性分类

#### 1. 互斥锁与读写锁

**互斥锁（Exclusive Lock）**

```java
public class MutexLockExample {
    private final ReentrantLock mutex = new ReentrantLock();
    private int data = 0;

    public void write(int value) {
        mutex.lock();
        try {
            data = value; // 写操作需要独占访问
        } finally {
            mutex.unlock();
        }
    }

    public int read() {
        mutex.lock();
        try {
            return data; // 读操作也需要独占访问
        } finally {
            mutex.unlock();
        }
    }
}
```

**读写锁（ReadWrite Lock）**

```java
public class ReadWriteLockExample {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    private int data = 0;

    public void write(int value) {
        writeLock.lock();
        try {
            data = value; // 写操作独占
        } finally {
            writeLock.unlock();
        }
    }

    public int read() {
        readLock.lock();
        try {
            return data; // 多个读操作可以并发
        } finally {
            readLock.unlock();
        }
    }
}
```

#### 2. 自旋锁

**自旋锁原理：** 线程不放弃 CPU 时间片，通过循环检查锁状态来等待锁释放。

```java
public class SpinLock {
    private final AtomicReference<Thread> owner = new AtomicReference<>();

    public void lock() {
        Thread currentThread = Thread.currentThread();
        // 自旋等待
        while (!owner.compareAndSet(null, currentThread)) {
            // 空循环，消耗CPU时间
        }
    }

    public void unlock() {
        Thread currentThread = Thread.currentThread();
        owner.compareAndSet(currentThread, null);
    }
}
```

**自适应自旋锁：** JVM 根据历史自旋成功率动态调整自旋次数。

#### 3. 按获取锁的方式分类

| 锁类型       | 特点                 | 适用场景       | 示例                        |
| ------------ | -------------------- | -------------- | --------------------------- |
| **阻塞锁**   | 获取不到锁时线程阻塞 | 锁竞争不激烈   | synchronized, ReentrantLock |
| **非阻塞锁** | 获取不到锁时立即返回 | 高并发场景     | tryLock(), CAS 操作         |
| **可中断锁** | 等待锁时可被中断     | 需要响应中断   | lockInterruptibly()         |
| **超时锁**   | 等待锁有时间限制     | 避免长时间等待 | tryLock(timeout)            |

### 按锁的状态分类

#### 1. 偏向锁（Biased Lock）

```java
public class BiasedLockExample {
    private int count = 0;

    // 第一次访问时偏向第一个线程
    public synchronized void increment() {
        count++; // 如果只有一个线程访问，使用偏向锁
    }
}
```

**特点：**

-   锁偏向于第一个获得它的线程
-   没有真正的加锁/解锁操作
-   适用于单线程场景

#### 2. 轻量级锁（Lightweight Lock）

```java
// 轻量级锁的Mark Word操作
public class LightweightLockExample {
    private Object lockObject = new Object();

    public void method() {
        synchronized(lockObject) {
            // 在栈帧中创建锁记录
            // 使用CAS操作更新Mark Word
            // 业务逻辑
        }
        // CAS恢复Mark Word
    }
}
```

**特点：**

-   使用 CAS 操作避免互斥量开销
-   适用于线程交替执行同步块的场景
-   竞争激烈时会升级为重量级锁

#### 3. 重量级锁（Heavyweight Lock）

```java
public class HeavyweightLockExample {
    private final Object lock = new Object();

    public void method() {
        synchronized(lock) {
            // 使用操作系统互斥量
            // 线程阻塞和唤醒
            // 涉及用户态和内核态切换
        }
    }
}
```

**特点：**

-   基于操作系统互斥量实现
-   涉及线程阻塞和唤醒
-   性能开销最大，但功能最完整

### 锁的粒度分类

#### 1. 对象锁

```java
public class ObjectLock {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void method1() {
        synchronized(lock1) {
            // 只锁定lock1对象
        }
    }

    public void method2() {
        synchronized(lock2) {
            // 锁定lock2对象，与method1不冲突
        }
    }
}
```

#### 2. 类锁

```java
public class ClassLock {
    private static int staticData = 0;

    // 方式1：synchronized修饰静态方法
    public static synchronized void staticMethod1() {
        staticData++;
    }

    // 方式2：synchronized(ClassName.class)
    public static void staticMethod2() {
        synchronized(ClassLock.class) {
            staticData++;
        }
    }
}
```

#### 3. 方法锁与代码块锁

```java
public class MethodVsBlockLock {
    private int data = 0;
    private final Object lock = new Object();

    // 方法锁：锁定整个方法
    public synchronized void methodLock() {
        data++;
        // 所有代码都在锁的保护下
        someOtherOperation();
    }

    // 代码块锁：只锁定必要的代码
    public void blockLock() {
        someOtherOperation(); // 不需要同步的操作

        synchronized(lock) {
            data++; // 只有这部分需要同步
        }
    }
}
```

### 锁的优化策略

#### 1. 锁消除

JVM 在编译时分析代码，去除不可能存在竞争的锁：

```java
public class LockElimination {
    public String contactString(String s1, String s2) {
        // StringBuffer是线程安全的，但这里只有一个线程访问
        // JVM会消除StringBuffer内部的synchronized
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        return sb.toString();
    }
}
```

#### 2. 锁粗化

将多个相邻的同步块合并为一个：

```java
public class LockCoarsening {
    private final Object lock = new Object();

    // 优化前：多次加锁解锁
    public void inefficient() {
        synchronized(lock) { operation1(); }
        synchronized(lock) { operation2(); }
        synchronized(lock) { operation3(); }
    }

    // 优化后：一次加锁
    public void efficient() {
        synchronized(lock) {
            operation1();
            operation2();
            operation3();
        }
    }
}
```

#### 3. 锁降级

虽然 synchronized 不支持锁降级，但读写锁支持：

```java
public class LockDowngrade {
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    private volatile boolean dataReady = false;
    private String data;

    public void processData() {
        readLock.lock();
        try {
            if (!dataReady) {
                // 必须先释放读锁，再获取写锁
                readLock.unlock();
                writeLock.lock();
                try {
                    if (!dataReady) {
                        data = loadData();
                        dataReady = true;
                    }
                    // 锁降级：在持有写锁时获取读锁
                    readLock.lock();
                } finally {
                    writeLock.unlock(); // 释放写锁，此时仍持有读锁
                }
            }
            // 使用数据
            useData(data);
        } finally {
            readLock.unlock();
        }
    }

    private String loadData() { return "data"; }
    private void useData(String data) { System.out.println(data); }
}
```

---

## JVM 锁优化机制

### synchronized 锁升级过程

在 JDK 1.6 之后，为了提高 synchronized 的性能，JVM 引入了锁升级机制：

```
无锁状态 → 偏向锁 → 轻量级锁 → 重量级锁
```

#### 锁升级流程图

```
线程访问同步代码
       ↓
   检查锁状态
       ↓
  ┌─────────────┐    是    ┌─────────────┐
  │  无锁状态    │ ────────→ │   偏向锁     │
  └─────────────┘          └─────────────┘
                                  ↓ 有竞争
                           ┌─────────────┐
                           │  轻量级锁    │
                           └─────────────┘
                                  ↓ 竞争激烈
                           ┌─────────────┐
                           │  重量级锁    │
                           └─────────────┘
```

### 1. 偏向锁（Biased Lock）

#### 基本原理

偏向锁是为了减少单线程获取锁的代价而引入的优化。

```java
public class BiasedLockDemo {
    private int count = 0;

    // 第一个线程访问时，锁会偏向该线程
    public synchronized void increment() {
        count++; // 后续该线程访问无需加锁操作
    }
}
```

#### 偏向锁的获取过程

```java
// 偏向锁获取伪代码
if (markWord.biasedLock == 1) {
    if (markWord.threadId == currentThreadId) {
        // 偏向当前线程，直接执行
        return;
    } else {
        // 尝试CAS替换threadId
        if (CAS(markWord.threadId, currentThreadId)) {
            // 成功偏向到当前线程
            return;
        } else {
            // 失败，撤销偏向锁，升级为轻量级锁
            revokeBias();
        }
    }
}
```

#### 偏向锁的撤销

```java
public class BiasedLockRevocation {
    private Object lock = new Object();

    public void method1() {
        synchronized(lock) {
            // 线程1获得偏向锁
        }
    }

    public void method2() {
        synchronized(lock) {
            // 线程2尝试获取锁，导致偏向锁撤销
            // 升级为轻量级锁
        }
    }
}
```

**撤销条件：**

-   其他线程尝试获取偏向锁
-   调用 System.gc()
-   线程退出同步块

### 2. 轻量级锁（Lightweight Lock）

#### 基本原理

轻量级锁使用 CAS 操作避免了重量级锁的互斥量开销。

```java
public class LightweightLockDemo {
    private Object lock = new Object();

    public void method() {
        synchronized(lock) {
            // JVM会在当前线程栈帧中创建锁记录(Lock Record)
            // 使用CAS将对象头的Mark Word复制到锁记录
            // 然后CAS将Mark Word更新为指向锁记录的指针

            // 业务逻辑
            doSomething();

            // 退出时使用CAS恢复Mark Word
        }
    }
}
```

#### 轻量级锁的加锁过程

```java
// 轻量级锁加锁伪代码
LockRecord lockRecord = createLockRecord(); // 在栈帧中创建锁记录
lockRecord.markWord = object.markWord;      // 复制Mark Word

if (CAS(object.markWord, ptrToLockRecord)) {
    // 加锁成功
    return;
} else {
    // 加锁失败，可能的原因：
    // 1. 当前线程已持有锁（重入）
    // 2. 其他线程竞争，需要膨胀为重量级锁
    handleLockInflation();
}
```

#### 轻量级锁的解锁过程

```java
// 轻量级锁解锁伪代码
if (CAS(object.markWord, lockRecord.markWord)) {
    // 解锁成功
    return;
} else {
    // 解锁失败，说明有竞争，已膨胀为重量级锁
    // 需要唤醒等待的线程
    notifyWaitingThreads();
}
```

### 3. 重量级锁（Heavyweight Lock）

#### 基本原理

重量级锁基于操作系统的互斥量（Mutex）实现，涉及用户态和内核态的切换。

```java
public class HeavyweightLockDemo {
    private Object lock = new Object();

    public void method() {
        synchronized(lock) {
            // 当竞争激烈时，轻量级锁会膨胀为重量级锁
            // 线程会被阻塞，进入等待队列
            // 涉及系统调用，性能开销较大

            heavyComputation(); // 长时间的计算
        }
    }
}
```

#### Monitor 工作机制

```java
// Monitor工作原理示意
public class MonitorExample {
    private final Object monitor = new Object();

    public void waitExample() throws InterruptedException {
        synchronized(monitor) {
            while (condition) {
                monitor.wait(); // 释放锁，进入等待队列
            }
            // 重新获得锁后继续执行
        }
    }

    public void notifyExample() {
        synchronized(monitor) {
            condition = false;
            monitor.notify(); // 唤醒等待队列中的一个线程
        }
    }
}
```

### 4. 自旋优化

#### 自旋锁机制

```java
public class SpinOptimization {
    private volatile boolean locked = false;

    public void spinLock() {
        // 简单自旋锁实现
        while (locked) {
            // 自旋等待，不放弃CPU
            Thread.yield(); // 让出CPU时间片
        }
        locked = true;
    }

    public void unlock() {
        locked = false;
    }
}
```

#### 自适应自旋

JVM 会根据历史统计信息动态调整自旋次数：

```java
// 自适应自旋伪代码
int spinCount = getSpinCount(lock); // 根据历史信息获取自旋次数

for (int i = 0; i < spinCount; i++) {
    if (tryLock()) {
        return; // 获取锁成功
    }
    // 继续自旋
}

// 自旋失败，阻塞线程
blockThread();
```

### 5. 锁消除（Lock Elimination）

编译器在编译时分析代码，去除不可能存在竞争的锁：

```java
public class LockEliminationExample {

    // 原始代码
    public String inefficientConcat(String s1, String s2, String s3) {
        StringBuffer sb = new StringBuffer(); // StringBuffer内部有synchronized
        sb.append(s1);
        sb.append(s2);
        sb.append(s3);
        return sb.toString();
    }

    // JVM优化后等效代码
    public String optimizedConcat(String s1, String s2, String s3) {
        StringBuilder sb = new StringBuilder(); // 编译器知道sb只在一个线程中使用
        sb.append(s1);
        sb.append(s2);
        sb.append(s3);
        return sb.toString();
    }
}
```

### 6. 锁粗化（Lock Coarsening）

将多个连续的加锁解锁操作合并为一个：

```java
public class LockCoarseningExample {
    private final Object lock = new Object();

    // 优化前：频繁加锁解锁
    public void inefficientMethod() {
        for (int i = 0; i < 1000; i++) {
            synchronized(lock) {
                // 每次循环都加锁解锁
                doSomething(i);
            }
        }
    }

    // 优化后：锁粗化
    public void efficientMethod() {
        synchronized(lock) {
            for (int i = 0; i < 1000; i++) {
                // 整个循环只加锁一次
                doSomething(i);
            }
        }
    }

    private void doSomething(int i) {
        // 具体操作
    }
}
```

### 锁优化的 JVM 参数

```bash
# 偏向锁相关参数
-XX:+UseBiasedLocking          # 启用偏向锁（JDK6-14默认开启）
-XX:-UseBiasedLocking          # 禁用偏向锁
-XX:BiasedLockingStartupDelay=0 # 设置偏向锁延迟启动时间

# 自旋锁相关参数
-XX:+UseSpinning               # 启用自旋锁（JDK6后默认开启）
-XX:PreBlockSpin=10            # 设置自旋次数

# 锁优化相关参数
-XX:+EliminateLocks            # 启用锁消除
-XX:+DoEscapeAnalysis          # 启用逃逸分析（锁消除的前提）
```

### 性能对比

| 锁类型       | 获取/释放开销 | 适用场景     | 优缺点                                     |
| ------------ | ------------- | ------------ | ------------------------------------------ |
| **偏向锁**   | 极低          | 单线程访问   | 优：几乎无开销；缺：多线程竞争时撤销开销大 |
| **轻量级锁** | 低            | 线程交替访问 | 优：CAS 操作，避免阻塞；缺：自旋消耗 CPU   |
| **重量级锁** | 高            | 竞争激烈场景 | 优：功能完整；缺：涉及系统调用，开销大     |

### 最佳实践

```java
public class LockOptimizationBestPractices {

    // 1. 减少锁的粒度
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    public void finegrainedLocking() {
        synchronized(lock1) {
            // 只保护相关资源
            updateResource1();
        }

        // 不需要同步的操作
        doIndependentWork();

        synchronized(lock2) {
            // 保护另一个资源
            updateResource2();
        }
    }

    // 2. 减少锁的持有时间
    public void minimizeLockHoldTime() {
        // 准备工作在锁外进行
        Object data = prepareData();

        synchronized(this) {
            // 只在必要时持有锁
            updateSharedState(data);
        }

        // 后续处理在锁外进行
        processResult();
    }

    // 3. 使用并发集合类
    private final ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();

    public void useConcurrentCollections() {
        // 使用并发集合类替代synchronized集合
        map.put("key", "value"); // 内部优化的并发控制
    }

    private void updateResource1() {}
    private void updateResource2() {}
    private void doIndependentWork() {}
    private Object prepareData() { return new Object(); }
    private void updateSharedState(Object data) {}
    private void processResult() {}
}
```

---

### Java 当中有哪几种锁

自旋锁: 自旋锁在 JDK1.6 之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在 jdk6 之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定
偏向锁: 在 JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。
轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在 Java SE1.6 里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁

### 简述 Java 偏向锁

JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。
其申请流程为：

-   首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；
-   判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤 4；
-   判断是否需要重偏向。如果不用的话，直接获得偏向锁；
-   利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。

### 简述轻量级锁

轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。
其申请流程为：

-   如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。
-   虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针
-   如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。
-   如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧
-   如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行
-   如果不是则说明锁对象已经被其他线程抢占。
-   如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时 Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。

### 简述锁优化策略

即自适应自旋、锁消除、锁粗化、锁升级等策略偏。

### 简述 Java 的自旋锁

线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。

### 简述自适应自旋锁

自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。

### 简述锁粗化

锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。

### 简述锁消除

锁消除是一种更为彻底的优化，在编译时，Java 编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。

### 简述 Lock 与 ReentrantLock

Lock 接口是 Java 并发包的顶层接口。
可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。

## 线程安全与内存模型

### 变量的线程安全性

#### 成员变量和静态变量

```java
public class VariableThreadSafety {

    // 1. 不共享的成员变量 - 线程安全
    private int instanceVar; // 每个实例都有自己的副本

    // 2. 共享的成员变量 - 需要考虑线程安全
    private static int sharedVar = 0; // 所有实例共享

    // 3. 只读共享变量 - 线程安全
    private static final int CONSTANT = 100; // 不可变

    // 4. 有写操作的共享变量 - 非线程安全
    private static int counter = 0;

    public void unsafeMethod() {
        counter++; // 非线程安全操作
    }

    public synchronized void safeMethod() {
        counter++; // 线程安全操作
    }
}
```

#### 局部变量

```java
public class LocalVariableThreadSafety {

    // 1. 基本类型局部变量 - 线程安全
    public void safeLocalVariable() {
        int localVar = 10; // 线程私有
        localVar++; // 安全操作
    }

    // 2. 引用类型局部变量 - 情况复杂
    public void referenceLocalVariable() {
        List<String> localList = new ArrayList<>(); // 线程私有
        localList.add("item"); // 安全，因为引用不会逃逸
    }

    // 3. 引用逃逸 - 需要考虑线程安全
    public List<String> escapingReference() {
        List<String> localList = new ArrayList<>();
        localList.add("item");
        return localList; // 引用逃逸，可能被其他线程访问
    }

    // 4. 方法参数传递引用 - 需要考虑线程安全
    public void modifyList(List<String> list) {
        list.add("item"); // 可能不安全，取决于调用者
    }
}
```

### Java 内存模型（JMM）

#### 基本概念

Java 内存模型定义了线程与内存之间的抽象关系：

```java
public class MemoryModelExample {
    private boolean flag = false;
    private int counter = 0;

    // 写线程
    public void writer() {
        counter = 1;    // 1
        flag = true;    // 2
    }

    // 读线程
    public void reader() {
        if (flag) {     // 3
            int i = counter * 2; // 4
            // 由于重排序，这里i的值可能不是2
        }
    }
}
```

#### as-if-serial 规则

```java
public class AsIfSerialExample {
    private int a = 0;
    private int b = 0;

    public void method() {
        // 编译器可能重排序这些操作
        a = 1; // 操作1
        b = 2; // 操作2
        int c = a + b; // 操作3

        // 但必须保证c的值是正确的（单线程语义）
    }
}
```

#### happens-before 规则

Java 内存模型通过 happens-before 规则来确定操作的执行顺序：

```java
public class HappensBeforeExample {
    private int x = 0;
    private volatile boolean flag = false;

    // 线程A
    public void threadA() {
        x = 1;          // 1
        flag = true;    // 2 (volatile写)
    }

    // 线程B
    public void threadB() {
        if (flag) {     // 3 (volatile读)
            int i = x;  // 4
            // 根据happens-before规则，这里i一定等于1
        }
    }
}
```

**8 个 happens-before 规则：**

1. **程序次序规则**：单线程内，按照代码顺序执行
2. **锁定规则**：unlock 操作 happens-before 后续的 lock 操作
3. **volatile 变量规则**：volatile 写 happens-before 后续的 volatile 读
4. **传递性**：A happens-before B，B happens-before C，则 A happens-before C
5. **线程启动规则**：Thread.start() happens-before 该线程的所有操作
6. **线程中断规则**：interrupt()调用 happens-before 检测到中断事件
7. **线程终结规则**：线程中所有操作 happens-before 线程的终止检测
8. **对象终结规则**：对象初始化 happens-before finalize()方法

### 三大特性

#### 1. 原子性（Atomicity）

```java
public class AtomicityExample {
    private int count = 0;
    private final AtomicInteger atomicCount = new AtomicInteger(0);

    // 非原子操作
    public void nonAtomicIncrement() {
        count++; // 包含读取、计算、写入三个步骤
    }

    // 原子操作
    public void atomicIncrement() {
        atomicCount.incrementAndGet(); // 原子操作
    }

    // 同步保证原子性
    public synchronized void synchronizedIncrement() {
        count++; // 在同步块中保证原子性
    }
}
```

#### 2. 可见性（Visibility）

```java
public class VisibilityExample {
    private boolean running = true;
    private volatile boolean volatileRunning = true;

    // 线程1
    public void thread1() {
        while (running) {
            // 可能无法看到running的变化
        }
    }

    // 线程2
    public void thread2() {
        while (volatileRunning) {
            // 能够立即看到volatileRunning的变化
        }
    }

    public void stopThreads() {
        running = false;         // 可能不可见
        volatileRunning = false; // 立即可见
    }
}
```

#### 3. 有序性（Ordering）

```java
public class OrderingExample {
    private int a = 0;
    private int b = 0;
    private volatile int v = 0;

    // 可能发生重排序
    public void method1() {
        a = 1; // 1
        b = 2; // 2 可能与1重排序
    }

    // volatile禁止重排序
    public void method2() {
        a = 1; // 1
        v = 3; // 2 volatile写，建立内存屏障
        b = 2; // 3 不能重排序到2之前
    }
}
```

### volatile 关键字详解

#### volatile 的作用

```java
public class VolatileExample {
    private volatile boolean flag = false;
    private volatile int counter = 0;

    // 1. 保证可见性
    public void setFlag() {
        flag = true; // 立即写入主内存
    }

    public boolean checkFlag() {
        return flag; // 直接从主内存读取
    }

    // 2. 禁止指令重排序
    private int a = 0;
    private volatile int b = 0;

    public void method() {
        a = 1;       // 1
        b = 2;       // 2 volatile写，不能与1重排序
        int c = a;   // 3 不能重排序到2之前
    }

    // 3. 不保证原子性
    public void incrementCounter() {
        counter++; // 非原子操作，volatile无法保证
    }

    // 正确的原子操作
    private final AtomicInteger atomicCounter = new AtomicInteger(0);

    public void atomicIncrementCounter() {
        atomicCounter.incrementAndGet();
    }
}
```

#### volatile 的实现原理

```java
public class VolatileImplementation {
    private volatile int value;

    public void setValue(int newValue) {
        // 编译后会在汇编指令中添加lock前缀
        // lock addl $0,0(%%esp) - 内存屏障
        value = newValue;
    }

    public int getValue() {
        // 保证从主内存读取最新值
        return value;
    }
}
```

### 内存屏障

```java
public class MemoryBarrierExample {
    private int a = 0;
    private int b = 0;
    private volatile int flag = 0;

    public void writer() {
        a = 1;              // 1
        b = 2;              // 2
        // StoreStore屏障
        flag = 1;           // 3 volatile写
        // StoreLoad屏障
    }

    public void reader() {
        int f = flag;       // 4 volatile读
        // LoadLoad屏障
        // LoadStore屏障
        if (f == 1) {
            int x = a;      // 5
            int y = b;      // 6
        }
    }
}
```

### 线程状态与生命周期

#### 线程状态枚举

```java
public class ThreadStateExample {

    public static void demonstrateThreadStates() throws InterruptedException {
        Object lock = new Object();

        // NEW状态
        Thread thread = new Thread(() -> {
            synchronized (lock) {
                try {
                    // TIMED_WAITING状态
                    Thread.sleep(2000);

                    // WAITING状态
                    lock.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });

        System.out.println("1. " + thread.getState()); // NEW

        thread.start();
        Thread.sleep(100);
        System.out.println("2. " + thread.getState()); // RUNNABLE

        Thread.sleep(500);
        System.out.println("3. " + thread.getState()); // TIMED_WAITING

        Thread.sleep(2000);
        System.out.println("4. " + thread.getState()); // WAITING

        // 创建另一个线程来演示BLOCKED状态
        Thread blockedThread = new Thread(() -> {
            synchronized (lock) {
                // 这个线程会被阻塞
                System.out.println("获得锁");
            }
        });

        blockedThread.start();
        Thread.sleep(100);
        System.out.println("5. " + blockedThread.getState()); // BLOCKED

        // 唤醒等待的线程
        synchronized (lock) {
            lock.notify();
        }

        thread.join();
        System.out.println("6. " + thread.getState()); // TERMINATED
    }
}
```

#### 线程通信方式

```java
public class ThreadCommunication {

    // 1. volatile变量通信
    private volatile boolean flag = false;

    public void volatileCommunication() {
        new Thread(() -> {
            while (!flag) {
                // 等待flag变为true
            }
            System.out.println("收到信号");
        }).start();

        new Thread(() -> {
            try {
                Thread.sleep(1000);
                flag = true; // 发送信号
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }

    // 2. wait/notify通信
    private final Object lock = new Object();
    private boolean condition = false;

    public void waitNotifyCommunication() {
        new Thread(() -> {
            synchronized (lock) {
                while (!condition) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
                System.out.println("条件满足，继续执行");
            }
        }).start();

        new Thread(() -> {
            try {
                Thread.sleep(1000);
                synchronized (lock) {
                    condition = true;
                    lock.notify();
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }

    // 3. 管道通信
    public void pipelineCommunication() throws IOException {
        PipedWriter writer = new PipedWriter();
        PipedReader reader = new PipedReader(writer);

        new Thread(() -> {
            try (BufferedReader br = new BufferedReader(reader)) {
                String line = br.readLine();
                System.out.println("接收到: " + line);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(() -> {
            try (PrintWriter pw = new PrintWriter(writer)) {
                Thread.sleep(1000);
                pw.println("Hello from writer thread");
                pw.flush();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

---

## 并发工具类

### CAS（Compare And Swap）机制

#### CAS 基本原理

CAS 是一种无锁算法，包含三个操作数：

-   **内存位置（V）**：要修改的变量的内存地址
-   **预期原值（A）**：期望的当前值
-   **新值（B）**：要设置的新值

```java
public class CASExample {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        int current;
        int updated;
        do {
            current = count.get();    // 获取当前值
            updated = current + 1;    // 计算新值
        } while (!count.compareAndSet(current, updated)); // CAS操作
    }

    // 模拟CAS的底层实现
    public boolean compareAndSet(int expect, int update) {
        // 伪代码：实际由CPU指令实现
        synchronized (this) {
            if (this.value == expect) {
                this.value = update;
                return true;
            }
            return false;
        }
    }
}
```

#### CAS 的优缺点

**优点：**

-   **非阻塞算法**：不会导致线程阻塞
-   **性能高**：避免了锁的开销
-   **避免死锁**：无锁设计

**缺点：**

```java
public class CASProblems {

    // 1. ABA问题
    private final AtomicInteger value = new AtomicInteger(1);

    public void abaDemo() {
        // 线程1读取值为1
        int original = value.get(); // 1

        // 假设线程2执行：1 -> 2 -> 1
        // 线程1无法察觉值被修改过
        boolean success = value.compareAndSet(original, 2);
        System.out.println("CAS成功: " + success);
    }

    // ABA问题解决方案：使用版本号
    private final AtomicStampedReference<Integer> stampedRef =
        new AtomicStampedReference<>(1, 0);

    public void solveABA() {
        int[] stampHolder = new int[1];
        Integer ref = stampedRef.get(stampHolder);
        int stamp = stampHolder[0];

        // 使用版本号进行CAS
        boolean success = stampedRef.compareAndSet(ref, ref + 1, stamp, stamp + 1);
        System.out.println("带版本号的CAS成功: " + success);
    }

    // 2. 自旋开销问题
    private final AtomicInteger counter = new AtomicInteger(0);

    public void highContentionIncrement() {
        // 在高竞争环境下，大量线程自旋会消耗CPU
        for (int i = 0; i < 1000000; i++) {
            while (true) {
                int current = counter.get();
                if (counter.compareAndSet(current, current + 1)) {
                    break; // 成功则跳出自旋
                }
                // 继续自旋，消耗CPU
            }
        }
    }

    // 3. 只能保证一个共享变量的原子性
    private final AtomicInteger x = new AtomicInteger(0);
    private final AtomicInteger y = new AtomicInteger(0);

    public void multipleVariables() {
        // 无法同时原子地更新x和y
        // 需要使用锁或其他机制
        synchronized(this) {
            x.incrementAndGet();
            y.incrementAndGet();
        }
    }

    // 解决方案：将多个变量封装成一个对象
    public static class Point {
        public final int x, y;
        public Point(int x, int y) { this.x = x; this.y = y; }
    }

    private final AtomicReference<Point> pointRef =
        new AtomicReference<>(new Point(0, 0));

    public void atomicUpdatePoint() {
        Point current;
        Point updated;
        do {
            current = pointRef.get();
            updated = new Point(current.x + 1, current.y + 1);
        } while (!pointRef.compareAndSet(current, updated));
    }
}
```

### Unsafe 类详解

```java
public class UnsafeExample {
    private static final Unsafe unsafe;
    private static final long valueOffset;

    static {
        try {
            // 通过反射获取Unsafe实例
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            unsafe = (Unsafe) field.get(null);

            // 获取字段的内存偏移量
            valueOffset = unsafe.objectFieldOffset(
                UnsafeExample.class.getDeclaredField("value"));
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private volatile int value = 0;

    // 使用Unsafe进行CAS操作
    public boolean compareAndSwapInt(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    // 直接内存操作
    public void directMemoryAccess() {
        // 分配内存
        long address = unsafe.allocateMemory(8);

        try {
            // 写入数据
            unsafe.putLong(address, 1234567890L);

            // 读取数据
            long value = unsafe.getLong(address);
            System.out.println("Direct memory value: " + value);

        } finally {
            // 释放内存
            unsafe.freeMemory(address);
        }
    }

    // 创建对象（绕过构造器）
    public void createObjectWithoutConstructor() throws InstantiationException {
        // 不调用构造器创建对象
        Object obj = unsafe.allocateInstance(String.class);
        System.out.println("Created object: " + obj);
    }
}
```

### CountDownLatch 详解

```java
public class CountDownLatchExample {

    // 1. 等待多个线程完成
    public void waitForTasks() throws InterruptedException {
        int taskCount = 3;
        CountDownLatch latch = new CountDownLatch(taskCount);

        // 启动工作线程
        for (int i = 0; i < taskCount; i++) {
            final int taskId = i;
            new Thread(() -> {
                try {
                    // 模拟任务执行
                    Thread.sleep(1000 + taskId * 500);
                    System.out.println("任务" + taskId + "完成");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown(); // 完成后计数减1
                }
            }).start();
        }

        // 主线程等待所有任务完成
        System.out.println("等待所有任务完成...");
        latch.await();
        System.out.println("所有任务已完成！");
    }

    // 2. 让多个线程等待开始信号
    public void startSignal() throws InterruptedException {
        CountDownLatch startSignal = new CountDownLatch(1);
        int workerCount = 3;

        // 创建工作线程
        for (int i = 0; i < workerCount; i++) {
            final int workerId = i;
            new Thread(() -> {
                try {
                    System.out.println("工作线程" + workerId + "准备就绪");
                    startSignal.await(); // 等待开始信号

                    // 开始工作
                    System.out.println("工作线程" + workerId + "开始工作");
                    Thread.sleep(2000);
                    System.out.println("工作线程" + workerId + "工作完成");

                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        }

        // 主线程准备
        Thread.sleep(2000);
        System.out.println("发送开始信号...");
        startSignal.countDown(); // 发送开始信号
    }

    // 3. 实际应用：服务启动协调
    public void serviceStartupCoordination() throws InterruptedException {
        CountDownLatch serviceLatch = new CountDownLatch(3);

        // 启动数据库服务
        new Thread(() -> {
            try {
                System.out.println("启动数据库服务...");
                Thread.sleep(2000);
                System.out.println("数据库服务启动完成");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                serviceLatch.countDown();
            }
        }).start();

        // 启动缓存服务
        new Thread(() -> {
            try {
                System.out.println("启动缓存服务...");
                Thread.sleep(1500);
                System.out.println("缓存服务启动完成");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                serviceLatch.countDown();
            }
        }).start();

        // 启动消息队列服务
        new Thread(() -> {
            try {
                System.out.println("启动消息队列服务...");
                Thread.sleep(1000);
                System.out.println("消息队列服务启动完成");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                serviceLatch.countDown();
            }
        }).start();

        // 等待所有服务启动完成
        System.out.println("等待所有服务启动...");
        serviceLatch.await();
        System.out.println("所有服务启动完成，应用程序可以开始处理请求");
    }
}
```

### 其他重要并发工具

#### Semaphore（信号量）

```java
public class SemaphoreExample {
    // 限制同时访问资源的线程数
    private final Semaphore semaphore = new Semaphore(3); // 最多3个许可

    public void accessResource() {
        try {
            semaphore.acquire(); // 获取许可
            System.out.println(Thread.currentThread().getName() + " 正在访问资源");
            Thread.sleep(2000); // 模拟资源使用
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            System.out.println(Thread.currentThread().getName() + " 释放资源");
            semaphore.release(); // 释放许可
        }
    }
}
```

#### CyclicBarrier（循环屏障）

```java
public class CyclicBarrierExample {
    public void cyclicBarrierDemo() {
        int parties = 3;
        CyclicBarrier barrier = new CyclicBarrier(parties, () -> {
            System.out.println("所有线程都到达屏障点，继续执行");
        });

        for (int i = 0; i < parties; i++) {
            final int threadId = i;
            new Thread(() -> {
                try {
                    System.out.println("线程" + threadId + "执行第一阶段");
                    Thread.sleep(1000 + threadId * 500);

                    barrier.await(); // 等待其他线程

                    System.out.println("线程" + threadId + "执行第二阶段");
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
}
```

---

## 实际应用场景

### 缓存更新模式

#### 缓存双重检查锁

```java
public class CacheManager {
    private volatile Map<String, Object> cache;
    private final Object lock = new Object();

    public Object getFromCache(String key) {
        if (cache == null) {
            synchronized (lock) {
                if (cache == null) {
                    cache = loadCacheFromDatabase();
                }
            }
        }
        return cache.get(key);
    }

    private Map<String, Object> loadCacheFromDatabase() {
        // 模拟从数据库加载缓存
        System.out.println("从数据库加载缓存...");
        Map<String, Object> newCache = new HashMap<>();
        // 实际数据库操作
        return newCache;
    }
}
```

#### 分布式锁实现缓存更新

```java
public class DistributedCacheManager {
    private final RedisTemplate<String, Object> redisTemplate;
    private final String LOCK_KEY = "cache:update:lock";
    private final String CACHE_KEY = "cache:data";

    public Object getCacheData(String key) {
        // 先从缓存获取
        Object cached = redisTemplate.opsForHash().get(CACHE_KEY, key);
        if (cached != null) {
            return cached;
        }

        // 缓存未命中，获取分布式锁更新缓存
        String lockValue = UUID.randomUUID().toString();
        try {
            boolean acquired = acquireDistributedLock(lockValue, 30000);
            if (acquired) {
                // 再次检查缓存（可能已被其他节点更新）
                cached = redisTemplate.opsForHash().get(CACHE_KEY, key);
                if (cached == null) {
                    // 从数据库加载并更新缓存
                    cached = loadFromDatabase(key);
                    redisTemplate.opsForHash().put(CACHE_KEY, key, cached);
                    redisTemplate.expire(CACHE_KEY, Duration.ofMinutes(30));
                }
            }
        } finally {
            releaseDistributedLock(lockValue);
        }

        return cached;
    }

    private boolean acquireDistributedLock(String lockValue, long timeoutMs) {
        Boolean result = redisTemplate.opsForValue().setIfAbsent(
            LOCK_KEY, lockValue, Duration.ofMillis(timeoutMs));
        return Boolean.TRUE.equals(result);
    }

    private void releaseDistributedLock(String lockValue) {
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "return redis.call('del', KEYS[1]) " +
            "else return 0 end";
        redisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(LOCK_KEY), lockValue);
    }
}
```

### 数据库连接池管理

#### 连接池的线程安全实现

```java
public class DatabaseConnectionPool {
    private final BlockingQueue<Connection> pool;
    private final AtomicInteger activeConnections = new AtomicInteger(0);
    private final int maxConnections;
    private final Object createLock = new Object();

    public DatabaseConnectionPool(int maxConnections) {
        this.maxConnections = maxConnections;
        this.pool = new LinkedBlockingQueue<>();
    }

    public Connection getConnection() throws InterruptedException {
        Connection conn = pool.poll();
        if (conn == null) {
            // 需要创建新连接
            synchronized (createLock) {
                if (activeConnections.get() < maxConnections) {
                    conn = createNewConnection();
                    activeConnections.incrementAndGet();
                }
            }

            if (conn == null) {
                // 等待可用连接
                conn = pool.take();
            }
        }
        return conn;
    }

    public void returnConnection(Connection conn) {
        if (conn != null && isValidConnection(conn)) {
            pool.offer(conn);
        } else {
            // 连接无效，减少活跃连接数
            activeConnections.decrementAndGet();
        }
    }

    private Connection createNewConnection() {
        // 创建新的数据库连接
        return DriverManager.getConnection("jdbc:mysql://localhost:3306/test");
    }

    private boolean isValidConnection(Connection conn) {
        try {
            return !conn.isClosed() && conn.isValid(5);
        } catch (SQLException e) {
            return false;
        }
    }
}
```

### 秒杀系统的并发控制

#### 库存扣减的线程安全实现

```java
@Service
public class SeckillService {

    private final StringRedisTemplate redisTemplate;
    private final SeckillMapper seckillMapper;

    // 使用Redis分布式锁控制库存扣减
    public SeckillResult seckillWithRedisLock(Long seckillId, Long userId) {
        String lockKey = "seckill:lock:" + seckillId;
        String lockValue = UUID.randomUUID().toString();

        try {
            // 获取分布式锁
            Boolean acquired = redisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(10));

            if (!Boolean.TRUE.equals(acquired)) {
                return SeckillResult.fail("系统繁忙，请稍后重试");
            }

            // 检查库存
            Integer stock = getStockFromRedis(seckillId);
            if (stock <= 0) {
                return SeckillResult.fail("库存不足");
            }

            // 检查用户是否已经参与过秒杀
            if (hasUserParticipated(seckillId, userId)) {
                return SeckillResult.fail("您已经参与过该秒杀活动");
            }

            // 扣减库存
            decrementStock(seckillId);

            // 创建订单
            Long orderId = createSeckillOrder(seckillId, userId);

            return SeckillResult.success(orderId);

        } finally {
            // 释放锁
            releaseDistributedLock(lockKey, lockValue);
        }
    }

    // 使用CAS实现无锁库存扣减
    public SeckillResult seckillWithCAS(Long seckillId, Long userId) {
        int maxRetries = 10;
        int retryCount = 0;

        while (retryCount < maxRetries) {
            // 获取当前库存
            Integer currentStock = getStockFromRedis(seckillId);

            if (currentStock <= 0) {
                return SeckillResult.fail("库存不足");
            }

            // 使用CAS更新库存
            String stockKey = "seckill:stock:" + seckillId;
            String script =
                "local current = redis.call('get', KEYS[1]) " +
                "if current == ARGV[1] then " +
                "  redis.call('set', KEYS[1], ARGV[2]) " +
                "  return 1 " +
                "else " +
                "  return 0 " +
                "end";

            Long result = redisTemplate.execute(
                new DefaultRedisScript<>(script, Long.class),
                Collections.singletonList(stockKey),
                currentStock.toString(),
                String.valueOf(currentStock - 1)
            );

            if (result == 1) {
                // CAS成功，创建订单
                Long orderId = createSeckillOrder(seckillId, userId);
                return SeckillResult.success(orderId);
            }

            retryCount++;
            // 短暂等待后重试
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }

        return SeckillResult.fail("系统繁忙，请稍后重试");
    }
}
```

### 任务调度系统

#### 分布式任务锁

```java
@Component
public class ScheduledTaskManager {

    private final RedisTemplate<String, String> redisTemplate;

    @Scheduled(fixedRate = 60000) // 每分钟执行一次
    public void executeScheduledTask() {
        String taskKey = "scheduled:task:data-sync";
        String instanceId = InetAddress.getLocalHost().getHostAddress() +
                           ":" + ManagementFactory.getRuntimeMXBean().getName();

        try {
            // 获取分布式锁，确保只有一个实例执行任务
            Boolean acquired = redisTemplate.opsForValue()
                .setIfAbsent(taskKey, instanceId, Duration.ofMinutes(5));

            if (Boolean.TRUE.equals(acquired)) {
                System.out.println("实例 " + instanceId + " 获得任务锁，开始执行任务");

                // 执行实际的任务逻辑
                performDataSync();

                // 任务执行完成，主动释放锁
                releaseTaskLock(taskKey, instanceId);

            } else {
                System.out.println("实例 " + instanceId + " 未获得任务锁，跳过执行");
            }

        } catch (Exception e) {
            System.err.println("任务执行失败: " + e.getMessage());
            // 确保异常情况下也释放锁
            releaseTaskLock(taskKey, instanceId);
        }
    }

    private void performDataSync() {
        // 模拟数据同步任务
        System.out.println("开始执行数据同步任务...");
        try {
            Thread.sleep(30000); // 模拟任务执行时间
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        System.out.println("数据同步任务执行完成");
    }

    private void releaseTaskLock(String taskKey, String instanceId) {
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "  return redis.call('del', KEYS[1]) " +
            "else " +
            "  return 0 " +
            "end";

        redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(taskKey),
            instanceId
        );
    }
}
```

## 性能优化与最佳实践

### 锁的性能对比

#### 不同锁机制的性能测试

```java
public class LockPerformanceTest {

    private static final int THREAD_COUNT = 100;
    private static final int OPERATIONS_PER_THREAD = 100000;

    private volatile int counter = 0;
    private final Object syncLock = new Object();
    private final ReentrantLock reentrantLock = new ReentrantLock();
    private final AtomicInteger atomicCounter = new AtomicInteger(0);

    @Test
    public void testSynchronizedPerformance() throws InterruptedException {
        long startTime = System.currentTimeMillis();

        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);

        for (int i = 0; i < THREAD_COUNT; i++) {
            executor.submit(() -> {
                for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
                    synchronized (syncLock) {
                        counter++;
                    }
                }
                latch.countDown();
            });
        }

        latch.await();
        executor.shutdown();

        long endTime = System.currentTimeMillis();
        System.out.println("Synchronized 耗时: " + (endTime - startTime) + "ms");
        System.out.println("最终结果: " + counter);
    }

    @Test
    public void testReentrantLockPerformance() throws InterruptedException {
        counter = 0; // 重置计数器
        long startTime = System.currentTimeMillis();

        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);

        for (int i = 0; i < THREAD_COUNT; i++) {
            executor.submit(() -> {
                for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
                    reentrantLock.lock();
                    try {
                        counter++;
                    } finally {
                        reentrantLock.unlock();
                    }
                }
                latch.countDown();
            });
        }

        latch.await();
        executor.shutdown();

        long endTime = System.currentTimeMillis();
        System.out.println("ReentrantLock 耗时: " + (endTime - startTime) + "ms");
        System.out.println("最终结果: " + counter);
    }

    @Test
    public void testAtomicPerformance() throws InterruptedException {
        long startTime = System.currentTimeMillis();

        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);

        for (int i = 0; i < THREAD_COUNT; i++) {
            executor.submit(() -> {
                for (int j = 0; j < OPERATIONS_PER_THREAD; j++) {
                    atomicCounter.incrementAndGet();
                }
                latch.countDown();
            });
        }

        latch.await();
        executor.shutdown();

        long endTime = System.currentTimeMillis();
        System.out.println("AtomicInteger 耗时: " + (endTime - startTime) + "ms");
        System.out.println("最终结果: " + atomicCounter.get());
    }
}
```

### 锁的最佳实践

#### 1. 减少锁的持有时间

```java
public class LockTimeOptimization {
    private final Object lock = new Object();
    private volatile boolean dataReady = false;

    // 不好的做法：锁持有时间过长
    public void badMethod() {
        synchronized (lock) {
            // 耗时的数据库操作
            String data = fetchDataFromDatabase();

            // 耗时的网络操作
            sendDataToServer(data);

            // 简单的状态更新
            dataReady = true;
        }
    }

    // 好的做法：只锁定必要的部分
    public void goodMethod() {
        // 在锁外进行耗时操作
        String data = fetchDataFromDatabase();
        sendDataToServer(data);

        // 只锁定必要的状态更新
        synchronized (lock) {
            dataReady = true;
        }
    }
}
```

#### 2. 减少锁的粒度

```java
public class LockGranularityOptimization {
    // 不好的做法：使用粗粒度锁
    public class BadUserManager {
        private final Map<String, User> users = new HashMap<>();

        public synchronized void addUser(String id, User user) {
            users.put(id, user);
        }

        public synchronized User getUser(String id) {
            return users.get(id);
        }

        public synchronized void updateUserEmail(String id, String email) {
            User user = users.get(id);
            if (user != null) {
                user.setEmail(email);
            }
        }
    }

    // 好的做法：使用细粒度锁
    public class GoodUserManager {
        private final ConcurrentHashMap<String, User> users = new ConcurrentHashMap<>();
        private final ConcurrentHashMap<String, ReentrantLock> userLocks = new ConcurrentHashMap<>();

        public void addUser(String id, User user) {
            users.put(id, user);
            userLocks.put(id, new ReentrantLock());
        }

        public User getUser(String id) {
            return users.get(id); // ConcurrentHashMap保证读操作线程安全
        }

        public void updateUserEmail(String id, String email) {
            ReentrantLock userLock = userLocks.get(id);
            if (userLock != null) {
                userLock.lock();
                try {
                    User user = users.get(id);
                    if (user != null) {
                        user.setEmail(email);
                    }
                } finally {
                    userLock.unlock();
                }
            }
        }
    }
}
```

#### 3. 避免锁嵌套

```java
public class LockNestingAvoidance {
    private final Object lock1 = new Object();
    private final Object lock2 = new Object();

    // 不好的做法：容易导致死锁
    public void badMethod1() {
        synchronized (lock1) {
            // 一些操作
            synchronized (lock2) {
                // 嵌套锁操作
            }
        }
    }

    public void badMethod2() {
        synchronized (lock2) {
            // 一些操作
            synchronized (lock1) {
                // 嵌套锁操作，可能导致死锁
            }
        }
    }

    // 好的做法：统一锁获取顺序
    public void goodMethod1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // 按固定顺序获取锁
            }
        }
    }

    public void goodMethod2() {
        synchronized (lock1) {
            synchronized (lock2) {
                // 保持相同的锁获取顺序
            }
        }
    }

    // 更好的做法：重构避免嵌套锁
    public void bestMethod() {
        Object data1, data2;

        synchronized (lock1) {
            data1 = getDataFromResource1();
        }

        synchronized (lock2) {
            data2 = getDataFromResource2();
        }

        // 在锁外处理数据
        processData(data1, data2);
    }
}
```

### 常见面试问题

#### 1. synchronized 和 ReentrantLock 的区别

| 特性         | synchronized                | ReentrantLock             |
| ------------ | --------------------------- | ------------------------- |
| **锁类型**   | 内置锁（监视器锁）          | 显式锁                    |
| **使用方式** | 自动加锁解锁                | 手动加锁解锁              |
| **公平性**   | 非公平锁                    | 支持公平锁和非公平锁      |
| **可中断性** | 不可中断                    | 支持中断                  |
| **超时机制** | 不支持                      | 支持                      |
| **条件变量** | 只有一个条件（wait/notify） | 支持多个条件（Condition） |
| **性能**     | JVM 内置优化                | 显式实现，功能更丰富      |

#### 2. 如何解决死锁？

**死锁的四个必要条件：**

1. **互斥条件**：资源不能被多个线程同时使用
2. **请求和保持条件**：线程已获得资源，同时等待其他资源
3. **不可剥夺条件**：资源不能被强制剥夺
4. **环路等待条件**：存在循环等待链

**解决方案：**

```java
public class DeadlockSolution {

    // 1. 统一锁顺序
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public void transfer1() {
        synchronized (lock1) {
            synchronized (lock2) {
                // 转账操作
            }
        }
    }

    public void transfer2() {
        synchronized (lock1) { // 保持相同顺序
            synchronized (lock2) {
                // 转账操作
            }
        }
    }

    // 2. 使用超时机制
    private final ReentrantLock lock3 = new ReentrantLock();
    private final ReentrantLock lock4 = new ReentrantLock();

    public boolean transferWithTimeout() {
        boolean acquired1 = false;
        boolean acquired2 = false;

        try {
            acquired1 = lock3.tryLock(1, TimeUnit.SECONDS);
            if (acquired1) {
                acquired2 = lock4.tryLock(1, TimeUnit.SECONDS);
                if (acquired2) {
                    // 执行转账操作
                    return true;
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (acquired2) lock4.unlock();
            if (acquired1) lock3.unlock();
        }

        return false;
    }
}
```

#### 3. 什么是锁升级？

**锁升级过程：**

```
无锁 → 偏向锁 → 轻量级锁 → 重量级锁
```

这个优化是不可逆的，只能升级不能降级，目的是减少锁操作的开销。

---
