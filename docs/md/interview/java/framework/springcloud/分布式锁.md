# 分布式锁

## 分布式锁主流方案

-   基于数据库
-   基于 Redis
-   基于 Zookeeper
-   etcd
-   consul

1. 基于 ZooKeeper 的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景；
2. 基于 Redis 的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景。

## 分布式锁场景

-   商城秒杀
-   抢优惠券
-   接口幂等性校验

## Redis 实现分布式锁的 7 种方案

-   方案一：SETNX + EXPIRE

```java
if（jedis.setnx(key_resource_id,lock_value) == 1）{ //加锁
    expire（key_resource_id，100; //设置过期时间
    try {
        //业务请求
    } catch() {
    } finally {
        jedis.del(key_resource_id); //释放锁
    }
}
```

setnx 和 expire 两个命令分开，不是原子操作，如果执行完 setnx 操作后进程挂掉，那么锁将会一直存在，其他线程永远获取不了锁

-   方案二：SETNX + value 值是（系统时间+过期时间）

```java
long expires = System.currentTimeMillis() + expireTime; //系统时间 + 过期时间
String expiresStr = String.valueOf(expires);

// 如果当前锁不存在，返回加锁成功
if (jedis.setnx(key_resource_id, expiresStr) == 1) {
    return true;
}
// 如果锁已经存在，获取锁的过期时间
String currentValueStr = jedis.get(key_resource_id);

// 如果获取到的过期时间，小于系统当前时间，表示已经过期
if (currentValueStr != null && Long.parseLong(currentValueStr) < System.currentTimeMillis()) {

    // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间
    String oldValueStr = jedis.getSet(key_resource_id, expiresStr);

    if (oldValueStr != null && oldValueStr.equals(currentValueStr)) {
        // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁
        return true;
    }
}

//其他情况，均返回加锁失败
return false;
```

-   -   过期时间是客户端生成的，在分布式环境中需要保障每个客户端的时间同步
    -   jedis.getSet 可能出现锁覆盖的情况

-   方案三：使用 Lua 脚本(包含 SETNX + EXPIRE 两条指令)

```java
String lua_scripts = "if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then" +
    " redis.call('expire',KEYS[1],ARGV[2]) return 1 else return 0 end";

Object result = jedis.eval(lua_scripts, Collections.singletonList(key_resource_id), Collections.singletonList(values));
//判断是否成功
return result.equals(1L);
```

-   方案四：SET 的扩展命令（SET EX PX NX）

-   -   **SET key value [EX seconds] [PX milliseconds] [NX|XX]**
    -   **NX：**表示 key 不存在的时候，才能 set 成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取
    -   **EX seconds：**设定 key 的过期时间，时间单位是秒
    -   **PX milliseconds：**设定 key 的过期时间，单位为毫秒
    -   **XX：**仅当 key 存在时设置值

```java
@RequestMapping(value = "/test")
public String test(){
    String lockKey = "product_001";

    try{
        Boolean result = stringRedisTemplate.opsForValue()
            .setIfAbsent(lockKey, "testlock", 10, TimeUnit.SECONDS);
        if(!result){
            // 代表已经加锁了
            return "error_code";
        }
        // 从redis 中拿当前库存的值
        int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
        if(stock > 0){
            int realStock = stock - 1;
            stringRedisTemplate.opsForValue().set("stock", realStock + "");
            System.out.println("扣减成功，剩余库存：" + realStock);
        }else{
            System.out.println("扣减失败，库存不足");
        }
    } finally {
        // 释放锁
        stringRedisTemplate.delete(lockKey);
    }

    return "end";
}
```

-   -   存在超时时间过短，业务代码未执行完的情况
    -   锁被其他线程误删。线程 a 执行完后，去释放锁。但是它不知道当前的锁可能是线程 b 持有的（线程 a 去释放锁时，有可能过期时间已经到了，此时线程 b 进来占有了锁）。那线程 a 就把线程 b 的锁释放掉了，但是线程 b 临界区业务代码可能都还没执行完呢

-   方案五：SET EX PX NX + 校验唯一随机值，再释放锁

```java
if（jedis.set(key_resource_id, uni_request_id, "NX", "EX", 100s) == 1）{ //加锁
    try {
        // 业务处理
    }catch(){
    }
    finally {
        // 判断是不是当前线程加的锁,是才释放，非原子
        if (uni_request_id.equals(jedis.get(key_resource_id))) {
            jedis.del(lockKey); // 释放锁
        }
    }
}
```

为了更严谨，一般也是用 lua 脚本代替

```lua
if redis.call('get',KEYS[1]) == ARGV[1] then
  return redis.call('del',KEYS[1])
else
  return 0
end;
```

-   方案六：单机分布式锁 Redisson

-   方案七：多机分布式锁 Redlock + Redisson

### 单机 Redisson 分布式锁

#### 引入依赖

```xml
<dependency>
  <groupId>org.redisson</groupId>
  <artifactId>redisson</artifactId>
  <version>xxx</version>
</dependency>
```

#### 初始化客户端

```java
@Bean
public RedissonClient redisson(){
    // 单机模式
    Config config = new Config();
    config.useSingleServer().setAddress("redis://127.0.0.1:6379").setDatabase(0);
    return Redisson.create(config);
}
```

#### 实现分布式锁

```java
@RestController
public class IndexController {

    @Autowired
    private RedissonClient redisson;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    /**
     * 模拟下单减库存的场景
     *
     * @return
     */
    @RequestMapping(value = "/test")
    public String test() {
        String lockKey = "product_001";
        // 1.获取锁对象
        RLock redissonLock = redisson.getLock(lockKey);
        try {
            // 2.加锁  等价于 setIfAbsent(lockKey,"testlock",10,TimeUnit.SECONDS);
            redissonLock.lock();
            // 从redis 中拿当前库存的值
            int stock = Integer.parseInt(stringRedisTemplate.opsForValue().get("stock"));
            if (stock > 0) {
                int realStock = stock - 1;
                stringRedisTemplate.opsForValue().set("stock", realStock + "");
                System.out.println("扣减成功，剩余库存：" + realStock);
            } else {
                System.out.println("扣减失败，库存不足");
            }
        } finally {
            // 3.释放锁
            redissonLock.unlock();
        }
        return "end";
    }
}
```

Redisson 的 lock 方法最终执行的是 lua 脚本

```lua
-- exists 判断 key 是否存在
if (redis.call('exists', KEYS[1]) == 0) then
    -- 设置 key
    redis.call('hset', KEYS[1], ARGV[2], 1);
    -- 追加过期时间
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;
```

lua 脚本在 redis 中执行时，会被当做一条命令，所以能够保证原子性，Redisson 中大量使用了 lua 脚本

### 多机分布式锁 Redlock + Redisson

**org.redisson.RedissonMultiLock** 对象可实现 Redlock 锁算法，将多个 RLock 对象划分为一组并且将它们当做一个锁来处理，每个 RLock 对象可以属于不同的 Redisson 实例

```java
RLock lock1 = redissonInstance1.getLock("lock1");
RLock lock2 = redissonInstance2.getLock("lock2");
RLock lock3 = redissonInstance3.getLock("lock3");


RedissonMultiLock lock = new RedissonMultiLock(lock1, lock2, lock3);
// locks: lock1 lock2 lock3
lock.lock();
...
lock.unlock();
```

**RedissonRedLock extends** **RedissonMultiLock**

```java
Config config1 = new Config();
config1.useSingleServer().setAddress("redis://172.0.0.1:5378").setDatabase(0);
RedissonClient redissonClient1 = Redisson.create(config1);

Config config2 = new Config();
config2.useSingleServer().setAddress("redis://172.0.0.1:5379").setDatabase(0);
RedissonClient redissonClient2 = Redisson.create(config2);

Config config3 = new Config();
config3.useSingleServer().setAddress("redis://172.0.0.1:5380").setDatabase(0);
RedissonClient redissonClient3 = Redisson.create(config3);

/**
* 获取多个 RLock 对象
*/
RLock lock1 = redissonInstance1.getLock("lockKey");
RLock lock2 = redissonInstance2.getLock("lockKey");
RLock lock3 = redissonInstance3.getLock("lockKey");

/**
* 根据多个 RLock 对象构建 RedissonRedLock
*/
RedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);

try {
    /**
    * 尝试获取锁
    * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败
    * leaseTime   锁的持有时间，超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）
    */
    boolean res = redLock.tryLock((long)waitTimeout, (long)leaseTime, TimeUnit.SECONDS);
    if (res) {
        //成功获得锁，在这里处理业务
    }
} catch (Exception e) {
    throw new RuntimeException("aquire lock fail");
} finally {
    //解锁
    redLock.unlock();
}
```

## Zookeeper 分布式锁

ZooKeeper 实现的分布式锁，性能并不太高，在高性能高并发的场景下不建议使用分布式锁

### 三种方案

-   临时节点方案：缺点是每次竞争锁，都只有一个线程拿到锁，会导致大量线程同时阻塞抢锁，性能低甚至宕机
-   临时顺序节点方案：临时顺序节点与临时节点不同的是产生的节点是有序的
-   Curator 分布式锁工具中的共享可重入锁：全局同步锁，在同一时间不会有两个客户端持有一个锁

### 临时顺序节点方案

**排队取号**

**公平可重入锁**，**Zookeeper 临时顺序节点**，递增有序性，可以确保锁的公平，节点监听机制，可以保障占有锁的传递有序而且高效

分布式锁的算法

-   一把分布式锁通常使用一个 Znode 节点表示；如果锁对应的 Znode 节点不存在，首先创建 Znode 节点。这里假设为“/test/lock”，代表了一把需要创建的分布式锁
-   抢占锁的所有客户端，使用锁的 Znode 节点的子节点列表来表示；如果某个客户端需要占用锁，则在“/test/lock”下创建一个临时有序的子节点。所有临时有序子节点，尽量共用一个有意义的子节点前缀。比如“/test/lock/seq-”
-   判定客户端是否占有锁，客户端创建子节点后，需要进行判断：自己创建的子节点，是否为当前子节点列表中序号最小的子节点。如果是，则认为加锁成功；如果不是，则监听前一个 Znode 子节点变更消息，等待前一个节点释放锁。
-   一旦队列中的后面的节点，获得前一个子节点变更通知，则开始进行判断，判断自己是否为当前子节点列表中序号最小的子节点，如果是，则认为加锁成功；如果不是，则持续监听，一直到获得锁。
-   获取锁后，开始处理业务流程。完成业务流程后，删除自己的对应的子节点，完成释放锁的工作，以方面后继节点能捕获到节点变更通知，获得分布式锁。

#### Lock 接口

定义了一个锁的接口 Lock，两个抽象方法：一个加锁方法，一个解锁方法

```java
public interface Lock {
    /**
     * 加锁方法
     *
     * @return 是否成功加锁
     */
    boolean lock() throws Exception;

    /**
     * 解锁方法
     *
     * @return 是否成功解锁
     */
    boolean unlock();
}
```

#### 锁实现

**lock()**

-   首先尝试着去加锁，如果加锁失败就去等待，然后再重复

```java
public class ZkLock implements Lock {
    //ZkLock的节点链接
    private static final String ZK_PATH = "/test/lock";
    private static final String LOCK_PREFIX = ZK_PATH + "/";
    private static final long WAIT_TIME = 1000;

    //Zk客户端
    CuratorFramework client = null;

    private String locked_short_path = null;
    private String locked_path = null;
    private String prior_path = null;
    final AtomicInteger lockCount = new AtomicInteger(0);

    private Thread thread;

    public ZkLock() {
        ZKclient.instance.init();
        synchronized (ZKclient.instance) {
            if (!ZKclient.instance.isNodeExist(ZK_PATH)) {
                ZKclient.instance.createNode(ZK_PATH, null);
            }
        }
        client = ZKclient.instance.getClient();
    }

    @Override
    public boolean lock() {
		//可重入，确保同一线程，可以重复加锁
        synchronized (this) {
            if (lockCount.get() == 0) {
                thread = Thread.currentThread();
                lockCount.incrementAndGet();
            } else {
                if (!thread.equals(Thread.currentThread())) {
                    return false;
                }
                lockCount.incrementAndGet();
                return true;
            }
        }

        try {
            boolean locked = false;
			//首先尝试着去加锁
            locked = tryLock();

            if (locked) {
                return true;
            }
            //如果加锁失败就去等待
            while (!locked) {

                await();

                //获取等待的子节点列表
                List<String> waiters = getWaiters();
				//判断，是否加锁成功
                if (checkLocked(waiters)) {
                    locked = true;
                }
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            unlock();
        }

        return false;
    }
}
```

**tryLock()**

-   创建临时顺序节点，并且保存自己的节点路径
-   判断是否是第一个，如果是第一个，则加锁成功。如果不是，就找到前一个 Znode 节点，并且保存其路径到 prior_path

```java
/**
 * 尝试加锁
 * @return 是否加锁成功
 * @throws Exception 异常
 */
private boolean tryLock() throws Exception {
    //创建临时Znode
    locked_path = ZKclient.instance
            .createEphemeralSeqNode(LOCK_PREFIX);
    //然后获取所有节点
    List<String> waiters = getWaiters();

    if (null == locked_path) {
        throw new Exception("zk error");
    }
    //取得加锁的排队编号
    locked_short_path = getShortPath(locked_path);

    //获取等待的子节点列表，判断自己是否第一个
    if (checkLocked(waiters)) {
        return true;
    }

    // 判断自己排第几个
    int index = Collections.binarySearch(waiters, locked_short_path);
    if (index < 0) { // 网络抖动，获取到的子节点列表里可能已经没有自己了
        throw new Exception("节点没有找到: " + locked_short_path);
    }

    //如果自己没有获得锁，则要监听前一个节点
    prior_path = ZK_PATH + "/" + waiters.get(index - 1);

    return false;
}

private String getShortPath(String locked_path) {

    int index = locked_path.lastIndexOf(ZK_PATH + "/");
    if (index >= 0) {
        index += ZK_PATH.length() + 1;
        return index <= locked_path.length() ? locked_path.substring(index) : "";
    }
    return null;
}
```

**checkLocked()**

-   判断是否可以持有锁，当前创建的节点，是否在上一步获取到的子节点列表的第一个位置

```java
private boolean checkLocked(List<String> waiters) {

    //节点按照编号，升序排列
    Collections.sort(waiters);

    // 如果是第一个，代表自己已经获得了锁
    if (locked_short_path.equals(waiters.get(0))) {
        log.info("成功的获取分布式锁,节点为{}", locked_short_path);
        return true;
    }
    return false;
}
```

**await()**

-   监听前一个 ZNode 节点（prior_path 成员）的删除事件，可以使用两种监听方式
-   Watcher 订阅
-   TreeCache 订阅

```java
private void await() throws Exception {

    if (null == prior_path) {
        throw new Exception("prior_path error");
    }

    final CountDownLatch latch = new CountDownLatch(1);

    //订阅比自己次小顺序节点的删除事件
    Watcher w = new Watcher() {
        @Override
        public void process(WatchedEvent watchedEvent) {
            System.out.println("监听到的变化 watchedEvent = " + watchedEvent);
            log.info("[WatchedEvent]节点删除");

            latch.countDown();
        }
    };

    client.getData().usingWatcher(w).forPath(prior_path);

/*
    //订阅比自己次小顺序节点的删除事件
    TreeCache treeCache = new TreeCache(client, prior_path);
    TreeCacheListener l = new TreeCacheListener() {
        @Override
        public void childEvent(CuratorFramework client,
                                TreeCacheEvent event) throws Exception {
            ChildData data = event.getData();
            if (data != null) {
                switch (event.getType()) {
                    case NODE_REMOVED:
                        log.debug("[TreeCache]节点删除, path={}, data={}",
                                data.getPath(), data.getData());

                        latch.countDown();
                        break;
                    default:
                        break;
                }
            }
        }
    };

    treeCache.getListenable().addListener(l);
    treeCache.start();
*/
    latch.await(WAIT_TIME, TimeUnit.SECONDS);
}
```

**可重入**

只需要保障同一个线程进入加锁的代码，可以重复加锁成功即可。在 lock 方法前面加上可重入的判断逻辑

```java
@Override
public boolean lock() {

    //可重入的判断
    synchronized (this) {
        if (lockCount.get() == 0) {
            thread = Thread.currentThread();
            lockCount.incrementAndGet();
        } else {
            if (!thread.equals(Thread.currentThread())) {
                return false;
            }
            lockCount.incrementAndGet();
            return true;
        }
    }
}
```

为了变成可重入，在代码中增加了一个加锁的计数器 lockCount，计算重复加锁的次数。如果是同一个线程加锁，只需要增加次数，直接返回，表示加锁成功。

#### 解锁

**unLock()**，表示释放锁，释放锁主要有两个工作

-   减少重入锁的计数，如果最终的值不是 0，直接返回，表示成功的释放了一次
-   如果计数器为 0，移除 Watchers 监听器，并且删除创建的 Znode 临时节点

```java
/**
 * 释放锁
 *
 * @return 是否成功释放锁
 */
@Override
public boolean unlock() {
	//只有加锁的线程，能够解锁
    if (!thread.equals(Thread.currentThread())) {
        return false;
    }
	//减少可重入的计数
    int newLockCount = lockCount.decrementAndGet();
	//计数不能小于0
    if (newLockCount < 0) {
        throw new IllegalMonitorStateException("Lock count has gone negative for lock: " + locked_path);
    }
	//如果计数不为0，直接返回
    if (newLockCount != 0) {
        return true;
    }
    //删除临时节点
    try {
        if (ZKclient.instance.isNodeExist(locked_path)) {
            client.delete().forPath(locked_path);
        }
    } catch (Exception e) {
        e.printStackTrace();
        return false;
    }

    return true;
}
```

#### 测试

```java
prviate int count = 0;

@Test
public void testLock() throws InterruptedException {
    for (int i = 0; i < 10; i++) {
        FutureTaskScheduler.add(() -> {
            //创建锁
            ZkLock lock = new ZkLock();
            lock.lock();
//每条线程，执行10次累加
            for (int j = 0; j < 10; j++) {
//公共的资源变量累加
                count++;
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("count = " + count);
            //释放锁
            lock.unlock();

        });
    }

    Thread.sleep(Integer.MAX_VALUE);
}
```

### Curator 分布式锁 InterProcessMutex

```java
prviate int count = 0;

@Test
public void testzkMutex() throws InterruptedException {

    CuratorFramework client = ZKclient.instance.getClient();
    final InterProcessMutex zkMutex = new InterProcessMutex(client, "/mutex");

    for (int i = 0; i < 10; i++) {
        FutureTaskScheduler.add(() -> {

            try {
                //获取互斥锁
                zkMutex.acquire();

                for (int j = 0; j < 10; j++) {
					//公共的资源变量累加
                    count++;
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.info("count = " + count);
                //释放互斥锁
                zkMutex.release();

            } catch (Exception e) {
                e.printStackTrace();
            }

        });
    }

    Thread.sleep(Integer.MAX_VALUE);
}
```

## etcd 分布式锁

etcd 是一个分布式键值对存储，设计用来可靠而快速的保存关键数据并提供访问，etcd 分布式锁并不是 etcd server 对外提供一个功能 api，而是基于 etcd 的各种特性（lease、watch、mvcc 等）集成的一个工具。

## Consul 分布式锁

Consul 的分布式锁主要利用 Key/Value 存储 API 中的 acquire 和 release 操作来实现。acquire 和 release 操作是类似 Check-And-Set 的操作

# 分布式锁技术详解

## 第一章 分布式锁概述

### 1.1 什么是分布式锁

分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现。在分布式系统中，当多个节点需要访问共享资源时，分布式锁可以保证在同一时刻只有一个节点能够获得锁并访问资源，从而避免并发访问导致的数据不一致问题。

**核心特征：**

-   **互斥性**：在任意时刻，只有一个客户端能持有锁
-   **安全性**：锁只能被持有该锁的客户端删除，不能被其他客户端删除
-   **避免死锁**：获取锁的客户端因为某些原因而没有主动释放锁，也要能保证锁可以被释放
-   **容错性**：只要大部分节点正常运行，客户端就可以加锁和解锁

### 1.2 分布式锁与本地锁的区别

| 特性     | 本地锁                      | 分布式锁                 |
| -------- | --------------------------- | ------------------------ |
| 作用范围 | 单个 JVM 内                 | 跨 JVM、跨服务器         |
| 实现方式 | synchronized、ReentrantLock | Redis、ZooKeeper、数据库 |
| 性能开销 | 低                          | 相对较高                 |
| 复杂度   | 简单                        | 复杂                     |
| 可用性   | 依赖 JVM                    | 依赖外部存储             |

### 1.3 分布式锁应用场景

#### 1.3.1 防止重复操作

```java
// 典型场景：防止重复下单
@Service
public class OrderService {

    @Autowired
    private DistributedLock distributedLock;

    public void createOrder(String userId, String productId) {
        String lockKey = "order:create:" + userId + ":" + productId;

        if (distributedLock.tryLock(lockKey, 30, TimeUnit.SECONDS)) {
            try {
                // 检查是否已经存在订单
                if (orderExists(userId, productId)) {
                    throw new BusinessException("订单已存在，请勿重复下单");
                }

                // 创建订单
                createOrderInternal(userId, productId);

            } finally {
                distributedLock.unlock(lockKey);
            }
        } else {
            throw new BusinessException("系统繁忙，请稍后重试");
        }
    }
}
```

#### 1.3.2 资源互斥访问

-   **商城秒杀**：控制库存扣减的并发访问
-   **抢优惠券**：防止超发优惠券
-   **接口幂等性校验**：保证接口调用的幂等性
-   **定时任务**：防止多个节点同时执行定时任务

#### 1.3.3 数据一致性保证

```java
// 典型场景：库存扣减
@Service
public class InventoryService {

    public boolean reduceStock(String productId, int quantity) {
        String lockKey = "inventory:" + productId;

        return distributedLock.execute(lockKey, 10, TimeUnit.SECONDS, () -> {
            // 获取当前库存
            int currentStock = getCurrentStock(productId);

            if (currentStock >= quantity) {
                // 扣减库存
                updateStock(productId, currentStock - quantity);
                return true;
            } else {
                return false;
            }
        });
    }
}
```

### 1.4 分布式锁主流实现方案

#### 1.4.1 技术方案对比

| 方案          | 优点                   | 缺点                             | 适用场景                       |
| ------------- | ---------------------- | -------------------------------- | ------------------------------ |
| **数据库**    | 理解简单，易于实现     | 性能差，单点故障                 | 低并发场景                     |
| **Redis**     | 性能高，支持过期时间   | 可能丢失锁，复杂场景需要额外处理 | 高并发，对可靠性要求不是特别高 |
| **ZooKeeper** | 可靠性高，支持阻塞等待 | 性能相对较低，运维复杂           | 对可靠性要求高的场景           |
| **etcd**      | 强一致性，性能好       | 学习成本高，生态相对较小         | 云原生环境                     |
| **Consul**    | 功能丰富，支持健康检查 | 复杂度高                         | 微服务环境                     |

#### 1.4.2 选型建议

**高性能场景**：推荐 Redis 分布式锁

-   适用于电商秒杀、高频交易等场景
-   能够承受极高的并发量
-   可以通过集群部署提高可用性

**高可靠场景**：推荐 ZooKeeper 分布式锁

-   适用于金融支付、核心业务等场景
-   强一致性保证
-   天然支持阻塞等待和公平锁

**云原生场景**：推荐 etcd 分布式锁

-   适用于 Kubernetes 环境
-   强一致性和高性能的平衡
-   良好的运维工具支持

## 第二章 Redis 分布式锁详解

### 2.1 Redis 分布式锁演进历程

Redis 分布式锁经历了从简单到复杂、从不完善到相对完善的演进过程。理解这个演进过程有助于我们深入掌握分布式锁的核心原理。

### 2.2 方案演进分析

#### 2.2.1 方案一：SETNX + EXPIRE（存在原子性问题）

**实现方式：**

```java
public class SimpleRedisLock {

    private Jedis jedis;

    public boolean lock(String key, String value, int expireTime) {
        // 第一步：尝试加锁
        if (jedis.setnx(key, value) == 1) {
            // 第二步：设置过期时间
            jedis.expire(key, expireTime);
            try {
                // 业务逻辑
                return true;
            } finally {
                // 第三步：释放锁
                jedis.del(key);
            }
        }
        return false;
    }
}
```

**存在问题：**

-   **原子性问题**：setnx 和 expire 是两个独立命令，不是原子操作
-   **死锁风险**：如果在 setnx 成功后，expire 执行前进程挂掉，锁将永远存在
-   **误删问题**：可能删除其他线程持有的锁

**解决思路：**
需要保证加锁和设置过期时间的原子性

#### 2.2.2 方案二：SETNX + 时间戳（存在时钟同步问题）

**实现方式：**

```java
public class TimestampRedisLock {

    private Jedis jedis;

    public boolean lock(String key, long expireTime) {
        long expires = System.currentTimeMillis() + expireTime;
        String expiresStr = String.valueOf(expires);

        // 如果当前锁不存在，返回加锁成功
        if (jedis.setnx(key, expiresStr) == 1) {
            return true;
        }

        // 如果锁已经存在，获取锁的过期时间
        String currentValueStr = jedis.get(key);

        // 如果获取到的过期时间，小于系统当前时间，表示已经过期
        if (currentValueStr != null && Long.parseLong(currentValueStr) < System.currentTimeMillis()) {
            // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间
            String oldValueStr = jedis.getSet(key, expiresStr);

            // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁
            if (oldValueStr != null && oldValueStr.equals(currentValueStr)) {
                return true;
            }
        }

        return false;
    }
}
```

**存在问题：**

-   **时钟同步问题**：过期时间由客户端生成，分布式环境中时钟可能不同步
-   **锁覆盖问题**：getSet 操作可能导致锁被意外覆盖

#### 2.2.3 方案三：Lua 脚本保证原子性

**实现方式：**

```java
public class LuaRedisLock {

    private Jedis jedis;

    // 加锁Lua脚本
    private static final String LOCK_SCRIPT =
        "if redis.call('setnx', KEYS[1], ARGV[1]) == 1 then " +
        "    redis.call('expire', KEYS[1], ARGV[2]) " +
        "    return 1 " +
        "else " +
        "    return 0 " +
        "end";

    // 释放锁Lua脚本
    private static final String UNLOCK_SCRIPT =
        "if redis.call('get', KEYS[1]) == ARGV[1] then " +
        "    return redis.call('del', KEYS[1]) " +
        "else " +
        "    return 0 " +
        "end";

    public boolean lock(String key, String value, int expireTime) {
        Object result = jedis.eval(LOCK_SCRIPT,
            Collections.singletonList(key),
            Arrays.asList(value, String.valueOf(expireTime)));
        return "1".equals(result.toString());
    }

    public boolean unlock(String key, String value) {
        Object result = jedis.eval(UNLOCK_SCRIPT,
            Collections.singletonList(key),
            Collections.singletonList(value));
        return "1".equals(result.toString());
    }
}
```

**改进点：**

-   使用 Lua 脚本保证加锁和设置过期时间的原子性
-   释放锁时校验锁的所有者，避免误删

#### 2.2.4 方案四：SET EX PX NX 命令

**实现方式：**

```java
@Service
public class ModernRedisLock {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    public boolean processWithLock(String lockKey, Supplier<Boolean> business) {
        String lockValue = UUID.randomUUID().toString();

        try {
            // 使用SET命令的扩展参数，原子性加锁
            Boolean result = stringRedisTemplate.opsForValue()
                .setIfAbsent(lockKey, lockValue, 10, TimeUnit.SECONDS);

            if (!Boolean.TRUE.equals(result)) {
                return false;
            }

            // 执行业务逻辑
            return business.get();

        } finally {
            // 使用Lua脚本安全释放锁
            releaseLock(lockKey, lockValue);
        }
    }

    private void releaseLock(String lockKey, String lockValue) {
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "    return redis.call('del', KEYS[1]) " +
            "else " +
            "    return 0 " +
            "end";

        stringRedisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(lockKey), lockValue);
    }
}
```

**命令说明：**

-   **SET key value [EX seconds] [PX milliseconds] [NX|XX]**
-   **NX**：仅当 key 不存在时才设置
-   **EX seconds**：设置秒级过期时间
-   **PX milliseconds**：设置毫秒级过期时间
-   **XX**：仅当 key 存在时才设置

**仍存在问题：**

-   **锁超时问题**：业务执行时间超过锁过期时间
-   **误删问题**：虽然加了校验，但仍可能在极端情况下误删

#### 2.2.5 方案五：增强版 - 锁续期机制

**实现方式：**

```java
@Component
public class AdvancedRedisLock {

    @Autowired
    private StringRedisTemplate redisTemplate;

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    public <T> T executeWithLock(String lockKey, long expireTime, TimeUnit timeUnit,
                                Supplier<T> business) {
        String lockValue = UUID.randomUUID().toString();
        String threadId = Thread.currentThread().getName();

        try {
            // 加锁
            if (!tryLock(lockKey, lockValue, expireTime, timeUnit)) {
                throw new RuntimeException("获取锁失败");
            }

            // 启动锁续期任务
            ScheduledFuture<?> renewalTask = startLockRenewal(lockKey, lockValue, expireTime, timeUnit);

            try {
                // 执行业务逻辑
                return business.get();
            } finally {
                // 停止续期任务
                renewalTask.cancel(true);
            }

        } finally {
            // 释放锁
            releaseLock(lockKey, lockValue);
        }
    }

    private boolean tryLock(String lockKey, String lockValue, long expireTime, TimeUnit timeUnit) {
        Boolean result = redisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, expireTime, timeUnit);
        return Boolean.TRUE.equals(result);
    }

    private ScheduledFuture<?> startLockRenewal(String lockKey, String lockValue,
                                              long expireTime, TimeUnit timeUnit) {
        return scheduler.scheduleAtFixedRate(() -> {
            try {
                renewLock(lockKey, lockValue, expireTime, timeUnit);
            } catch (Exception e) {
                log.error("锁续期失败: " + lockKey, e);
            }
        }, expireTime / 3, expireTime / 3, timeUnit);
    }

    private void renewLock(String lockKey, String lockValue, long expireTime, TimeUnit timeUnit) {
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "    return redis.call('expire', KEYS[1], ARGV[2]) " +
            "else " +
            "    return 0 " +
            "end";

        Long seconds = timeUnit.toSeconds(expireTime);
        redisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(lockKey), lockValue, seconds.toString());
    }

    private void releaseLock(String lockKey, String lockValue) {
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "    return redis.call('del', KEYS[1]) " +
            "else " +
            "    return 0 " +
            "end";

        redisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(lockKey), lockValue);
    }
}
```

**改进点：**

-   **自动续期**：定期检查并延长锁的过期时间
-   **安全释放**：确保只有锁的持有者才能释放锁
-   **函数式接口**：提供更友好的 API

### 2.3 方案六：Redisson 单机分布式锁

Redisson 是一个在 Redis 基础上实现的 Java 分布式对象和服务框架，提供了完善的分布式锁实现。

#### 2.3.1 基本使用

**Maven 依赖：**

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.20.1</version>
</dependency>
```

**配置类：**

```java
@Configuration
public class RedissonConfig {

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
            .setAddress("redis://127.0.0.1:6379")
            .setDatabase(0)
            .setConnectionPoolSize(10)
            .setConnectionMinimumIdleSize(2);
        return Redisson.create(config);
    }
}
```

**使用示例：**

```java
@RestController
public class OrderController {

    @Autowired
    private RedissonClient redissonClient;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @PostMapping("/order/create")
    public ResponseEntity<String> createOrder(@RequestParam String productId) {
        String lockKey = "product_stock:" + productId;
        RLock lock = redissonClient.getLock(lockKey);

        try {
            // 尝试加锁，最多等待10秒，锁持有时间30秒
            boolean locked = lock.tryLock(10, 30, TimeUnit.SECONDS);
            if (!locked) {
                return ResponseEntity.status(HttpStatus.TOO_MANY_REQUESTS)
                    .body("系统繁忙，请稍后重试");
            }

            // 执行业务逻辑
            int stock = Integer.parseInt(
                stringRedisTemplate.opsForValue().get("stock:" + productId));

            if (stock > 0) {
                int newStock = stock - 1;
                stringRedisTemplate.opsForValue().set("stock:" + productId, String.valueOf(newStock));
                return ResponseEntity.ok("下单成功，剩余库存：" + newStock);
            } else {
                return ResponseEntity.badRequest().body("库存不足");
            }

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("系统异常");
        } finally {
            // 释放锁
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

#### 2.3.2 Redisson 锁的核心特性

**1. 自动续期（Watch Dog 机制）**

```java
public class RedissonLockDemo {

    @Autowired
    private RedissonClient redissonClient;

    public void demonstrateWatchDog() {
        RLock lock = redissonClient.getLock("demo-lock");

        try {
            // 不指定过期时间，启用看门狗机制
            lock.lock();

            // 模拟长时间业务处理
            Thread.sleep(60000); // 60秒

            // 看门狗会每10秒（默认30秒/3）检查一次
            // 如果锁仍然被当前线程持有，则续期到30秒

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            lock.unlock();
        }
    }
}
```

**2. 可重入锁**

```java
public void demonstrateReentrant() {
    RLock lock = redissonClient.getLock("reentrant-lock");

    try {
        lock.lock();
        System.out.println("第一次获取锁");

        // 同一线程可以再次获取锁
        lock.lock();
        System.out.println("第二次获取锁");

    } finally {
        // 需要调用相同次数的unlock
        lock.unlock();
        lock.unlock();
    }
}
```

**3. 公平锁**

```java
public void demonstrateFairLock() {
    RLock fairLock = redissonClient.getFairLock("fair-lock");

    try {
        // 公平锁保证按照请求顺序获取锁
        fairLock.lock();
        // 业务逻辑
    } finally {
        fairLock.unlock();
    }
}
```

#### 2.3.3 Redisson 底层实现原理

**Lua 脚本分析：**

```lua
-- Redisson加锁脚本
if (redis.call('exists', KEYS[1]) == 0) then
    redis.call('hset', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;

if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then
    redis.call('hincrby', KEYS[1], ARGV[2], 1);
    redis.call('pexpire', KEYS[1], ARGV[1]);
    return nil;
end;

return redis.call('pttl', KEYS[1]);
```

**脚本解析：**

1. 检查锁是否存在，如果不存在则创建锁
2. 使用 Hash 结构存储锁信息，字段为线程 ID，值为重入次数
3. 如果是同一线程重入，则增加重入计数
4. 如果锁被其他线程持有，返回剩余过期时间

### 2.4 方案七：Redlock 多机分布式锁

#### 2.4.1 Redlock 算法原理

Redlock 是 Redis 官方提供的分布式锁算法，用于在多个 Redis 实例之间实现分布式锁，提高锁的可靠性。

**算法步骤：**

1. 获取当前时间戳
2. 依次尝试从 N 个 Redis 实例获取锁
3. 只有当获取锁的实例数量大于 N/2+1，且总耗时小于锁的有效期时，才认为获取锁成功
4. 如果获取锁失败，则释放所有已获取的锁

#### 2.4.2 Redisson 实现 Redlock

**配置多个 Redis 实例：**

```java
@Configuration
public class RedlockConfig {

    @Bean
    public RedissonRedLock redissonRedLock() {
        Config config1 = new Config();
        config1.useSingleServer().setAddress("redis://172.0.0.1:6379");
        RedissonClient redissonClient1 = Redisson.create(config1);

        Config config2 = new Config();
        config2.useSingleServer().setAddress("redis://172.0.0.1:6380");
        RedissonClient redissonClient2 = Redisson.create(config2);

        Config config3 = new Config();
        config3.useSingleServer().setAddress("redis://172.0.0.1:6381");
        RedissonClient redissonClient3 = Redisson.create(config3);

        RLock lock1 = redissonClient1.getLock("distributed-lock");
        RLock lock2 = redissonClient2.getLock("distributed-lock");
        RLock lock3 = redissonClient3.getLock("distributed-lock");

        return new RedissonRedLock(lock1, lock2, lock3);
    }
}
```

**使用 Redlock：**

```java
@Service
public class RedlockService {

    @Autowired
    private RedissonRedLock redissonRedLock;

    public boolean executeWithRedlock(String businessId, Supplier<Boolean> business) {
        try {
            // 尝试获取锁，等待时间100ms，锁持有时间10秒
            boolean acquired = redissonRedLock.tryLock(100, 10000, TimeUnit.MILLISECONDS);

            if (acquired) {
                try {
                    return business.get();
                } finally {
                    redissonRedLock.unlock();
                }
            } else {
                log.warn("获取Redlock失败: {}", businessId);
                return false;
            }

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Redlock操作被中断: {}", businessId, e);
            return false;
        }
    }
}
```

### 2.5 Redis 分布式锁最佳实践

#### 2.5.1 锁超时时间设置

```java
@Component
public class LockTimeoutStrategy {

    // 根据业务类型设置不同的超时时间
    public long getExpireTime(String businessType) {
        switch (businessType) {
            case "payment":
                return 30; // 支付业务30秒
            case "inventory":
                return 5;  // 库存操作5秒
            case "batch":
                return 300; // 批处理5分钟
            default:
                return 10; // 默认10秒
        }
    }
}
```

#### 2.5.2 锁粒度控制

```java
@Service
public class LockGranularityDemo {

    // 粗粒度锁 - 性能较差但实现简单
    public void processOrderCoarse(String orderId) {
        String lockKey = "order:process";
        // 所有订单处理都会竞争这一把锁
    }

    // 细粒度锁 - 性能较好但需要注意死锁
    public void processOrderFine(String orderId) {
        String lockKey = "order:process:" + orderId;
        // 每个订单有独立的锁
    }

    // 中等粒度锁 - 平衡性能和复杂度
    public void processOrderModerate(String orderId, String userId) {
        String lockKey = "order:process:user:" + userId;
        // 按用户维度加锁
    }
}
```

#### 2.5.3 异常处理策略

```java
@Component
public class LockExceptionHandler {

    public <T> T executeWithLockSafely(String lockKey, Supplier<T> business, T defaultValue) {
        RLock lock = redissonClient.getLock(lockKey);

        try {
            if (lock.tryLock(3, 10, TimeUnit.SECONDS)) {
                try {
                    return business.get();
                } catch (Exception e) {
                    log.error("业务执行异常: " + lockKey, e);
                    // 根据业务需要决定是否抛出异常或返回默认值
                    return defaultValue;
                }
            } else {
                log.warn("获取锁超时: {}", lockKey);
                return defaultValue;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("锁操作被中断: {}", lockKey, e);
            return defaultValue;
        } finally {
            try {
                if (lock.isHeldByCurrentThread()) {
                    lock.unlock();
                }
            } catch (Exception e) {
                log.error("释放锁异常: {}", lockKey, e);
            }
        }
    }
}
```

## 第三章 ZooKeeper 分布式锁详解

### 3.1 ZooKeeper 分布式锁原理

ZooKeeper 是一个分布式协调服务，基于其强一致性和临时顺序节点的特性，可以实现高可靠的分布式锁。

#### 3.1.1 ZooKeeper 核心特性

**1. 强一致性**

-   基于 ZAB（ZooKeeper Atomic Broadcast）协议
-   保证所有节点的数据最终一致
-   适合对一致性要求高的场景

**2. 临时节点（Ephemeral Node）**

-   客户端断开连接后自动删除
-   天然解决了死锁问题
-   无需设置过期时间

**3. 顺序节点（Sequential Node）**

-   自动递增的序号后缀
-   保证节点创建的先后顺序
-   实现公平锁的基础

### 3.2 三种实现方案对比

#### 3.2.1 方案对比表格

| 方案         | 原理             | 优点               | 缺点             | 适用场景       |
| ------------ | ---------------- | ------------------ | ---------------- | -------------- |
| 临时节点     | 单一临时节点抢占 | 实现简单           | 惊群效应，性能差 | 低并发场景     |
| 临时顺序节点 | 排队取号机制     | 公平锁，无惊群     | 实现复杂         | 高并发公平场景 |
| Curator 框架 | 封装顺序节点     | 简单易用，功能完善 | 依赖外部框架     | 生产环境推荐   |

### 临时顺序节点方案

**排队取号**

**公平可重入锁**，**Zookeeper 临时顺序节点**，递增有序性，可以确保锁的公平，节点监听机制，可以保障占有锁的传递有序而且高效

分布式锁的算法

-   一把分布式锁通常使用一个 Znode 节点表示；如果锁对应的 Znode 节点不存在，首先创建 Znode 节点。这里假设为“/test/lock”，代表了一把需要创建的分布式锁
-   抢占锁的所有客户端，使用锁的 Znode 节点的子节点列表来表示；如果某个客户端需要占用锁，则在“/test/lock”下创建一个临时有序的子节点。所有临时有序子节点，尽量共用一个有意义的子节点前缀。比如“/test/lock/seq-”
-   判定客户端是否占有锁，客户端创建子节点后，需要进行判断：自己创建的子节点，是否为当前子节点列表中序号最小的子节点。如果是，则认为加锁成功；如果不是，则监听前一个 Znode 子节点变更消息，等待前一个节点释放锁。
-   一旦队列中的后面的节点，获得前一个子节点变更通知，则开始进行判断，判断自己是否为当前子节点列表中序号最小的子节点，如果是，则认为加锁成功；如果不是，则持续监听，一直到获得锁。
-   获取锁后，开始处理业务流程。完成业务流程后，删除自己的对应的子节点，完成释放锁的工作，以方面后继节点能捕获到节点变更通知，获得分布式锁。

#### Lock 接口

定义了一个锁的接口 Lock，两个抽象方法：一个加锁方法，一个解锁方法

```java
public interface Lock {
    /**
     * 加锁方法
     *
     * @return 是否成功加锁
     */
    boolean lock() throws Exception;

    /**
     * 解锁方法
     *
     * @return 是否成功解锁
     */
    boolean unlock();
}
```

#### 锁实现

**lock()**

-   首先尝试着去加锁，如果加锁失败就去等待，然后再重复

```java
public class ZkLock implements Lock {
    //ZkLock的节点链接
    private static final String ZK_PATH = "/test/lock";
    private static final String LOCK_PREFIX = ZK_PATH + "/";
    private static final long WAIT_TIME = 1000;

    //Zk客户端
    CuratorFramework client = null;

    private String locked_short_path = null;
    private String locked_path = null;
    private String prior_path = null;
    final AtomicInteger lockCount = new AtomicInteger(0);

    private Thread thread;

    public ZkLock() {
        ZKclient.instance.init();
        synchronized (ZKclient.instance) {
            if (!ZKclient.instance.isNodeExist(ZK_PATH)) {
                ZKclient.instance.createNode(ZK_PATH, null);
            }
        }
        client = ZKclient.instance.getClient();
    }

    @Override
    public boolean lock() {
		//可重入，确保同一线程，可以重复加锁
        synchronized (this) {
            if (lockCount.get() == 0) {
                thread = Thread.currentThread();
                lockCount.incrementAndGet();
            } else {
                if (!thread.equals(Thread.currentThread())) {
                    return false;
                }
                lockCount.incrementAndGet();
                return true;
            }
        }

        try {
            boolean locked = false;
			//首先尝试着去加锁
            locked = tryLock();

            if (locked) {
                return true;
            }
            //如果加锁失败就去等待
            while (!locked) {

                await();

                //获取等待的子节点列表
                List<String> waiters = getWaiters();
				//判断，是否加锁成功
                if (checkLocked(waiters)) {
                    locked = true;
                }
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            unlock();
        }

        return false;
    }
}
```

**tryLock()**

-   创建临时顺序节点，并且保存自己的节点路径
-   判断是否是第一个，如果是第一个，则加锁成功。如果不是，就找到前一个 Znode 节点，并且保存其路径到 prior_path

```java
/**
 * 尝试加锁
 * @return 是否加锁成功
 * @throws Exception 异常
 */
private boolean tryLock() throws Exception {
    //创建临时Znode
    locked_path = ZKclient.instance
            .createEphemeralSeqNode(LOCK_PREFIX);
    //然后获取所有节点
    List<String> waiters = getWaiters();

    if (null == locked_path) {
        throw new Exception("zk error");
    }
    //取得加锁的排队编号
    locked_short_path = getShortPath(locked_path);

    //获取等待的子节点列表，判断自己是否第一个
    if (checkLocked(waiters)) {
        return true;
    }

    // 判断自己排第几个
    int index = Collections.binarySearch(waiters, locked_short_path);
    if (index < 0) { // 网络抖动，获取到的子节点列表里可能已经没有自己了
        throw new Exception("节点没有找到: " + locked_short_path);
    }

    //如果自己没有获得锁，则要监听前一个节点
    prior_path = ZK_PATH + "/" + waiters.get(index - 1);

    return false;
}

private String getShortPath(String locked_path) {

    int index = locked_path.lastIndexOf(ZK_PATH + "/");
    if (index >= 0) {
        index += ZK_PATH.length() + 1;
        return index <= locked_path.length() ? locked_path.substring(index) : "";
    }
    return null;
}
```

**checkLocked()**

-   判断是否可以持有锁，当前创建的节点，是否在上一步获取到的子节点列表的第一个位置

```java
private boolean checkLocked(List<String> waiters) {

    //节点按照编号，升序排列
    Collections.sort(waiters);

    // 如果是第一个，代表自己已经获得了锁
    if (locked_short_path.equals(waiters.get(0))) {
        log.info("成功的获取分布式锁,节点为{}", locked_short_path);
        return true;
    }
    return false;
}
```

**await()**

-   监听前一个 ZNode 节点（prior_path 成员）的删除事件，可以使用两种监听方式
-   Watcher 订阅
-   TreeCache 订阅

```java
private void await() throws Exception {

    if (null == prior_path) {
        throw new Exception("prior_path error");
    }

    final CountDownLatch latch = new CountDownLatch(1);

    //订阅比自己次小顺序节点的删除事件
    Watcher w = new Watcher() {
        @Override
        public void process(WatchedEvent watchedEvent) {
            System.out.println("监听到的变化 watchedEvent = " + watchedEvent);
            log.info("[WatchedEvent]节点删除");

            latch.countDown();
        }
    };

    client.getData().usingWatcher(w).forPath(prior_path);

/*
    //订阅比自己次小顺序节点的删除事件
    TreeCache treeCache = new TreeCache(client, prior_path);
    TreeCacheListener l = new TreeCacheListener() {
        @Override
        public void childEvent(CuratorFramework client,
                                TreeCacheEvent event) throws Exception {
            ChildData data = event.getData();
            if (data != null) {
                switch (event.getType()) {
                    case NODE_REMOVED:
                        log.debug("[TreeCache]节点删除, path={}, data={}",
                                data.getPath(), data.getData());

                        latch.countDown();
                        break;
                    default:
                        break;
                }
            }
        }
    };

    treeCache.getListenable().addListener(l);
    treeCache.start();
*/
    latch.await(WAIT_TIME, TimeUnit.SECONDS);
}
```

**可重入**

只需要保障同一个线程进入加锁的代码，可以重复加锁成功即可。在 lock 方法前面加上可重入的判断逻辑

```java
@Override
public boolean lock() {

    //可重入的判断
    synchronized (this) {
        if (lockCount.get() == 0) {
            thread = Thread.currentThread();
            lockCount.incrementAndGet();
        } else {
            if (!thread.equals(Thread.currentThread())) {
                return false;
            }
            lockCount.incrementAndGet();
            return true;
        }
    }
}
```

为了变成可重入，在代码中增加了一个加锁的计数器 lockCount，计算重复加锁的次数。如果是同一个线程加锁，只需要增加次数，直接返回，表示加锁成功。

#### 解锁

**unLock()**，表示释放锁，释放锁主要有两个工作

-   减少重入锁的计数，如果最终的值不是 0，直接返回，表示成功的释放了一次
-   如果计数器为 0，移除 Watchers 监听器，并且删除创建的 Znode 临时节点

```java
/**
 * 释放锁
 *
 * @return 是否成功释放锁
 */
@Override
public boolean unlock() {
	//只有加锁的线程，能够解锁
    if (!thread.equals(Thread.currentThread())) {
        return false;
    }
	//减少可重入的计数
    int newLockCount = lockCount.decrementAndGet();
	//计数不能小于0
    if (newLockCount < 0) {
        throw new IllegalMonitorStateException("Lock count has gone negative for lock: " + locked_path);
    }
	//如果计数不为0，直接返回
    if (newLockCount != 0) {
        return true;
    }
    //删除临时节点
    try {
        if (ZKclient.instance.isNodeExist(locked_path)) {
            client.delete().forPath(locked_path);
        }
    } catch (Exception e) {
        e.printStackTrace();
        return false;
    }

    return true;
}
```

#### 测试

```java
prviate int count = 0;

@Test
public void testLock() throws InterruptedException {
    for (int i = 0; i < 10; i++) {
        FutureTaskScheduler.add(() -> {
            //创建锁
            ZkLock lock = new ZkLock();
            lock.lock();
//每条线程，执行10次累加
            for (int j = 0; j < 10; j++) {
//公共的资源变量累加
                count++;
            }
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.info("count = " + count);
            //释放锁
            lock.unlock();

        });
    }

    Thread.sleep(Integer.MAX_VALUE);
}
```

### Curator 分布式锁 InterProcessMutex

```java
prviate int count = 0;

@Test
public void testzkMutex() throws InterruptedException {

    CuratorFramework client = ZKclient.instance.getClient();
    final InterProcessMutex zkMutex = new InterProcessMutex(client, "/mutex");

    for (int i = 0; i < 10; i++) {
        FutureTaskScheduler.add(() -> {

            try {
                //获取互斥锁
                zkMutex.acquire();

                for (int j = 0; j < 10; j++) {
					//公共的资源变量累加
                    count++;
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.info("count = " + count);
                //释放互斥锁
                zkMutex.release();

            } catch (Exception e) {
                e.printStackTrace();
            }

        });
    }

    Thread.sleep(Integer.MAX_VALUE);
}
```

## 第四章 其他分布式锁技术

### 4.1 etcd 分布式锁

#### 4.1.1 etcd 简介

etcd 是一个分布式、可靠的键值存储系统，专为分布式系统设计。etcd 分布式锁基于其 lease（租约）、watch（监听）、mvcc（多版本并发控制）等特性实现。

#### 4.1.2 etcd 分布式锁原理

**核心特性：**

-   **Lease 机制**：提供 TTL（生存时间）功能，自动过期释放锁
-   **Watch 机制**：监听键值变化，实现事件驱动
-   **MVCC**：多版本并发控制，支持事务操作
-   **强一致性**：基于 Raft 协议保证数据一致性

#### 4.1.3 etcd 锁实现示例

**Maven 依赖：**

```xml
<dependency>
    <groupId>io.etcd</groupId>
    <artifactId>jetcd-core</artifactId>
    <version>0.7.5</version>
</dependency>
```

**基本实现：**

```java
@Component
public class EtcdDistributedLock {

    private Client etcdClient;
    private Lock lockClient;
    private Lease leaseClient;

    @PostConstruct
    public void init() {
        etcdClient = Client.builder()
            .endpoints("http://127.0.0.1:2379")
            .build();
        lockClient = etcdClient.getLockClient();
        leaseClient = etcdClient.getLeaseClient();
    }

    public boolean tryLock(String lockName, long timeout, TimeUnit timeUnit) {
        try {
            // 创建租约
            long leaseId = leaseClient.grant(timeUnit.toSeconds(timeout)).get().getID();

            // 获取锁
            ByteSequence lockKey = ByteSequence.from(lockName, StandardCharsets.UTF_8);
            LockResponse lockResponse = lockClient.lock(lockKey, leaseId).get();

            if (lockResponse != null) {
                // 保存lockKey用于释放
                return true;
            }
            return false;

        } catch (Exception e) {
            log.error("etcd加锁失败", e);
            return false;
        }
    }

    public void unlock(String lockName) {
        try {
            ByteSequence lockKey = ByteSequence.from(lockName, StandardCharsets.UTF_8);
            lockClient.unlock(lockKey).get();
        } catch (Exception e) {
            log.error("etcd解锁失败", e);
        }
    }

    @PreDestroy
    public void destroy() {
        if (etcdClient != null) {
            etcdClient.close();
        }
    }
}
```

**业务使用：**

```java
@Service
public class EtcdLockService {

    @Autowired
    private EtcdDistributedLock etcdLock;

    public String processTask(String taskId) {
        String lockName = "task:" + taskId;

        try {
            if (etcdLock.tryLock(lockName, 30, TimeUnit.SECONDS)) {
                try {
                    // 执行业务逻辑
                    return handleTask(taskId);
                } finally {
                    etcdLock.unlock(lockName);
                }
            } else {
                return "任务正在处理中";
            }
        } catch (Exception e) {
            log.error("任务处理异常: " + taskId, e);
            return "处理失败";
        }
    }

    private String handleTask(String taskId) {
        // 模拟任务处理
        return "任务处理完成: " + taskId;
    }
}
```

### 4.2 Consul 分布式锁

#### 4.2.1 Consul 简介

Consul 是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置。Consul 分布式锁基于其 Key/Value 存储的 acquire 和 release 操作实现。

#### 4.2.2 Consul 锁原理

**核心机制：**

-   **Session 机制**：创建会话来管理锁的生命周期
-   **Key/Value 存储**：使用 KV 存储实现锁状态管理
-   **Health Check**：通过健康检查自动释放失效的锁
-   **Watch 机制**：监听键值变化

#### 4.2.3 Consul 锁实现

**Maven 依赖：**

```xml
<dependency>
    <groupId>com.ecwid.consul</groupId>
    <artifactId>consul-api</artifactId>
    <version>1.4.5</version>
</dependency>
```

**实现示例：**

```java
@Component
public class ConsulDistributedLock {

    private ConsulClient consulClient;
    private final Map<String, String> sessionCache = new ConcurrentHashMap<>();

    @PostConstruct
    public void init() {
        consulClient = new ConsulClient("127.0.0.1", 8500);
    }

    public boolean tryLock(String lockKey, long timeout, TimeUnit timeUnit) {
        try {
            // 创建Session
            NewSession newSession = new NewSession();
            newSession.setTtl(Math.max(10, (int) timeUnit.toSeconds(timeout))); // 最小10秒
            newSession.setBehavior(Session.Behavior.DELETE);

            String sessionId = consulClient.sessionCreate(newSession, QueryParams.DEFAULT)
                .getValue();

            // 尝试获取锁
            PutParams putParams = new PutParams();
            putParams.setAcquireSession(sessionId);

            boolean acquired = consulClient.setKVValue(lockKey, "locked", putParams);

            if (acquired) {
                sessionCache.put(lockKey, sessionId);
                return true;
            } else {
                // 获取锁失败，销毁session
                consulClient.sessionDestroy(sessionId, QueryParams.DEFAULT);
                return false;
            }

        } catch (Exception e) {
            log.error("Consul加锁失败", e);
            return false;
        }
    }

    public void unlock(String lockKey) {
        try {
            String sessionId = sessionCache.remove(lockKey);
            if (sessionId != null) {
                // 释放锁
                PutParams putParams = new PutParams();
                putParams.setReleaseSession(sessionId);
                consulClient.setKVValue(lockKey, "", putParams);

                // 销毁session
                consulClient.sessionDestroy(sessionId, QueryParams.DEFAULT);
            }
        } catch (Exception e) {
            log.error("Consul解锁失败", e);
        }
    }
}
```

**Spring Boot 集成：**

```java
@Service
public class ConsulLockService {

    @Autowired
    private ConsulDistributedLock consulLock;

    public String processOrder(String orderId) {
        String lockKey = "order/" + orderId;

        try {
            if (consulLock.tryLock(lockKey, 60, TimeUnit.SECONDS)) {
                try {
                    return processOrderLogic(orderId);
                } finally {
                    consulLock.unlock(lockKey);
                }
            } else {
                return "订单正在处理中，请稍后";
            }
        } catch (Exception e) {
            log.error("订单处理异常: " + orderId, e);
            return "处理失败";
        }
    }

    private String processOrderLogic(String orderId) {
        // 模拟订单处理
        return "订单处理成功: " + orderId;
    }
}
```

### 4.3 数据库分布式锁

#### 4.3.1 基于 MySQL 的分布式锁

**1. 基于唯一索引**

**表结构：**

```sql
CREATE TABLE `distributed_lock` (
  `id` BIGINT NOT NULL AUTO_INCREMENT,
  `lock_name` VARCHAR(100) NOT NULL COMMENT '锁名称',
  `lock_value` VARCHAR(100) NOT NULL COMMENT '锁值',
  `expire_time` BIGINT NOT NULL COMMENT '过期时间',
  `create_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_lock_name` (`lock_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

**实现代码：**

```java
@Repository
public class DatabaseDistributedLock {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public boolean tryLock(String lockName, String lockValue, long expireTime) {
        try {
            String sql = "INSERT INTO distributed_lock (lock_name, lock_value, expire_time) VALUES (?, ?, ?)";
            int result = jdbcTemplate.update(sql, lockName, lockValue,
                System.currentTimeMillis() + expireTime);
            return result > 0;
        } catch (DuplicateKeyException e) {
            // 锁已存在，检查是否过期
            return tryAcquireExpiredLock(lockName, lockValue, expireTime);
        }
    }

    private boolean tryAcquireExpiredLock(String lockName, String lockValue, long expireTime) {
        try {
            String sql = "UPDATE distributed_lock SET lock_value = ?, expire_time = ? " +
                        "WHERE lock_name = ? AND expire_time < ?";
            int result = jdbcTemplate.update(sql, lockValue,
                System.currentTimeMillis() + expireTime, lockName, System.currentTimeMillis());
            return result > 0;
        } catch (Exception e) {
            log.error("尝试获取过期锁失败", e);
            return false;
        }
    }

    public boolean unlock(String lockName, String lockValue) {
        try {
            String sql = "DELETE FROM distributed_lock WHERE lock_name = ? AND lock_value = ?";
            int result = jdbcTemplate.update(sql, lockName, lockValue);
            return result > 0;
        } catch (Exception e) {
            log.error("释放锁失败", e);
            return false;
        }
    }

    // 清理过期锁的定时任务
    @Scheduled(fixedRate = 60000) // 每分钟执行一次
    public void cleanExpiredLocks() {
        try {
            String sql = "DELETE FROM distributed_lock WHERE expire_time < ?";
            int count = jdbcTemplate.update(sql, System.currentTimeMillis());
            if (count > 0) {
                log.info("清理过期锁数量: {}", count);
            }
        } catch (Exception e) {
            log.error("清理过期锁失败", e);
        }
    }
}
```

**2. 基于 SELECT FOR UPDATE**

```java
@Service
@Transactional
public class SelectForUpdateLock {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Transactional(rollbackFor = Exception.class)
    public <T> T executeWithLock(String lockName, Supplier<T> business) {
        try {
            // 获取锁
            acquireLock(lockName);

            // 执行业务逻辑
            return business.get();

        } catch (Exception e) {
            log.error("执行业务逻辑失败", e);
            throw new RuntimeException("业务执行失败", e);
        }
        // 事务结束时自动释放锁
    }

    private void acquireLock(String lockName) {
        String sql = "SELECT lock_name FROM distributed_lock WHERE lock_name = ? FOR UPDATE";

        try {
            List<String> result = jdbcTemplate.queryForList(sql, String.class, lockName);
            if (result.isEmpty()) {
                // 锁不存在，创建锁
                String insertSql = "INSERT INTO distributed_lock (lock_name, lock_value) VALUES (?, ?)";
                jdbcTemplate.update(insertSql, lockName, UUID.randomUUID().toString());
            }
        } catch (Exception e) {
            throw new RuntimeException("获取锁失败", e);
        }
    }
}
```

### 4.4 分布式锁选型对比

#### 4.4.1 综合对比表

| 技术      | 性能             | 可靠性 | 复杂度 | 功能特性           | 适用场景                   |
| --------- | ---------------- | ------ | ------ | ------------------ | -------------------------- |
| Redis     | 很高(10 万+QPS)  | 中等   | 低     | 简单高效           | 高并发、对可靠性要求不极致 |
| ZooKeeper | 中等(1-2 万 QPS) | 很高   | 中等   | 功能丰富、强一致性 | 对一致性要求极高           |
| etcd      | 中等(1 万+QPS)   | 很高   | 中等   | 云原生、K8s 生态   | 云原生应用                 |
| Consul    | 中等(几千 QPS)   | 高     | 中等   | 服务发现+锁        | 微服务架构                 |
| 数据库    | 低(几百 QPS)     | 高     | 低     | 简单可靠           | 低并发、简单场景           |

#### 4.4.2 选型建议

**高性能场景：**

```java
// 推荐Redis + Redisson
@Service
public class HighPerformanceLockService {

    @Autowired
    private RedissonClient redissonClient;

    public void highConcurrencyOperation(String resourceId) {
        RLock lock = redissonClient.getLock("resource:" + resourceId);

        try {
            if (lock.tryLock(1, 10, TimeUnit.SECONDS)) {
                // 高并发业务逻辑
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

**高可靠性场景：**

```java
// 推荐ZooKeeper + Curator
@Service
public class HighReliabilityLockService {

    @Autowired
    private CuratorFramework curatorFramework;

    public void criticalOperation(String resourceId) {
        InterProcessMutex lock = new InterProcessMutex(
            curatorFramework, "/critical-locks/" + resourceId);

        try {
            if (lock.acquire(30, TimeUnit.SECONDS)) {
                // 关键业务逻辑
            }
        } catch (Exception e) {
            log.error("关键操作失败", e);
        } finally {
            try {
                lock.release();
            } catch (Exception e) {
                log.error("释放锁失败", e);
            }
        }
    }
}
```

**云原生场景：**

```java
// 推荐etcd
@Service
public class CloudNativeLockService {

    @Autowired
    private EtcdDistributedLock etcdLock;

    public void cloudNativeOperation(String resourceId) {
        String lockName = "/cloud-locks/" + resourceId;

        try {
            if (etcdLock.tryLock(lockName, 30, TimeUnit.SECONDS)) {
                // 云原生应用逻辑
            }
        } finally {
            etcdLock.unlock(lockName);
        }
    }
}
```

### 4.5 混合锁策略

#### 4.5.1 分层锁架构

```java
@Component
public class HybridDistributedLock {

    @Autowired
    private RedissonClient redissonClient;

    @Autowired
    private CuratorFramework curatorFramework;

    /**
     * 混合锁：Redis做快速筛选，ZooKeeper做最终仲裁
     */
    public <T> T executeWithHybridLock(String lockKey, Supplier<T> business) {
        // 第一层：Redis快速锁
        RLock redisLock = redissonClient.getLock("redis:" + lockKey);

        try {
            if (redisLock.tryLock(1, 30, TimeUnit.SECONDS)) {
                try {
                    // 第二层：ZooKeeper可靠锁
                    InterProcessMutex zkLock = new InterProcessMutex(
                        curatorFramework, "/zk-locks/" + lockKey);

                    if (zkLock.acquire(10, TimeUnit.SECONDS)) {
                        try {
                            return business.get();
                        } finally {
                            zkLock.release();
                        }
                    } else {
                        throw new RuntimeException("获取ZK锁超时");
                    }

                } finally {
                    redisLock.unlock();
                }
            } else {
                throw new RuntimeException("获取Redis锁超时");
            }
        } catch (Exception e) {
            throw new RuntimeException("混合锁执行失败", e);
        }
    }
}
```

#### 4.5.2 故障转移策略

```java
@Component
public class FaultTolerantLockService {

    @Autowired
    private RedissonClient redissonClient;

    @Autowired
    private CuratorFramework curatorFramework;

    @Autowired
    private DatabaseDistributedLock databaseLock;

    public <T> T executeWithFallback(String lockKey, Supplier<T> business) {
        // 优先使用Redis
        try {
            return executeWithRedisLock(lockKey, business);
        } catch (Exception e) {
            log.warn("Redis锁失败，降级到ZooKeeper", e);

            // 降级到ZooKeeper
            try {
                return executeWithZkLock(lockKey, business);
            } catch (Exception e2) {
                log.warn("ZooKeeper锁失败，降级到数据库", e2);

                // 最后降级到数据库
                return executeWithDbLock(lockKey, business);
            }
        }
    }

    private <T> T executeWithRedisLock(String lockKey, Supplier<T> business) throws Exception {
        RLock lock = redissonClient.getLock(lockKey);
        if (lock.tryLock(5, 30, TimeUnit.SECONDS)) {
            try {
                return business.get();
            } finally {
                lock.unlock();
            }
        } else {
            throw new RuntimeException("Redis锁获取失败");
        }
    }

    private <T> T executeWithZkLock(String lockKey, Supplier<T> business) throws Exception {
        InterProcessMutex lock = new InterProcessMutex(curatorFramework, "/" + lockKey);
        if (lock.acquire(10, TimeUnit.SECONDS)) {
            try {
                return business.get();
            } finally {
                lock.release();
            }
        } else {
            throw new RuntimeException("ZooKeeper锁获取失败");
        }
    }

    private <T> T executeWithDbLock(String lockKey, Supplier<T> business) {
        String lockValue = UUID.randomUUID().toString();
        if (databaseLock.tryLock(lockKey, lockValue, 30000)) {
            try {
                return business.get();
            } finally {
                databaseLock.unlock(lockKey, lockValue);
            }
        } else {
            throw new RuntimeException("数据库锁获取失败");
        }
    }
}
```
