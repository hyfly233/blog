# 分布式事务

## 分布式事务

- 分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上，分布式事务需要保证这些小操作要么全部成功，要么全部失败
- 对于分布式系统而言，需要保证分布式系统中的数据一致性，避免业务出现问题。分布式系统中对数要么一起成功，要么一起失败，必须是一个整体性的事务
- 当本地事务要扩展到分布式时，它的复杂性进一步增加

- - 存储端的多样性：本地事务的情况下，所有数据都会落到同一个DB中，但是，在分布式的情况下，就会出现数据可能要落到多个DB，或者还会落到Redis，落到MQ等中
  - 事务链路的延展性：本地事务的情况下，通常所有的事务相关的业务操作会被封装到一个Service方法中。而在分布式的情况下，请求链路被延展伸长，一个操作被拆分成多个服务，它们呈线性或网状，依靠网络通信构成一个整体，事务变得十分复杂

## 分布式事务使用场景

- 跨库事务
- 分库分表
- 微服务化

## 事务组成

![img](https://cdn.nlark.com/yuque/0/2023/jpeg/29236088/1676448575049-8c663679-1e52-4b1f-8226-73ecc6ae22fd.jpeg)

- 事务：事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即原子性、一致性、隔离性和持久性
- 本地事务：当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性，高效，可靠，状态可以只在资源管理器中维护，而且应用编程模型简单。但是本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器
- 全局事务：当事务由全局事务管理器进行全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的一致提交回滚
- TX协议：应用或者应用服务器与事务管理器的接口
- XA协议：全局事务管理器与资源管理器的接口。XA是由X/Open组织提出的分布式事务规范。该规范主要定义了全局事务管理器和局部资源管理器之间的接口。主流的数据库产品都实现了XA接口。XA接口是一个双向的系统接口，在事务管理器以及多个资源管理器之间作为通信桥梁。之所以需要XA是因为在分布式系统中从理论上讲两台机器是无法达到一致性状态的，因此引入一个单点进行协调。由全局事务管理器管理和协调的事务可以跨越多个资源和进程。全局事务管理器一般使用XA二阶段协议与数据库进行交互
- AP：应用程序，可以理解为使用DTP（Data Tools Platform）的程序
- RM：资源管理器，可以是一个DBMS或者消息服务器管理系统，应用程序通过资源管理器对资源进行控制，资源必须实现XA定义的接口。资源管理器负责控制和管理实际的资源
- TM：事务管理器，负责协调和管理事务，提供给AP编程接口以及管理资源管理器。事务管理器控制着全局事务，管理事务的生命周期，并且协调资源
- 两阶段提交协议：XA用于在全局事务中协调多个资源的机制。TM和RM之间采取两阶段提交的方案来解决一致性问题。两节点提交需要一个协调者（TM）来掌控所有参与者（RM）节点的操作结果并且指引这些节点是否需要最终提交。两阶段提交的局限在于协议成本，准备阶段的持久成本，全局事务状态的持久成本，潜在故障点多带来的脆弱性，准备后，提交前的故障引发一系列隔离与恢复难题。
- BASE理论：BA指的是基本业务可用性，支持分区失败，S表示柔性状态，也就是允许短时间内不同步，E表示最终一致性，数据最终是一致的，但是实时是不一致的。原子性和持久性必须从根本上保障，为了可用性、性能和服务降级的需要，只有降低一致性和隔离性的要求。
- CAP定理：对于共享数据系统，最多只能同时拥有CAP其中的两个，任意两个都有其适应的场景，真是的业务系统中通常是ACID与CAP的混合体。分布式系统中最重要的是满足业务需求，而不是追求高度抽象，绝对的系统特性。C表示一致性，也就是所有用户看到的数据是一样的。A表示可用性，是指总能找到一个可用的数据副本。P表示分区容错性，能够容忍网络中断等故障。

## 分布式事务与分布式锁的区别

- 分布式锁解决的是分布式资源抢占的问题
- 分布式事务和本地事务是解决流程化提交问题

## CAP

## BASE

BASE是Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。BASE基于CAP定理演化而来，核心思想是即时无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。

- Basically Available（基本可用）：指分布式系统中出现不可预知故障的时候，允许损失部分可用性，但不等于系统不可用

- - 响应时间上的损失：当出现故障时，响应时间增加
  - 功能上的损失：当流量高峰时，屏蔽一些功能的使用以爆炸系统的稳定性（服务降级）

- Soft state（软状态）：数据存在中间状态，并认为改中间状态不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时
- Eventually consistent（最终一致性）：系统中的所有数据副本，经过一段时间的同步后，最终能够达到一个一致的状态

- - 因果一致性（Causal Consistency）：即进程A在更新完数据后通知进程B，那么之后进程B对该项数据的范围都是进程A更新后的最新值
  - 读己之所写（Read your writes）：进程A更新一项数据后，它自己总是能访问到自己更新过的最新值
  - 会话一致型（Session consistency）：将数据一致性框定在会话当中，在一个会话当中实现读己之所写的一致性。即执行更新后，客户端在同一个会话中始终能读到该项数据的最新值
  - 单调读一致型（Monotonic read consistency）：如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值
  - 单调写一致型（Monotonic write consistency）：一个系统需要保证来自同一个进程的写操作被顺序执行



## 解决方案

- 强一致性 

- - 二阶段提交
  - Raft

- 最终一致性 

- - 异步确保型
  - 事务型消息
  - TCC型



## 二阶段提交



排它锁保证强一致性



二阶段提交非常影响性能



## Raft协议



对N个节点的集群中，同步成功一半以上（N/2 + 1）个节点就算同步成功，外加二阶段提交



## TCC



依照二阶段提交设计的，Try，Confirm，Cancel



需要中间状态字段，log表



需要定时补偿机制



## 异步确保型



消息中间件需要持久化消息，并且开启重试



回滚操作发送mq可能会失败



## 事务型消息



本地事务开始前，先向RocketMQ发送prepare消息，再执行本地事务后commit，send commit消息



RocketMQ会根据prepare消息进行会查





## 什么是CAP理论



CAP理论是分布式领域中非常重要的一个指导理论，C（Consistency）表示强一致性，A（Availability）表示可用性，P（PartitionTolerance）表示分区容错性，CAP理论指出在目前的硬件条件下，一个分布式系统是必须要保证分区容错性的，而在这个前提下，分布式系统要么保证CP，要么保证AP，无法同时保证CAP。



- 分区容错性表示，一个系统虽然是分布式的，但是对外看上去应该是一个整体，不能由于分布式系统内部的某个结点挂点，或网络出现了故障，而导致系统对外出现异常。所以，对于分布式系统而言是一定要保证分区容错性的
- 强一致性表示，一个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提供服务的，不然就会造成数据不一致，所以
  强一致性和可用性是不能同时满足的
- 可用性表示，一个分布式系统对外要保证可用



## 什么是BASE理论



由于不能同时满足CAP，所以出现了BASE理论



1. BA：`BasicallyAvailable`，表示基本可用，表示可以允许一定程度的不可用，比如由于系统故障，请求时间变长，或者由于系统故障导致部分非核心功能不可用，都是允许的
2. S：`Softstate`：表示分布式系统可以处于一种中间状态，比如数据正在同步
3. E：`Eventuallyconsistent`，表示最终一致性，不要求分布式系统数据实时达到一致，允许在经过一段时间后再达到一致，在达到一致过程中，系统也是可用的



## 什么是RPC



RPC，表示远程过程调用，对于Java这种面试对象语言，也可以理解为远程方法调用



RPC调用和HTTP调用是有区别的



RPC表示的是一种调用远程方法的方式，可以使用HTTP协议、或直接基于TCP协议来实现RPC，在Java中，可以通过直接使用某个服务接口的代理对象来执行方法，而底层则通过构造



HTTP请求来调用远端的方法，所以，有一种说法是RPC协议是HTTP协议之上的一种协议



## 分布式ID是什么？ 有哪些解决方案？



在开发中，我们通常会需要一个唯ID来标识数据，如果是单体架构，我们可以通过数据库的主键，或直接在内存中维护一个自增数字来作为ID都是可以的，但对于一个分布式系统，就会有可能会出现I冲突，此时有以下解决方案



1. uuid，这种方案复杂度最低，但是会影响存储空间和性能
2. 利用单机数据库的自增主键，作为分布式ID的生成器，复杂度适中，ID长度较之uuid更短，但是受到单机数据库性能的限制，并发量大的时候此方案也不是最优方案
3. 利用redis、zookeeper的特性来生成id，比如redis的自增命令、zookeeper的顺序节点，这种方案和单机数据库（mysql）相比，性能有所提高，可以适当选用
4. 雪花算法，一切问题如果能直接用算法解决，那就是最合适的，利用雪花算法也可以生成分布式ID，底层原理就是通过某台机器在某一毫秒内对某一个数字自增，这种方案也能保证分布式架构中的系统id唯一，但是只能保证超势递增。业界存在`tinyid`、`lea`等开源中间件实现了雪花算法



## 分布式锁的使用场景是什么？ 有哪些实现方案？



在单体架构中，多个线程都是属于同一个进程的，所以在线程并发执行时，遇到资源竞争时，可以利用`Reentrantlock`、`synchronized`等技术来作为锁，来控制共享资源的使用。



分布式架构中，多个线程是可能处于不同进程中的，而这些线程并发执行遇到资源竞争时，利用`ReentrantLock`、`synchronized`等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思就是，需要一个分布式锁生成器，分布式系统中的应用程序都可以来使用这个生成器所提供的锁，从而达到多个进程中的线程使用同一把锁



当前主流的分布式锁的实现方案有两种



1. zookeeper：利用的是zookeeper的临时节点、顺序节点、watch机制来实现的，zookeeper分布式锁的特点是高一致性，因为zookeeper保证的是CP，所以由它实现的分布式锁更可靠，不会出现混乱
2. redis：利用redis的setnx、lua脚本、消费订阅等机制来实现的，redis分布式锁的特点是高可用，因为redis保证的是AP，所以由它实现的分布式可能不可靠，不稳定（一旦redis中的数据出现了不一致），可能会出现多个客户端同时加到锁的情况



## 什么是分布式事务？有哪些实现方案？



在分布式系统中，一次业务处理可能需要多个应用来实现，比如用户发送一次下单请求，就涉及到订单系统创建订单、库存系统减库存，而对于次下单，订单创建与减库存应该是要同时成功或同时失败的，但在分布式系统中，如果不做处理，就很有可能出现订单创建成功，但是减库存失败，那么解决这类问题，就需要用到分布式事务。



常用解决方案有：



1. 本地消息表：创建订单时，将减库存消息加入在本地事务中，一起提交到数据库存入本地消息表，然后调用库存系统，如果调用成功则修改本地消息状态为成功，如果调用库存系统失败，则由后台定时任务从本地消息表中取出未成功的消息，重试调用库存系统
2. 消息队列：目前RocketMQ中支持事务消息，它的工作原理是：
   a.生产者订单系统先发送一条half消息到Broker，half消息对消费者而言是不可见的
   b.再创建订单，根据创建订单成功与否，向Broker发送commit或rollback
   c.并且生产者订单系统还可以提供Broker回调接口，当Broker发现一段时间half消息没有收到任何操作命令，则会主动调此接口来查询订单是否创建成功
   d.一旦half消息commit了，消费者库存系统就会来消费，如果消费成功，则消息销毁，分布式事务成功结束
   e.如果消费失败，则根据重试策略进行重试，最后还失败则进入死信队列，等待进一步处理
3. Seata：阿里开源的分布式事务框架，支持AT、TCC等多种模式，底层都是基于两阶段提交理论来实现的



## 数据一致性模型有哪些



-  强一致性：当更新操作完成之后，任何多个后续进程的访问都会返回最新的更新过的值，这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据CAP理论，这种实现需要性可用性。 
-  弱一致性：系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到用户读到某一操作对系统数据的更新需要一段时间，我们称这段时间为“不一致性窗口”。 
-  最终一致性：最终一致性是弱一致性的特例，强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态
  因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。到达最终一致性的时间，就是不一致窗口时间，在没有故障发生的前提下，不一致窗口的时间主要受通信延，系统负载和复制副本的个数影响，最终一致性模型根据其提供的不同保证可以划分为更多的模型，包括因果一致性和会话一致性等 
-  因果一致性：要求有因果关系的操作顺序得到保证
  非因果关系的操作顺序则无所谓进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获取到进程A更新后的最新值，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值
  在微博或者微信进行评论的时候，比如你在朋友圈发了一张照片，朋友给你评论了，而你对朋友的评论进行了回复，这条朋友圈的显示中，你的回复必须在朋友之后，这是一个因果关系，而其他没有因果关系的数据，可以允许不一致 
-  会话一致性：将对系统数据的访问过程框定在了一个会话当中，约定了系统能保证在同一个有效的会话中实现读己之所写的一致性，就是在你的一次访问中，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。实际开发中有分布式的Session一致性问题，可以认为是会话一致性的一个应用 



## 选举算法Quorum机制、 WARO



-  Waro：一种简单的副本控制协议，写操作时、只有当所有的副本都更新成功之后，这次写操作才算成功，否则视为失败
  优先保证读、任何节点读到的数据都是最新数据，性了更新服务的可用性、只要有一个副本岩机了，写服务就不会成功。但只要有一个节点存活、仍能提供读服务 
-  Quorum机制：10个副本，一次成功更新了三个，那么至少需要读取八个副本的数据，可以保证读到了最新的数据
  无法保证强一致性，也就是无法实现任何时刻任何用户或节点都可以读到最近一次成功提交的副本数据。需要配合一个获取最新成功提交的版本号的metadata服务，这样可以确定最新已经成功提交的版本号，然后从已经读到的数据中就可以确认最新写入的数据



## Seata

### Seata是什么

Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式的分布式解决方案，Seata AT和Seata TCC是在生产中最常用

### Seata的三大模块

- TC：事务协调者。负责事务ID的生成，事务注册、提交、回滚等
- TM：事务发起者。定义事务的边界，负责告知 TC，分布式事务的开始，提交，回滚
- RM：资源管理者。管理每个分支事务的资源，每一个 RM 都会作为一个分支事务注册在 TC

在Seata的AT模式中，TM和RM都作为SDK的一部分和业务服务在一起，可以认为是Client。TC是一个独立的服务，通过服务注册发现将自己暴露给Client们

### Seata执行流程

1. TM 开启分布式事务（TM 向 TC 注册全局事务记录）
2. 按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ）
3. TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交/回滚分布式事务）
4. TC 汇总事务信息，决定分布式事务是提交还是回滚
5. TC 通知所有 RM 提交/回滚资源，事务二阶段结束

### Seata AT模式

AT模式是指**Automatic (Branch) Transaction Mode自动化分支事务**，AT 模式，是 2pc两阶段提交协议的演变，不同的地方，Seata AT 模式不会一直锁表。

**使用前提：**

- 基于支持本地 ACID 事务的关系型数据库
- Java 应用通过 JDBC 访问数据库

### Seata TCC模式

TCC 与 Seata AT 事务一样都是**两阶段事务**，它与 AT 事务的主要区别为：

- **TCC 对业务代码侵入严重**
  每个阶段的数据操作都要自己进行编码来实现，事务框架无法自动处理
- **TCC 性能更高**
  不必对数据加全局锁，允许多个事务同时操作数据

### Seata Saga模式

Saga模式是Seata提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。

**适用场景：**

- 业务流程长、业务流程多
- 参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口

**优势：**

- 一阶段提交本地事务，无锁，高性能
- 事件驱动架构，参与者可异步执行，高吞吐
- 补偿服务易于实现

**缺点：**

- 不保证隔离性

### Seata XA模式

在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种 事务模式

**使用前提：**

- 支持XA 事务的数据库
- Java 应用，通过 JDBC 访问数据库





# 说一下两阶段提交和三阶段提交的过程？分别有什么问题？ 

两阶段提交协议 2PC 

1. 第一阶段（投票阶段）：

（1）协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应；

（2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。

（3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。 

2. 第二阶段（提交执行阶段）：

当协调者节点从所有参与者节点获得的相应消息都为”同意”时：

（1）协调者节点向所有参与者节点发出”正式提交(commit)”的请求；

（2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源；

（3）参与者节点向协调者节点发送”完成”消息；

（4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。

两阶段提交存在的问题：

1. 执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态；
2. 参与者发生故障：协调者需要给每个参与者额外指定超时机制，超时后整个事务失败；
3. 协调者发生故障：参与者会一直阻塞下去。需要额外的备机进行容错；
4. 二阶段无法解决的问题：协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。

三阶段提交协议 3PC

与两阶段提交不同的是，三阶段提交有两个改动点：

1. 引入超时机制。同时在协调者和参与者中都引入超时机制；
2. 在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。

也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。 

1. CanCommit 阶段

3PC 的 CanCommit 阶段其实和 2PC 的准备阶段很像。协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。

（1）事务询问：协调者向参与者发送 CanCommit 请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。

（2）响应反馈：参与者接到 CanCommit 请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回 Yes 响应，并进入预备状态。否则反馈 No。

2. PreCommit 阶段

协调者根据参与者的反应情况来决定是否可以继续事务的 PreCommit 操作。根据响应情况，有以下两种可能：

假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行。

（1）发送预提交请求：协调者向参与者发送 PreCommit 请求，并进入 Prepared 阶段。

（2）事务预提交：参与者接收到 PreCommit 请求后，会执行事务操作，并将 undo 和 redo 信息记录到事务日志中。

（3）响应反馈：如果参与者成功的执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。 

假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。

（1）发送中断请求：协调者向所有参与者发送 abort 请求。

（2）中断事务：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。 

3. doCommit 阶段

该阶段进行真正的事务提交，也可以分为以下两种情况。 

3.1 执行提交

（1）发送提交请求：协调接收到参与者发送的 ACK 响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送 doCommit 请求。

（2）事务提交：参与者接收到 doCommit 请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。 

（3）响应反馈：事务提交完之后，向协调者发送 ACK 响应。 

（4）完成事务：协调者接收到所有参与者的 ACK 响应之后，完成事务。 

3.2 中断事务 

协调者没有接收到参与者发送的 ACK 响应（可能是接受者发送的不是 ACK 响应，也可能响应超时），那么就会执行中断事务。 

（1）发送中断请求：协调者向所有参与者发送 abort 请求。 

（2）事务回滚：参与者接收到 abort 请求之后，利用其在阶段二记录的 undo 信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。 

（3）反馈结果：参与者完成事务回滚之后，向协调者发送 ACK 消息。 

（4）中断事务：协调者接收到参与者反馈的 ACK 消息之后，执行事务的中断。 

三阶段提交的问题： 

网络分区可能会带来问题。需要四阶段解决：四阶段直接调用远程服务的数据状态，确定当前数据一致性的情况。 