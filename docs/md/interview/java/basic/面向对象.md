# Java 面向对象编程详解

## 1. 面向对象概述

### 1.1 面向对象编程（OOP）定义

面向对象编程是一种编程范式，它将现实世界中的事物抽象为对象，通过对象之间的交互来解决问题。Java 是一门纯面向对象的编程语言，所有的代码都必须在类中定义。

### 1.2 面向对象的三大特性

| 特性     | 定义                                                                                                                             | 核心作用           |
| -------- | -------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| **封装** | 将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏                                     | 数据安全、代码复用 |
| **继承** | 对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求 | 代码复用、层次结构 |
| **多态** | 允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的                                   | 灵活性、扩展性     |

### 1.3 面向对象的优势

**代码复用性**：通过继承和组合，减少重复代码
**模块化**：将复杂的系统分解为简单的模块
**可维护性**：修改某个类的实现不会影响其他类
**可扩展性**：通过继承和多态轻松扩展功能
**抽象性**：隐藏实现细节，只暴露必要的接口

## 2. 封装（Encapsulation）

### 2.1 封装的定义

封装是一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。要访问该类的代码和数据，必须通过严格的接口控制。

### 2.2 封装的实现

#### 2.2.1 访问修饰符

| 修饰符    | 类内部 | 同包 | 子类 | 其他包 |
| --------- | ------ | ---- | ---- | ------ |
| private   | ✓      | ✗    | ✗    | ✗      |
| default   | ✓      | ✓    | ✗    | ✗      |
| protected | ✓      | ✓    | ✓    | ✗      |
| public    | ✓      | ✓    | ✓    | ✓      |

#### 2.2.2 封装的最佳实践

```java
public class Student {
    // 私有属性
    private String name;
    private int age;
    private double score;

    // 公共构造器
    public Student(String name, int age) {
        this.name = name;
        this.setAge(age); // 使用setter进行验证
    }

    // Getter方法
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // Setter方法（包含业务逻辑验证）
    public void setAge(int age) {
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException("年龄必须在0-150之间");
        }
        this.age = age;
    }

    public void setScore(double score) {
        if (score < 0 || score > 100) {
            throw new IllegalArgumentException("分数必须在0-100之间");
        }
        this.score = score;
    }

    // 业务方法
    public String getGrade() {
        if (score >= 90) return "A";
        if (score >= 80) return "B";
        if (score >= 70) return "C";
        if (score >= 60) return "D";
        return "F";
    }
}
```

### 2.3 封装的好处

**数据安全**：通过访问修饰符控制数据访问
**业务逻辑封装**：在 setter 方法中添加验证逻辑
**实现隐藏**：外部只需要知道接口，不需要了解内部实现
**易于维护**：修改内部实现不影响外部调用

## 3. 继承（Inheritance）

### 3.1 继承的定义

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

### 3.2 继承相关关键字

#### 3.2.1 核心关键字

**extends**：

-   类的继承是单一继承，一个子类只能拥有一个父类
-   用于类继承类的情况

```java
public class Animal {
    protected String name;
    protected int age;

    public void eat() {
        System.out.println(name + " is eating");
    }
}

public class Dog extends Animal {
    private String breed;

    public void bark() {
        System.out.println(name + " is barking");
    }

    @Override
    public void eat() {
        System.out.println(name + " the dog is eating dog food");
    }
}
```

**implements**：

-   使用 implements 关键字可以变相的使 java 具有多继承的特性
-   使用范围为类继承接口的情况，可以同时继承多个接口

```java
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

public class Duck extends Animal implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println(name + " is flying");
    }

    @Override
    public void swim() {
        System.out.println(name + " is swimming");
    }
}
```

#### 3.2.2 访问控制关键字

**super**：

-   通过 super 关键字来实现对父类成员的访问
-   用来引用当前对象的父类

```java
public class Cat extends Animal {
    private String color;

    public Cat(String name, int age, String color) {
        super(); // 调用父类构造器
        super.name = name; // 访问父类属性
        super.age = age;
        this.color = color;
    }

    @Override
    public void eat() {
        super.eat(); // 调用父类方法
        System.out.println("Cat is eating fish");
    }
}
```

**this**：

-   指向自己的引用
-   用于区分局部变量和成员变量

```java
public class Person {
    private String name;

    public Person(String name) {
        this.name = name; // 区分参数和成员变量
    }

    public Person getThis() {
        return this; // 返回当前对象
    }

    public void callOtherConstructor(String name, int age) {
        this(name); // 调用其他构造器
    }
}
```

**final**：

-   用于修饰类：该类不能被继承
-   用于修饰方法：该方法不能被子类重写
-   用于修饰变量：该变量是常量

```java
// final类
public final class String {
    // String类不能被继承
}

public class Parent {
    // final方法
    public final void finalMethod() {
        System.out.println("This method cannot be overridden");
    }

    // final变量
    public static final double PI = 3.14159;
}
```

### 3.3 构造器继承

**重要规则**：

-   子类不继承父类的构造器（构造方法或者构造函数）
-   子类只是调用父类构造器（隐式或显式）
-   如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表
-   如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器

```java
public class Vehicle {
    protected String brand;
    protected String model;

    // 无参构造器
    public Vehicle() {
        System.out.println("Vehicle default constructor");
    }

    // 有参构造器
    public Vehicle(String brand, String model) {
        this.brand = brand;
        this.model = model;
        System.out.println("Vehicle parameterized constructor");
    }
}

public class Car extends Vehicle {
    private int doors;

    // 隐式调用父类无参构造器
    public Car() {
        super(); // 可以省略，系统自动调用
        System.out.println("Car default constructor");
    }

    // 显式调用父类有参构造器
    public Car(String brand, String model, int doors) {
        super(brand, model); // 必须显式调用
        this.doors = doors;
        System.out.println("Car parameterized constructor");
    }
}
```

### 3.4 为什么 Java 不支持多重继承

**多重继承的问题**：

1. **钻石问题（Diamond Problem）**：当一个类继承多个父类，而这些父类又有共同的父类时，会产生二义性
2. **类型转换复杂**：多重继承会使类型转换变得复杂
3. **构造方法调用顺序**：多个父类的构造方法调用顺序难以确定
4. **性能影响**：多重继承会影响到程序性能

**Java 的解决方案**：

-   单一继承：一个类只能继承一个父类
-   接口多实现：一个类可以实现多个接口
-   接口默认方法：Java 8 引入接口默认方法，部分解决多重继承需求

## 4. 多态（Polymorphism）

### 4.1 多态的定义

多态是同一个行为具有多个不同表现形式或形态的能力。同一个接口，使用不同的实例而执行不同操作。

### 4.2 多态存在的三个必要条件

1. **继承**：子类继承父类或实现接口
2. **重写**：子类重写父类的方法
3. **父引用指向子类对象**：`Parent p = new Child()`

### 4.3 多态的实现机制

#### 4.3.1 编译时多态（静态多态）

**方法重载（Overloading）**：

-   重载是指同一个类中有多个同名的方法，但这些方法有不同的参数
-   在编译期间就可以确定调用哪个方法

```java
public class Calculator {
    // 重载：参数个数不同
    public int add(int a, int b) {
        return a + b;
    }

    // 重载：参数个数不同
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // 重载：参数类型不同
    public double add(double a, double b) {
        return a + b;
    }

    // 重载：参数顺序不同
    public String add(String str, int num) {
        return str + num;
    }

    public String add(int num, String str) {
        return num + str;
    }
}
```

#### 4.3.2 运行时多态（动态多态）

**方法重写（Overriding）**：

-   覆盖是指派生类重写基类的方法
-   使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象
-   在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法
-   需要到运行期才能确定调用哪个方法

```java
// 抽象基类
abstract class Shape {
    protected String color;

    public Shape(String color) {
        this.color = color;
    }

    // 抽象方法，子类必须实现
    public abstract double getArea();

    // 具体方法，子类可以重写
    public void display() {
        System.out.println("This is a " + color + " shape");
    }
}

// 圆形类
class Circle extends Shape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public void display() {
        System.out.println("This is a " + color + " circle with radius " + radius);
    }
}

// 矩形类
class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    @Override
    public double getArea() {
        return width * height;
    }

    @Override
    public void display() {
        System.out.println("This is a " + color + " rectangle " + width + "x" + height);
    }
}

// 多态使用示例
public class PolymorphismDemo {
    public static void main(String[] args) {
        // 父类引用指向子类对象
        Shape[] shapes = {
            new Circle("red", 5.0),
            new Rectangle("blue", 4.0, 6.0),
            new Circle("green", 3.0)
        };

        // 多态调用
        for (Shape shape : shapes) {
            shape.display(); // 运行时确定调用哪个方法
            System.out.println("Area: " + shape.getArea());
            System.out.println("---");
        }
    }
}
```

### 4.4 多态的优势

## 5. 方法重写与重载

### 5.1 方法重写（Override）

#### 5.1.1 重写的定义

重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心重写，重写的好处在于子类可以根据需要，定义特定于自己的行为。

#### 5.1.2 重写的规则

| 规则类别       | 具体要求                                                             |
| -------------- | -------------------------------------------------------------------- |
| **方法签名**   | 参数列表必须完全与被重写的方法相同                                   |
| **返回类型**   | 必须与被重写的方法的返回类型相同或是其子类型                         |
| **访问修饰符** | 访问修饰符的限制一定要大于等于被重写方法的访问修饰符                 |
| **异常处理**   | 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 |

#### 5.1.3 重写示例

```java
class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }

    protected void sleep() {
        System.out.println("Animal is sleeping");
    }

    public Animal reproduce() {
        return new Animal();
    }
}

class Dog extends Animal {
    // 正确的重写
    @Override
    public void makeSound() {
        System.out.println("Dog barks: Woof!");
    }

    // 扩大访问权限（正确）
    @Override
    public void sleep() {
        System.out.println("Dog is sleeping in the doghouse");
    }

    // 返回子类型（协变返回类型，正确）
    @Override
    public Dog reproduce() {
        return new Dog();
    }
}
```

#### 5.1.4 @Override 注解的作用

```java
class Parent {
    public void method1() { }
    public void method2(String str) { }
}

class Child extends Parent {
    // @Override注解帮助编译器检查是否正确重写
    @Override
    public void method1() { } // 正确重写

    // 如果没有@Override，这个错误可能不会被发现
    // @Override
    // public void method2(int num) { } // 编译错误：没有找到要重写的方法
}
```

### 5.2 方法重载（Overload）

#### 5.2.1 重载的定义

重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法都必须有一个独一无二的参数类型列表。

#### 5.2.2 重载的规则

| 规则类别       | 具体要求                             |
| -------------- | ------------------------------------ |
| **方法名**     | 必须相同                             |
| **参数列表**   | 必须不同（参数个数、类型或顺序不同） |
| **返回类型**   | 可以相同也可以不同                   |
| **访问修饰符** | 可以不同                             |
| **异常处理**   | 可以抛出不同的异常                   |

#### 5.2.3 重载示例

```java
public class MathUtils {
    // 基本的加法方法
    public int add(int a, int b) {
        return a + b;
    }

    // 重载：参数个数不同
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // 重载：参数类型不同
    public double add(double a, double b) {
        return a + b;
    }

    // 重载：参数类型不同
    public String add(String a, String b) {
        return a + b;
    }

    // 重载：参数顺序不同
    public String combine(String str, int num) {
        return str + num;
    }

    public String combine(int num, String str) {
        return num + str;
    }

    // 重载：可变参数
    public int add(int... numbers) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
}
```

### 5.3 重写与重载的区别对比

| 对比维度       | 重写（Override）       | 重载（Overload）       |
| -------------- | ---------------------- | ---------------------- |
| **英文名称**   | Override               | Overload               |
| **定义范围**   | 父类与子类之间         | 同一个类内部           |
| **方法名**     | 必须相同               | 必须相同               |
| **参数列表**   | 必须完全相同           | 必须不同               |
| **返回类型**   | 必须相同或协变         | 可以不同               |
| **访问修饰符** | 不能缩小访问权限       | 可以不同               |
| **异常处理**   | 不能抛出更宽泛的异常   | 可以不同               |
| **多态性**     | 运行时多态             | 编译时多态             |
| **绑定时机**   | 运行时绑定（动态绑定） | 编译时绑定（静态绑定） |

### 5.4 重写与重载的最佳实践

#### 5.4.1 重写最佳实践

```java
public abstract class Vehicle {
    protected String brand;
    protected double speed;

    // 抽象方法，强制子类实现
    public abstract void start();

    // 可重写的方法
    public void accelerate(double increment) {
        speed += increment;
        System.out.println(brand + " is accelerating to " + speed + " km/h");
    }
}

public class Car extends Vehicle {
    private int gear;

    public Car(String brand) {
        this.brand = brand;
        this.gear = 1;
    }

    // 必须实现抽象方法
    @Override
    public void start() {
        System.out.println(brand + " car engine started");
        speed = 0;
        gear = 1;
    }

    // 重写父类方法，添加特定逻辑
    @Override
    public void accelerate(double increment) {
        // 先调用父类方法
        super.accelerate(increment);

        // 添加子类特定逻辑
        if (speed > 50 && gear < 5) {
            gear++;
            System.out.println("Shifted to gear " + gear);
        }
    }
}
```

#### 5.4.2 重载最佳实践

```java
public class StringProcessor {
    // 基础方法
    public String process(String input) {
        return input.trim().toLowerCase();
    }

    // 重载：添加处理选项
    public String process(String input, boolean toUpperCase) {
        String result = input.trim();
        return toUpperCase ? result.toUpperCase() : result.toLowerCase();
    }

    // 重载：批量处理
    public String[] process(String[] inputs) {
        String[] results = new String[inputs.length];
        for (int i = 0; i < inputs.length; i++) {
            results[i] = process(inputs[i]);
        }
        return results;
    }

    // 重载：自定义分隔符处理
    public String process(String input, String delimiter, boolean join) {
        String[] parts = input.split(delimiter);
        if (join) {
            return String.join(" ", parts).trim();
        } else {
            return String.join(delimiter, parts);
        }
    }
}
```

## 6. 抽象类（Abstract Class）

## 6. 抽象类（Abstract Class）

### 6.1 抽象类的定义

使用 `abstract class` 来定义抽象类。如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。

### 6.2 抽象类的特点

| 特点               | 说明                                   |
| ------------------ | -------------------------------------- |
| **不能实例化**     | 不能使用 `new` 关键字创建抽象类的对象  |
| **可以有构造方法** | 用于子类调用，初始化抽象类的成员变量   |
| **可以有抽象方法** | 使用 `abstract` 关键字声明，没有方法体 |
| **可以有具体方法** | 普通方法，有完整的方法体实现           |
| **可以有成员变量** | 包括实例变量和静态变量                 |
| **必须被继承**     | 只有通过继承才能使用                   |

### 6.3 抽象方法

Abstract 关键字用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

```java
public abstract class Shape {
    protected String color;
    protected double x, y; // 位置坐标

    // 构造方法
    public Shape(String color, double x, double y) {
        this.color = color;
        this.x = x;
        this.y = y;
    }

    // 抽象方法：计算面积
    public abstract double calculateArea();

    // 抽象方法：计算周长
    public abstract double calculatePerimeter();

    // 具体方法：移动图形
    public void move(double deltaX, double deltaY) {
        this.x += deltaX;
        this.y += deltaY;
        System.out.println("Shape moved to (" + x + ", " + y + ")");
    }

    // 具体方法：获取信息
    public String getInfo() {
        return "Color: " + color + ", Position: (" + x + ", " + y + ")";
    }

    // 具体方法：设置颜色
    public void setColor(String color) {
        this.color = color;
    }
}

// 具体子类：圆形
public class Circle extends Shape {
    private double radius;

    public Circle(String color, double x, double y, double radius) {
        super(color, x, y);
        this.radius = radius;
    }

    // 实现抽象方法
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }

    // 特有方法
    public double getRadius() {
        return radius;
    }
}

// 具体子类：矩形
public class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(String color, double x, double y, double width, double height) {
        super(color, x, y);
        this.width = width;
        this.height = height;
    }

    // 实现抽象方法
    @Override
    public double calculateArea() {
        return width * height;
    }

    @Override
    public double calculatePerimeter() {
        return 2 * (width + height);
    }

    // 特有方法
    public double getWidth() { return width; }
    public double getHeight() { return height; }
}
```

### 6.4 抽象类的使用场景

**模板方法模式**：定义算法骨架，让子类实现具体步骤

```java
public abstract class DataProcessor {
    // 模板方法：定义处理流程
    public final void processData() {
        loadData();
        validateData();
        transformData();
        saveData();
        cleanup();
    }

    // 抽象方法：由子类实现
    protected abstract void loadData();
    protected abstract void transformData();
    protected abstract void saveData();

    // 具体方法：通用实现
    protected void validateData() {
        System.out.println("Validating data format...");
    }

    protected void cleanup() {
        System.out.println("Cleaning up resources...");
    }
}

public class FileDataProcessor extends DataProcessor {
    private String filePath;

    public FileDataProcessor(String filePath) {
        this.filePath = filePath;
    }

    @Override
    protected void loadData() {
        System.out.println("Loading data from file: " + filePath);
    }

    @Override
    protected void transformData() {
        System.out.println("Transforming file data...");
    }

    @Override
    protected void saveData() {
        System.out.println("Saving processed file data...");
    }
}
```

### 6.5 抽象类的继承规则

**抽象类可以实现（implements）接口**：

```java
interface Drawable {
    void draw();
}

interface Colorable {
    void setColor(String color);
    String getColor();
}

public abstract class AbstractShape implements Drawable, Colorable {
    protected String color;

    // 实现接口方法
    @Override
    public void setColor(String color) {
        this.color = color;
    }

    @Override
    public String getColor() {
        return color;
    }

    // 抽象方法
    public abstract double getArea();

    // draw方法可以在这里实现，也可以保持抽象
    // 这里选择提供默认实现
    @Override
    public void draw() {
        System.out.println("Drawing a " + color + " shape");
    }
}
```

**抽象类可以继承具体类**：

```java
public class BaseEntity {
    protected Long id;
    protected Date createTime;

    public BaseEntity() {
        this.createTime = new Date();
    }

    // getter和setter方法
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
}

public abstract class AbstractUser extends BaseEntity {
    protected String username;
    protected String email;

    // 抽象方法
    public abstract boolean authenticate(String password);

    // 具体方法
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
}
```

**抽象类也可以继承抽象类**：

```java
public abstract class Animal {
    public abstract void makeSound();
    public abstract void move();
}

public abstract class Mammal extends Animal {
    protected boolean isWarmBlooded = true;

    // 实现父类的一个抽象方法
    @Override
    public void move() {
        System.out.println("Mammal moves on land");
    }

    // 添加新的抽象方法
    public abstract void giveMilk();

    // 具体方法
    public boolean isWarmBlooded() {
        return isWarmBlooded;
    }
}

public class Dog extends Mammal {
    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }

    @Override
    public void giveMilk() {
        System.out.println("Dog feeds puppies with milk");
    }
}
```

## 7. 接口（Interface）

### 7.1 接口的定义

接口（Interface）在 Java 中是一个抽象类型，是抽象方法的集合，接口通常以 `interface` 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。

### 7.2 接口的特点

| 特点       | Java 8 之前                       | Java 8+                            |
| ---------- | --------------------------------- | ---------------------------------- |
| **方法**   | 只能有抽象方法                    | 可以有抽象方法、默认方法、静态方法 |
| **变量**   | 只能有常量（public static final） | 同左                               |
| **实例化** | 不能实例化                        | 不能实例化                         |
| **继承**   | 接口可以继承接口，支持多重继承    | 同左                               |
| **实现**   | 类可以实现多个接口                | 同左                               |

### 7.3 接口的基本语法

```java
// 基础接口定义
public interface Flyable {
    // 常量（默认是 public static final）
    double MAX_SPEED = 1000.0;

    // 抽象方法（默认是 public abstract）
    void fly();
    void land();
    double getAltitude();
}

// 接口继承接口
public interface SuperSonicFlyable extends Flyable {
    void breakSoundBarrier();

    // Java 8+ 默认方法
    default void announceSpeed() {
        System.out.println("Flying at supersonic speed!");
    }

    // Java 8+ 静态方法
    static double convertMachToKmh(double mach) {
        return mach * 1234.8; // 简化计算
    }
}

// 多接口实现
public class Fighter implements SuperSonicFlyable, Weaponized {
    private double altitude;
    private boolean isFlying;

    @Override
    public void fly() {
        isFlying = true;
        altitude = 1000;
        System.out.println("Fighter jet is flying at " + altitude + " meters");
    }

    @Override
    public void land() {
        isFlying = false;
        altitude = 0;
        System.out.println("Fighter jet has landed");
    }

    @Override
    public double getAltitude() {
        return altitude;
    }

    @Override
    public void breakSoundBarrier() {
        System.out.println("Boom! Sound barrier broken!");
    }

    @Override
    public void fireWeapon() {
        System.out.println("Missile launched!");
    }
}
```

### 7.4 接口的高级特性（Java 8+）

#### 7.4.1 默认方法（Default Methods）

```java
public interface Collection<E> {
    // 抽象方法
    boolean add(E element);
    boolean remove(E element);
    int size();

    // 默认方法
    default boolean isEmpty() {
        return size() == 0;
    }

    default void clear() {
        // 默认实现
        Iterator<E> iterator = iterator();
        while (iterator.hasNext()) {
            iterator.next();
            iterator.remove();
        }
    }

    // Java 8新增的默认方法
    default Stream<E> stream() {
        return StreamSupport.stream(spliterator(), false);
    }
}
```

#### 7.4.2 静态方法（Static Methods）

```java
public interface MathUtils {
    // 静态方法
    static int max(int a, int b) {
        return a > b ? a : b;
    }

    static int min(int a, int b) {
        return a < b ? a : b;
    }

    static double calculateCircleArea(double radius) {
        return Math.PI * radius * radius;
    }

    // 私有静态方法（Java 9+）
    private static void validateInput(double value) {
        if (value < 0) {
            throw new IllegalArgumentException("Value must be non-negative");
        }
    }
}

// 使用静态方法
public class Calculator {
    public void doCalculation() {
        int maxValue = MathUtils.max(10, 20); // 直接调用接口静态方法
        double area = MathUtils.calculateCircleArea(5.0);
    }
}
```

### 7.5 接口继承

**接口可以继承接口，且支持多重继承**：

```java
// 基础接口
interface Readable {
    String read();
}

interface Writable {
    void write(String data);
}

interface Closeable {
    void close();
}

// 接口多重继承
interface ReadWriteCloseable extends Readable, Writable, Closeable {
    // 可以添加新方法
    boolean isOpen();

    // 默认方法
    default void readAndWrite() {
        String data = read();
        write("Processed: " + data);
    }
}

// 实现多重继承的接口
public class FileHandler implements ReadWriteCloseable {
    private boolean isOpen = true;
    private StringBuilder buffer = new StringBuilder();

    @Override
    public String read() {
        return buffer.toString();
    }

    @Override
    public void write(String data) {
        buffer.append(data);
    }

    @Override
    public void close() {
        isOpen = false;
        buffer.setLength(0);
    }

    @Override
    public boolean isOpen() {
        return isOpen;
    }
}
```

### 7.6 函数式接口（Functional Interface）

```java
// 函数式接口（只有一个抽象方法）
@FunctionalInterface
public interface Processor<T, R> {
    R process(T input);

    // 可以有默认方法
    default void preProcess() {
        System.out.println("Pre-processing...");
    }

    // 可以有静态方法
    static void printInfo() {
        System.out.println("This is a processor interface");
    }
}

// 使用Lambda表达式
public class FunctionalExample {
    public void demonstrateFunctionalInterface() {
        // Lambda表达式实现
        Processor<String, String> upperCaseProcessor =
            input -> input.toUpperCase();

        // 方法引用
        Processor<String, Integer> lengthProcessor = String::length;

        // 使用
        String result = upperCaseProcessor.process("hello");
        Integer length = lengthProcessor.process("hello");
    }
}
```

## 8. 抽象类与接口的对比

### 8.1 相同点

-   **都不能被实例化**
-   **接口的实现类或抽象类的子类需实现接口或抽象类中相应的方法才能被实例化**

### 8.2 不同点

| 对比维度       | 抽象类                             | 接口                                                     |
| -------------- | ---------------------------------- | -------------------------------------------------------- |
| **关键字**     | extends                            | implements                                               |
| **继承数量**   | 单继承（一个类只能继承一个抽象类） | 多实现（一个类可以实现多个接口）                         |
| **方法类型**   | 可以有抽象方法和具体方法           | Java 8 前只能有抽象方法，Java 8+可以有默认方法和静态方法 |
| **变量类型**   | 可以有实例变量、常量、静态变量     | 只能有常量（public static final）                        |
| **构造方法**   | 可以有构造方法                     | 不能有构造方法                                           |
| **访问修饰符** | 可以有各种访问修饰符               | 方法默认 public，变量默认 public static final            |
| **设计目的**   | 提供通用的基础实现                 | 定义规范和契约                                           |

### 8.3 使用场景选择

#### 8.3.1 选择抽象类的情况

**有共同的实现代码**：

```java
public abstract class Employee {
    protected String name;
    protected String id;
    protected double baseSalary;

    // 通用实现
    public String getEmployeeInfo() {
        return "ID: " + id + ", Name: " + name;
    }

    // 抽象方法，由子类实现
    public abstract double calculateSalary();
}

public class FullTimeEmployee extends Employee {
    private double bonus;

    @Override
    public double calculateSalary() {
        return baseSalary + bonus;
    }
}
```

**需要定义非 public 的方法**：

```java
public abstract class DataAccess {
    // protected方法，只对子类可见
    protected void logAccess(String operation) {
        System.out.println("Accessing: " + operation);
    }

    // private方法，只在本类使用
    private void validateConnection() {
        // 验证连接
    }

    public abstract void connect();
}
```

#### 8.3.2 选择接口的情况

**定义契约和规范**：

```java
public interface PaymentProcessor {
    boolean processPayment(double amount, String currency);
    boolean refund(String transactionId, double amount);
    PaymentStatus getPaymentStatus(String transactionId);
}

// 不同的支付方式实现
public class CreditCardProcessor implements PaymentProcessor {
    // 实现信用卡支付逻辑
}

public class PayPalProcessor implements PaymentProcessor {
    // 实现PayPal支付逻辑
}
```

**需要多重继承的能力**：

```java
public class SmartPhone implements Callable, Photographable, Playable, Connectable {
    // 实现多个接口的方法
    @Override
    public void makeCall(String number) { }

    @Override
    public void takePhoto() { }

    @Override
    public void playMusic() { }

    @Override
    public void connectWifi() { }
}
```

### 8.4 设计建议

**优先使用接口**：

-   当子类和父类之间不存在明显的层次关系时
-   当希望支持差别较大的两个或更多对象间的特定交互行为时
-   使用接口能降低软件系统的耦合度，便于日后维护或添加删除方法

**使用抽象类**：

-   当子类和父类之间存在逻辑上的层次结构时，推荐使用抽象类
-   有利于功能的累积和代码复用
-   需要在多个相关类间共享代码时

## 9. 枚举（Enum）

### 9.1 枚举的定义

枚举是一种特殊的类，用于定义常量组。枚举可以包含字段、方法和构造器，枚举的实例是固定的。

```java
// 简单枚举
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

// 带属性的枚举
public enum Planet {
    MERCURY(3.303e+23, 2.4397e6),
    VENUS(4.869e+24, 6.0518e6),
    EARTH(5.976e+24, 6.37814e6),
    MARS(6.421e+23, 3.3972e6);

    private final double mass;   // 质量（千克）
    private final double radius; // 半径（米）

    // 构造器
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }

    // 方法
    public double getMass() { return mass; }
    public double getRadius() { return radius; }

    public double surfaceGravity() {
        return 6.67300E-11 * mass / (radius * radius);
    }
}
```

### 9.2 枚举的特点

-   枚举是线程安全的
-   枚举实现了 Comparable 和 Serializable 接口
-   可以添加属性、方法和构造器
-   可以实现接口
-   每个枚举常量都是该枚举类型的一个实例

## 10. 总结

### 10.1 面向对象设计原则

**SOLID 原则**：

-   **S - 单一职责原则**：一个类应该只有一个引起它变化的原因
-   **O - 开闭原则**：对扩展开放，对修改关闭
-   **L - 里氏替换原则**：子类对象应该能够替换父类对象
-   **I - 接口隔离原则**：不应该强迫客户依赖它们不使用的接口
-   **D - 依赖倒置原则**：高层模块不应该依赖低层模块，两者都应该依赖抽象

### 10.2 面向对象编程的优势

**代码复用**：通过继承和组合实现
**模块化设计**：将复杂系统分解为简单模块
**易于维护**：修改某个类不影响其他类
**易于扩展**：通过继承和多态轻松扩展功能
**代码可读性**：面向对象代码更接近人类思维方式

Java 的面向对象特性为开发大型、复杂的应用程序提供了强大的支持，通过合理运用封装、继承、多态等特性，可以构建出结构清晰、易于维护和扩展的软件系统。
