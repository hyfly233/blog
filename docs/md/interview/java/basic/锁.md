## 锁相关

### 什么是乐观锁和悲观锁

乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像 synchronized，不管三七二十一，直接上了锁就操作资源了。

### 聊聊 ReentrantLock 吧

ReentrantLock 意为可重入锁，说起 ReentrantLock 就不得不说 AQS ，因为其底层就是使用 AQS 去实现的。

ReentrantLock 有两种模式，一种是公平锁，一种是非公平锁。

-   公平模式下等待线程入队列后会严格按照队列顺序去执行
-   非公平模式下等待线程入队列后有可能会出现插队情况

公平锁

![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687052025-2bf96a70-b543-496a-9fbc-2a6a8fbab5dc.png)

-   第一步：获取状态的 state 的值

-   -   如果 state=0 即代表锁没有被其它线程占用，执行第二步。
    -   如果 state!=0 则代表锁正在被其它线程占用，执行第三步。

-   第二步：判断队列中是否有线程在排队等待

-   -   如果不存在则直接将锁的所有者设置成当前线程，且更新状态 state 。
    -   如果存在就入队。

-   第三步：判断锁的所有者是不是当前线程

-   -   如果是则更新状态 state 的值。
    -   如果不是，线程进入队列排队等待。

非公平锁

![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051916-02b67ed2-b1b3-4391-9200-9f9f7d1c5836.png)

-   获取状态的 state 的值

-   -   如果 state=0 即代表锁没有被其它线程占用，则设置当前锁的持有者为当前线程，该操作用 CAS 完成。
    -   如果不为 0 或者设置失败，代表锁被占用进行下一步。

-   此时获取 state 的值

-   -   如果是，则给 state+1，获取锁
    -   如果不是，则进入队列等待
    -   如果是 0，代表刚好线程释放了锁，此时将锁的持有者设为自己
    -   如果不是 0，则查看线程持有者是不是自己

### 24.synchronized 锁升级的过程

在 Java1.6 之前的版本中，synchronized 属于重量级锁，效率低下，锁是 cpu 一个总量级的资源，每次获取锁都要和 cpu 申请，非常消耗性能。

在 jdk1.6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Jdk1.6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁，增加了锁升级的过程，由无锁->偏向锁->自旋锁->重量级锁 ![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687052049-ef2ad665-a5b2-4845-9565-4e19613f7568.png)

增加锁升级的过程主要是减少用户态到核心态的切换，提高锁的效率，从 jvm 层面优化锁

### synchronized 关键字的用法？

synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用 synchronized(对象) { … }定义同步代码块，或者在声明方法时将 synchronized 作为方法的修饰符。

### 简述 synchronized 和 java.util.concurrent.locks.Lock 的异同？

Lock 是 Java 5 以后引入的新的 API，和关键字 synchronized 相比主要相同点：Lock 能完成 synchronized 所实现的所有功能；主要不同点：Lock 有比 synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。

### 当一个线程进入一个对象的 synchronized 方法 A 之后，其它线程是否可进入此对象的 synchronized 方法 B？

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入 A 方法说明对象锁已经被取走，那么试图进入 B 方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

### synchronized 和 ReentrantLock 的区别

synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质区别。既然 ReentrantLock 是类，那么它就提供了比 synchronized 更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock 比 synchronized 的扩展性体现在几点上：

1. ReentrantLock 可以对获取锁的等待时间进行设置，这样就避免了死锁
2. ReentrantLock 可以获取各种锁的信息
3. ReentrantLock 可以灵活地实现多路通知

另外，二者的锁机制其实也是不一样的:ReentrantLock 底层调用的是 Unsafe 的 park 方法加锁，synchronized 操作的应该是对象头中 mark word.

### synchronized 关键字加在静态方法和实例方法的区别?

修饰静态方法，是对类进行加锁，如果该类中有 methodA 和 methodB 都是被 synchronized 修饰的静态 方法，此时有两个线程 T1、T2 分别调用 methodA()和 methodB()，则 T2 会阻塞等待直到 T1 执行完成之后 才能执行。 修饰实例方法时，是对实例进行加锁，锁的是实例对象的对象头，如果调用同一个对象的两个不同的被 synchronized 修饰的实例方法时，看到的效果和上面的一样，如果调用不同对象的两个不同的被 synchronized 修饰的实例方法时，则不会阻塞。

### 18.countdownlatch 的用法？

两种用法： 1、让主线程 await，业务线程进行业务处理，处理完成时调用 countdownLatch.countDown()， CountDownLatch 实例化的时候需要根据业务去选择 CountDownLatch 的 count; 2、让业务线程 await，主线程处理完数据之后进行 countdownLatch.countDown()，此时业务线程被唤 醒，然后去主线程拿数据，或者执行自己的业务逻辑。

### synchronize 实现原理

[以下资源来源](https://github.com/crossoverJie/Java-Interview/blob/master/MD/Synchronize.md)

众所周知 Synchronize 关键字是解决并发问题常用解决方案，有以下三种使用方式:

-   同步普通方法，锁的是当前对象。
-   同步静态方法，锁的是当前 Class 对象。
-   同步块，锁的是 {} 中的对象。

实现原理： JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。

具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。

其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。

流程图如下:

![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051874-faa73eb9-9a6a-4678-bbea-e0b517629b14.png)

synchronize 很多都称之为重量锁，JDK1.6 中对 synchronize 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁。

轻量锁

当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。

如果更新成功，当前线程就获得了锁。

如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。

如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。

不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，轻量锁就会膨胀为重量锁。

解锁

轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁)

轻量锁能提升性能的原因是：

认为大多数锁在整个同步周期都不存在竞争，所以使用 CAS 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，甚至比重量锁更慢。

偏向锁

为了进一步的降低获取锁的代价，JDK1.6 之后还引入了偏向锁。

偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。

当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。

释放锁

当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。

偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 -XX:-userBiasedLocking=false 来关闭偏向锁，并默认进入轻量锁。

### 23.Sychornized 是否是公平锁？

不是公平锁

26.描述一下锁的四种状态及升级过程？

以下是 32 位的对象头描述 public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } synchronized 锁的膨胀过程： 当线程访问同步代码块。首先查看当前锁状态是否是偏向锁(可偏向状态) 1、如果是偏向锁： 1.1、检查当前 mark word 中记录是否是当前线程 id，如果是当前线程 id，则获得偏向锁执行同步代码 块。 1.2、如果不是当前线程 id，cas 操作替换线程 id，替换成功获得偏向锁(线程复用)，替换失败锁撤销升 级轻量锁(同一类对象多次撤销升级达到阈值 20，则批量重偏向,这个点可以稍微提一下,详见下面的注意) 2、升级轻量锁

### 如何预防死锁

1. 首先需要将死锁发生的是个必要条件讲出来：

1.  1. 互斥条件：同一时间只能有一个线程获取资源
    2. 不可剥夺条件：一个线程已经占有的资源，在释放之前不会被其它线程抢占
    3. 请求和保持条件：线程等待过程中不会释放已占有的资源
    4. 循环等待条件：多个线程互相等待对方释放资源

1. 预防死锁，就是需要破坏这四个必要条件

1.  1. 由于资源互斥是资源使用的固有特性，无法改变，不讨论
    2. 破坏不可剥夺条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将 被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进 程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行
    3. 破坏请求与保持条件：

1.  1.  1. 第一种方法是，静态分配即每个进程在开始执行时就申请他所需要的全部资源
    2. 第二种是，动态分配即每个进程在申请所需要的资源时，他本身不占用系统资源

1.  1. 破坏循环等待条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的 采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小 编号的进程才能申请较大编号的进程

### 产生死锁的条件

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### Java 当中有哪几种锁

自旋锁: 自旋锁在 JDK1.6 之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在 jdk6 之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定

偏向锁: 在 JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。

轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在 Java SE1.6 里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁

### 简述 Java 偏向锁

JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。

其申请流程为：

-   首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；
-   判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤 4；
-   判断是否需要重偏向。如果不用的话，直接获得偏向锁；
-   利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。

### 简述轻量级锁

轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。

其申请流程为：

-   如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。
-   虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针
-   如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。
-   如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧
-   如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行
-   如果不是则说明锁对象已经被其他线程抢占。
-   如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时 Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。

### 简述锁优化策略

即自适应自旋、锁消除、锁粗化、锁升级等策略偏。

### 简述 Java 的自旋锁

线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。

### 简述自适应自旋锁

自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。

### 简述锁粗化

锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。

### 简述锁消除

锁消除是一种更为彻底的优化，在编译时，Java 编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。

### 简述 Lock 与 ReentrantLock

Lock 接口是 Java 并发包的顶层接口。

可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。

# 变量的线程安全问题

## 成员变量和静态变量

-   没有共享，线程安全
-   被共享，分两种情况：

-   -   只读，线程安全
    -   有写操作，该变量是临界区，则需要考虑线程安全

## 局部变量

-   局部变量本身是线程安全的
-   局部变量引用的对象不一定是线程安全的

-   -   如果该引用的对象只存在于该函数的作用域中，则是线程安全

```java
public static void test1() {
    int i = 10;
    i++;
}
```

-   -   如果使用`return 语句`返回该引用对象，则需要考虑线程安全问题

### 简述 as-if-serial

编译器会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致

### 简述 happens-before 八大规则

-   程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
-   锁定规则：一个 unLock 操作先行发生于后面对同一个锁的 lock 操作；
-   volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
-   传递规则：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C；
-   线程启动规则：Thread 对象的 start()方法先行发生于此线程的每个一个动作；
-   线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
-   线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
-   对象终结规则：一个对象的初始化完成先行发生于他的 finalize()方法的开始；

### as-if-serial 和 happens-before 的区别

as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。

### 简述原子性操作

一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。

### 简述线程的可见性

可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile、synchronized、final 关键字都能保证可见性。

### 简述有序性

虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。

### 简述 Java 中 volatile 关键字作用

-   保证变量对所有线程的可见性。当一个线程修改了变量值，新值对于其他线程来说是立即可以得知的。
-   禁止指令重排。使用 volatile 变量进行写操作，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器进行重排序。

### Java 线程的实现方式

-   实现 Runnable 接口
-   继承 Thread 类
-   实现 Callable 接口

### 简述 Java 线程的状态

线程状态有 NEW、RUNNABLE、BLOCK、WAITING、TIMED_WAITING、THERMINATED

-   NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。
-   RUNNABLE：运行状态。表示线程正在 JVM 中执行，但是这个执行，不一定真的在跑，也可能在排队等 CPU。
-   BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。
-   WAITING：等待状态。线程内 run 方法执行完 Object.wait()/Thread.join()进入该状态。
-   TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用 Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。
-   TERMINATED：结束状态。线程调用完 run 方法进入该状态。

### 简述线程通信的方式

-   volatile 关键词修饰变量，保证所有线程对变量访问的可见性。
-   synchronized 关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。
-   wait/notify 方法
-   IO 通信

### 简述线程池

没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后复用已创建的线程，可以降低开销、控制最大并发数。

线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。

将任务派发给线程池时，会出现以下几种情况

-   核心线程池未满，创建一个新的线程执行任务。
-   如果核心线程池已满，工作队列未满，将线程存储在工作队列。
-   如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。
-   如果超过大小线程数，按照拒绝策略来处理任务。

线程池参数：

-   corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。
-   maximumPoolSize：线程池能够容纳同时执行的线程最大数。
-   keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。
-   workQueue：工作队列。
-   threadFactory：线程工厂，用来生产一组相同任务的线程。
-   handler：拒绝策略。

拒绝策略有以下几种：

-   AbortPolicy：丢弃任务并抛出异常
-   CallerRunsPolicy：重新尝试提交该任务
-   DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列
-   DiscardPolicy 表示直接抛弃当前任务但不抛出异常。

### 简述 Executor 框架

Executor 框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用 Executor 框架实现类的 Execute 方法就可以提交任务。

### 简述 Executor 的继承关系

-   Executor：一个接口，其定义了一个接收 Runnable 对象的方法 executor，该方法接收一个 Runable 实例执行这个任务。
-   ExecutorService：Executor 的子类接口，其定义了一个接收 Callable 对象的方法，返回 Future 对象，同时提供 execute 方法。
-   ScheduledExecutorService：ExecutorService 的子类接口，支持定期执行任务。
-   AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。
-   Executors：实现 ExecutorService 接口的静态工厂类，提供了一系列工厂方法用于创建线程池。
-   ThreadPoolExecutor：继承 AbstractExecutorService，用于创建线程池。
-   ForkJoinPool: 继承 AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于 map reduce。
-   ThreadPoolExecutor：继承 ThreadPoolExecutor，实现 ScheduledExecutorService，用于创建带定时任务的线程池。

### 简述线程池的状态

-   Running：能接受新提交的任务，也可以处理阻塞队列的任务。
-   Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于 running 时调用 shutdown 方法，会进入该状态。
-   Stop：不接受新任务，不处理存量任务，调用 shutdownnow 进入该状态。
-   Tidying：所有任务已经终止了，worker_count（有效线程数）为 0。
-   Terminated：线程池彻底终止。在 tidying 模式下调用 terminated 方法会进入该状态。

### 简述线程池类型

-   newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲 1 分钟后自动销毁。
-   newFixedThreadPool 指定工作线程数量线程池。
-   newSingleThreadExecutor 单线程 Executor。
-   newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。
-   newSingleThreadScheduledExecutor 支持定时任务的单线程 Executor。

### 简述阻塞队列

阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：

-   ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。
-   LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。
-   PriorityBlockingQueue：阻塞优先队列。
-   DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素
-   SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作
-   LinkedTransferQueue：与 LinkedBlockingQueue 相比多一个 transfer 方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。
-   LinkedBlockingDeque：双向阻塞队列。

### 谈一谈 ThreadLocal

ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap 是每个线程私有的。

-   set 给 ThreadLocalMap 设置值。
-   get 获取 ThreadLocalMap。
-   remove 删除 ThreadLocalMap 类型的对象。

存在的问题：对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。

比如说内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。

### 聊聊你对 Java 并发包下 unsafe 类的理解

对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。

Java 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。

### Java 中的乐观锁与 CAS 算法

乐观锁认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。

到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。

乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。

CAS 算法的思路如下：

-   该算法认为不同线程对变量的操作时产生竞争的情况比较少。
-   该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。
-   如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。
-   如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。

### ABA 问题及解决方法简述

CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。

juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。

### 简述常见的 Atomic 类

在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者--方案，使用 synchronized 关键字和 lock 固然可以实现，但代价比较大，此时用原子类更加方便。基本数据类型的原子类有：

-   AtomicInteger 原子更新整型
-   AtomicLong 原子更新长整型
-   AtomicBoolean 原子更新布尔类型

Atomic 数组类型有：

-   AtomicIntegerArray 原子更新整型数组里的元素
-   AtomicLongArray 原子更新长整型数组里的元素
-   AtomicReferenceArray 原子更新引用类型数组里的元素。

Atomic 引用类型有：

-   AtomicReference 原子更新引用类型
-   AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记
-   AtomicStampedReference 原子更新带有版本号的引用类型

FieldUpdater 类型：

-   AtomicIntegerFieldUpdater 原子更新整型字段的更新器
-   AtomicLongFieldUpdater 原子更新长整型字段的更新器
-   AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器

### 简述 Atomic 类基本实现原理

以 AtomicIntger 为例。

方法 getAndIncrement，以原子方式将当前的值加 1，具体实现为：

-   在 for 死循环中取得 AtomicInteger 里存储的数值
-   对 AtomicInteger 当前的值加 1
-   调用 compareAndSet 方法进行原子更新
-   先检查当前数值是否等于 expect
-   如果等于则说明当前值没有被其他线程修改，则将值更新为 next，
-   如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。

### 简述 CountDownLatch

CountDownLatch 这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用 countDown 方法，计数器的值就减 1，当计数器的值为 0 时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。只能一次性使用，不能 reset。

### 简述 CyclicBarrier

CyclicBarrier 主要功能和 CountDownLatch 类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。

### 简述 Semaphore

Semaphore 即信号量。Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为 0，线程进入休眠。

### 简述 Exchanger

Exchanger 类可用于两个线程之间交换信息。可简单地将 Exchanger 对象理解为一个包含两个格子的容器，通过 exchanger 方法可以向两个格子中填充信息。线程通过 exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。

### 简述 ConcurrentHashMap

JDK7 采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。

get 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列算法定位到元素。put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。

JDK8 的改进

-   取消分段锁机制，采用 CAS 算法进行值的设置，如果 CAS 失败再使用 synchronized 加锁添加元素
-   引入红黑树结构，当某个槽内的元素个数超过 8 且 Node 数组 容量大于 64 时，链表转为红黑树。
-   使用了更加优化的方式统计集合内的元素数量。

### synchronized 底层实现原理

Java 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。

synchronized 在 JVM 编译后会产生 monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。

执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。

### synchronized 关键词使用方法

-   直接修饰某个实例方法
-   直接修饰某个静态方法
-   修饰代码块

###

### 简述 AQS

AQS（AbstractQuenedSynchronizer）抽象的队列式同步器。AQS 是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。AQS 是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。

子类通过继承同步器并实现它的抽象方法 getState、setState 和 compareAndSetState 对同步状态进行更改。

AQS 获取独占锁/释放独占锁原理：

获取：（acquire）

-   调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋。
-   调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。

释放：（release）

-   调用 tryRelease 方法释放同步状态
-   调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。

AQS 获取共享锁/释放共享锁原理

获取锁（acquireShared）

-   调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。
-   释放（releaseShared），并唤醒后续处于等待状态的节点。

### 导致 Java 的线程池被瞬间占满的原因是什么

导致 Java 线程池被瞬间占满的原因有很多，以下是一些常见的原因：

1.任务队列满了：当任务队列中的任务数量超过了线程池的最大容量，新提交的任务将会被拒绝执行。这时如果不进行适当的处理，就会导致线程池被瞬间占满。

2.任务执行时间过长：当某个任务执行的时间过长时，该任务会一直占用一个线程，这会导致该线程无法执行其他任务，从而使线程池中的其他线程都处于等待状态，最终导致线程池被占满。

3.线程池配置不当：如果线程池的核心线程数和最大线程数都设置得过小，当有大量任务提交时，线程池就会被瞬间占满。

4.线程阻塞：当线程在执行任务时被阻塞，例如等待 I/O 操作或者等待某个锁时，该线程会一直占用一个线程资源，如果这种情况发生在多个线程上，就会导致线程池被占满。

5.资源不足：如果系统中的资源不足，例如内存不足或者文件句柄数达到了上限，就可能导致线程池被占满。

为了避免线程池被瞬间占满，可以通过合理的线程池配置、任务队列大小的调整、任务执行时间的优化等方式进行处理。同时，应该对任务的性质和系统资源的状况进行充分的了解和评估，以便对线程池的配置进行合理的调整。

### 在 Spring Boot 的 Web 项目中，通过 controller 调用 service 操作数据库，需要考虑多线程问题吗

在 Spring Boot 的 Web 项目中，如果在 controller 中调用 service 操作数据库，一般不需要考虑多线程问题，因为 Spring 框架本身就是线程安全的。

Spring 框架使用了一种称为"Dependency Injection（依赖注入）"的技术，这种技术可以确保在同一时间只有一个线程访问每个 Bean 实例，避免了多线程并发访问时可能会出现的数据不一致或线程安全问题。

当然，如果在 service 层中有共享变量或全局变量等需要被多个线程访问的情况下，就需要考虑线程安全问题了，可以使用 synchronized 关键字或 Lock 接口来保证线程安全。

总之，在 Spring Boot 的 Web 项目中，如果使用了 Spring 框架的依赖注入功能，通常不需要过多考虑多线程问题，但是对于一些需要跨线程共享变量或全局状态的场景，需要考虑线程安全问题。

## cas 是什么

cas 叫做 CompareAndSwap，比较并交换，很多地方使用到了它，比如锁升级中自旋锁就有用到，主要是通过处理器的指令来保证操作的原子性，它主要包含三个变量：

-   1.变量内存地址
-   2.旧的预期值 A
-   3.准备设置的新值 B

当一个线程需要修改一个共享变量的值，完成这个操作需要先取出共享变量的值，赋给 A，基于 A 进行计算，得到新值 B，在用预期原值 A 和内存中的共享变量值进行比较，如果相同就认为其他线程没有进行修改，而将新值写入内存

![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1677824948632-47e0c41c-3cb4-4408-8ff8-3ae459bbe756.png)

CAS 的缺点

-   CPU 开销比较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，又因为自旋的时候会一直占用 CPU，如果 CAS 一直更新不成功就会一直占用，造成 CPU 的浪费。
-   ABA 问题：比如线程 A 去修改 1 这个值，修改成功了，但是中间 线程 B 也修改了这个值，但是修改后的结果还是 1，所以不影响 A 的操作，这就会有问题。可以用版本号来解决这个问题。
-   只能保证一个共享变量的原子性

# Java 锁机制详解

## 1. 锁的分类与概念

### 1.1 按照加锁策略分类

#### 乐观锁 (Optimistic Locking)

**核心思想**：假设并发冲突不会经常发生，因此不会在每次访问资源时都加锁。

**实现机制**：

-   采用比较-交换（Compare And Swap, CAS）操作
-   通过版本号、时间戳等方式检测数据是否被修改
-   如果检测到冲突，则重试或返回失败

**适用场景**：

-   读多写少的场景
-   并发冲突概率较低的业务
-   对性能要求较高的场景

**典型实现**：AtomicInteger、版本号机制、CAS 操作

#### 悲观锁 (Pessimistic Locking)

**核心思想**：假设并发冲突一定会发生，因此在访问资源前先获取锁。

**实现机制**：

-   通过互斥锁确保同一时刻只有一个线程访问资源
-   线程获取锁失败时会被阻塞
-   锁持有者释放锁后，等待线程被唤醒重新竞争

**适用场景**：

-   写操作较多的场景
-   并发冲突概率较高的业务
-   数据一致性要求严格的场景

**典型实现**：synchronized、ReentrantLock、数据库行锁

### 1.2 锁的特性对比

| 特性     | 乐观锁       | 悲观锁         |
| -------- | ------------ | -------------- |
| 加锁时机 | 更新时检查   | 访问前加锁     |
| 性能开销 | 低（无阻塞） | 高（线程阻塞） |
| 冲突处理 | 重试机制     | 等待机制       |
| 适用场景 | 读多写少     | 写多读少       |
| 典型应用 | CAS 操作     | synchronized   |

## 2. ReentrantLock 详解

### 2.1 基本概念

**ReentrantLock** (可重入锁) 是 Java 并发包中提供的显式锁实现，基于 AQS (AbstractQueuedSynchronizer) 构建。

**可重入性**：同一线程可以多次获取同一把锁，每次获取锁时计数器 +1，每次释放锁时计数器 -1，当计数器为 0 时锁才真正被释放。

### 2.2 公平锁与非公平锁

#### 公平锁 (Fair Lock)

**特点**：严格按照线程申请锁的顺序获取锁，FIFO 原则。

**获取流程**：

1. 检查 AQS 状态位 state

    - state = 0：锁未被占用，进入步骤 2
    - state ≠ 0：锁被占用，进入步骤 3

2. 锁未被占用时：

    - 检查等待队列是否有线程排队
    - 无排队：直接获取锁，设置线程为锁持有者
    - 有排队：加入队列末尾等待

3. 锁被占用时：
    - 检查当前线程是否为锁持有者
    - 是：state +1，实现重入
    - 否：加入队列等待

**代码示例**：

```java
// 创建公平锁
ReentrantLock fairLock = new ReentrantLock(true);
```

#### 非公平锁 (Non-fair Lock)

**特点**：线程获取锁的顺序与申请顺序无关，新来的线程可能比等待的线程更早获取到锁。

**获取流程**：

1. 直接尝试 CAS 操作修改 state

    - 成功：获取锁，设置线程为锁持有者
    - 失败：进入步骤 2

2. 检查锁持有者
    - 是当前线程：state +1，实现重入
    - 不是当前线程：加入队列等待

**代码示例**：

```java
// 创建非公平锁（默认）
ReentrantLock unfairLock = new ReentrantLock(false);
// 或者
ReentrantLock unfairLock = new ReentrantLock();
```

### 2.3 性能对比

| 特性     | 公平锁   | 非公平锁 |
| -------- | -------- | -------- |
| 吞吐量   | 较低     | 较高     |
| 延迟     | 可预测   | 不可预测 |
| 饥饿问题 | 不会发生 | 可能发生 |
| 默认选择 | 否       | 是       |

### 2.4 使用示例

```java
public class ReentrantLockExample {
    private final ReentrantLock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock();
        try {
            count++;
            // 可重入性演示
            recursiveMethod();
        } finally {
            lock.unlock();
        }
    }

    private void recursiveMethod() {
        lock.lock(); // 重入锁
        try {
            // 业务逻辑
            System.out.println("Current count: " + count);
        } finally {
            lock.unlock();
        }
    }
}

## 3. Synchronized 锁升级机制

### 3.1 锁升级背景

在 JDK 1.6 之前，`synchronized` 是重量级锁，性能较差。JDK 1.6 之后，JVM 对 `synchronized` 进行了大量优化，引入了锁升级机制，显著提升了性能。

### 3.2 锁升级路径

```

无锁 → 偏向锁 → 轻量级锁 → 重量级锁

````

**锁升级特点**：
- 只能升级，不能降级
- 根据竞争情况动态调整
- 从用户态优化到核心态切换

### 3.3 各锁状态详解

#### 无锁状态
- 对象未被任何线程锁定
- Mark Word 存储对象的 hashCode、GC 分代年龄等信息

#### 偏向锁 (Biased Lock)
**适用场景**：锁总是被同一个线程获取，没有多线程竞争

**工作原理**：
- 第一次获取锁时，在对象头记录线程 ID
- 后续该线程再次获取锁时，只需检查线程 ID，无需 CAS 操作
- 当其他线程尝试获取锁时，偏向锁被撤销

**优势**：几乎无性能开销

#### 轻量级锁 (Lightweight Lock)
**适用场景**：多个线程交替获取锁，但不同时竞争

**工作原理**：
1. 线程在栈帧中创建 Lock Record
2. 使用 CAS 将对象 Mark Word 复制到 Lock Record
3. CAS 将对象 Mark Word 更新为指向 Lock Record 的指针
4. 成功则获取锁，失败则自旋重试或升级为重量级锁

**解锁过程**：
- 使用 CAS 将 Lock Record 中的内容替换回对象 Mark Word
- 成功则释放完成，失败表明有竞争，需要唤醒等待线程

#### 重量级锁 (Heavyweight Lock)
**适用场景**：多个线程同时竞争锁

**工作原理**：
- 基于操作系统的互斥量（mutex）实现
- 竞争失败的线程会被阻塞，进入等待队列
- 涉及用户态到核心态的切换，开销较大

### 3.4 锁状态对比表

| 锁状态 | 优点 | 缺点 | 适用场景 |
|--------|------|------|----------|
| 偏向锁 | 加锁解锁无需额外操作，性能最优 | 如果存在竞争会带来额外开销 | 只有一个线程访问同步块 |
| 轻量级锁 | 竞争线程不阻塞，响应速度快 | 长时间自旋消耗 CPU | 线程交替执行同步块 |
| 重量级锁 | 线程竞争不消耗 CPU | 线程阻塞，响应时间长 | 多线程同时竞争 |

### 3.5 JVM 参数调优

```bash
# 关闭偏向锁
-XX:-UseBiasedLocking

# 设置偏向锁延迟时间（毫秒）
-XX:BiasedLockingStartupDelay=4000

# 批量重偏向阈值
-XX:BiasedLockingBulkRebiasThreshold=20

# 批量撤销阈值
-XX:BiasedLockingBulkRevokeThreshold=40
````

## 4. Synchronized 深入解析

### 4.1 使用方式

`synchronized` 关键字有三种使用方式：

```java
public class SynchronizedExample {
    private Object obj = new Object();

    // 1. 修饰实例方法 - 锁的是当前对象 (this)
    public synchronized void instanceMethod() {
        // 业务逻辑
    }

    // 2. 修饰静态方法 - 锁的是当前 Class 对象
    public static synchronized void staticMethod() {
        // 业务逻辑
    }

    // 3. 修饰代码块 - 锁的是指定对象
    public void blockMethod() {
        synchronized (obj) {
            // 业务逻辑
        }
    }
}
```

### 4.2 锁的粒度与作用域

#### 实例方法同步

```java
public class InstanceSync {
    public synchronized void methodA() { /* ... */ }
    public synchronized void methodB() { /* ... */ }
}

// 同一个对象的不同 synchronized 方法互斥
InstanceSync obj = new InstanceSync();
// 线程 A 执行 obj.methodA() 时，线程 B 无法执行 obj.methodB()
```

#### 静态方法同步

```java
public class StaticSync {
    public static synchronized void methodA() { /* ... */ }
    public static synchronized void methodB() { /* ... */ }
}

// 同一个类的不同静态 synchronized 方法互斥
// 线程 A 执行 StaticSync.methodA() 时，线程 B 无法执行 StaticSync.methodB()
```

### 4.3 底层实现原理

#### 监视器 (Monitor) 机制

**核心概念**：

-   每个 Java 对象都关联一个监视器 (Monitor)
-   `synchronized` 通过进入和退出监视器来实现同步
-   监视器具有排他性，同一时刻只能被一个线程持有

#### 字节码指令

**同步代码块**：

```java
synchronized (obj) {
    // 同步代码
}
```

对应字节码：

```
monitorenter  // 进入监视器
// 同步代码的字节码
monitorexit   // 正常退出监视器
monitorexit   // 异常退出监视器
```

**同步方法**：

-   方法标志位设置 `ACC_SYNCHRONIZED`
-   JVM 在方法调用和返回时自动处理监视器的进入和退出

#### Monitor 状态转换

```java
public class MonitorExample {
    private final Object lock = new Object();

    public void criticalSection() {
        synchronized (lock) {
            // 1. monitorenter：尝试获取 monitor
            //    - 成功：计数器 +1，成为持有者
            //    - 失败：阻塞等待

            doWork();

            // 2. monitorexit：释放 monitor
            //    - 计数器 -1
            //    - 计数器为 0 时，唤醒等待线程
        }
    }
}
```

### 4.4 Synchronized vs ReentrantLock

| 特性     | synchronized                          | ReentrantLock      |
| -------- | ------------------------------------- | ------------------ |
| 类型     | 关键字                                | 类                 |
| 自动释放 | 是                                    | 否（需要手动释放） |
| 中断响应 | 不支持                                | 支持               |
| 超时获取 | 不支持                                | 支持               |
| 公平性   | 非公平                                | 可选公平/非公平    |
| 条件队列 | 单一（wait/notify）                   | 多个（Condition）  |
| 性能     | JDK 1.6 后优化，与 ReentrantLock 相近 | 略高               |

### 4.5 使用建议

**选择 synchronized 的情况**：

-   简单的同步需求
-   代码量较少，不需要复杂功能
-   希望自动释放锁，减少出错概率

**选择 ReentrantLock 的情况**：

-   需要中断等待锁的线程
-   需要超时获取锁
-   需要公平锁
-   需要多个条件队列

**代码示例**：

````java
public class LockComparison {
    private final ReentrantLock lock = new ReentrantLock();

    // ReentrantLock 高级用法
    public void advancedLocking() {
        boolean acquired = false;
        try {
            // 尝试获取锁，最多等待 1 秒
            acquired = lock.tryLock(1, TimeUnit.SECONDS);
            if (acquired) {
                // 执行临界区代码
                doWork();
            } else {
                // 处理获取锁失败的情况
                handleLockFailure();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        } finally {
            if (acquired) {
                lock.unlock();
            }
        }
    }

    private void doWork() { /* 业务逻辑 */ }
    private void handleLockFailure() { /* 失败处理 */ }
}

## 5. 死锁问题分析与解决

### 5.1 死锁产生的必要条件

死锁必须同时满足以下四个条件：

1. **互斥条件**：资源同一时间只能被一个线程使用
2. **请求与保持条件**：线程持有资源的同时，又请求其他资源并被阻塞
3. **不可剥夺条件**：线程已获得的资源在使用完之前不能被强制剥夺
4. **循环等待条件**：多个线程形成头尾相接的循环等待资源关系

### 5.2 死锁预防策略

#### 5.2.1 破坏互斥条件
- **方法**：尽量使用共享资源而非独占资源
- **局限性**：很多资源本质上不可共享（如打印机、数据库连接等）

#### 5.2.2 破坏请求与保持条件

**静态分配策略**：
```java
public class StaticAllocation {
    private final Object lockA = new Object();
    private final Object lockB = new Object();

    public void method1() {
        // 一次性申请所有需要的资源
        synchronized (lockA) {
            synchronized (lockB) {
                // 业务逻辑
                doWork1();
            }
        }
    }

    public void method2() {
        // 保持相同的加锁顺序
        synchronized (lockA) {
            synchronized (lockB) {
                // 业务逻辑
                doWork2();
            }
        }
    }
}
````

**动态分配策略**：

```java
public class DynamicAllocation {
    private final ReentrantLock lockA = new ReentrantLock();
    private final ReentrantLock lockB = new ReentrantLock();

    public void method1() throws InterruptedException {
        boolean acquiredA = false, acquiredB = false;
        try {
            acquiredA = lockA.tryLock(1, TimeUnit.SECONDS);
            if (acquiredA) {
                acquiredB = lockB.tryLock(1, TimeUnit.SECONDS);
                if (acquiredB) {
                    // 获取到所有锁，执行业务逻辑
                    doWork1();
                } else {
                    // 无法获取全部锁，释放已获取的锁
                    // 避免保持部分资源
                }
            }
        } finally {
            if (acquiredB) lockB.unlock();
            if (acquiredA) lockA.unlock();
        }
    }
}
```

#### 5.2.3 破坏不可剥夺条件

```java
public class PreemptiveAllocation {
    private final ReentrantLock lock1 = new ReentrantLock();
    private final ReentrantLock lock2 = new ReentrantLock();

    public void interruptibleMethod() throws InterruptedException {
        boolean acquired = false;
        try {
            // 使用可中断的锁获取方式
            lock1.lockInterruptibly();
            acquired = true;

            // 尝试获取第二个锁，可被中断
            lock2.lockInterruptibly();

            // 执行业务逻辑
            doWork();

        } catch (InterruptedException e) {
            // 处理中断，释放已获取的资源
            Thread.currentThread().interrupt();
            throw e;
        } finally {
            if (lock2.isHeldByCurrentThread()) {
                lock2.unlock();
            }
            if (acquired) {
                lock1.unlock();
            }
        }
    }
}
```

#### 5.2.4 破坏循环等待条件

**资源有序分配**：

```java
public class OrderedAllocation {
    // 为锁分配全局唯一的编号
    private static final Object lock1 = new Object(); // ID: 1
    private static final Object lock2 = new Object(); // ID: 2
    private static final Object lock3 = new Object(); // ID: 3

    public void method1() {
        // 按照编号顺序获取锁：1 -> 2
        synchronized (lock1) {
            synchronized (lock2) {
                doWork1();
            }
        }
    }

    public void method2() {
        // 按照编号顺序获取锁：1 -> 3
        synchronized (lock1) {
            synchronized (lock3) {
                doWork2();
            }
        }
    }

    public void method3() {
        // 按照编号顺序获取锁：2 -> 3
        synchronized (lock2) {
            synchronized (lock3) {
                doWork3();
            }
        }
    }
}
```

### 5.3 死锁检测与恢复

#### 5.3.1 死锁检测工具

**JVM 工具**：

```bash
# 使用 jstack 检测死锁
jstack <pid>

# 使用 jconsole 可视化检测
jconsole

# 使用 VisualVM 检测
visualvm
```

**编程检测**：

```java
public class DeadlockDetector {
    private final ThreadMXBean threadBean =
        ManagementFactory.getThreadMXBean();

    public void detectDeadlock() {
        long[] deadlockedThreads = threadBean.findDeadlockedThreads();
        if (deadlockedThreads != null) {
            ThreadInfo[] threadInfos =
                threadBean.getThreadInfo(deadlockedThreads);

            System.out.println("发现死锁：");
            for (ThreadInfo threadInfo : threadInfos) {
                System.out.println("线程名称：" + threadInfo.getThreadName());
                System.out.println("锁名称：" + threadInfo.getLockName());
                System.out.println("锁持有者：" + threadInfo.getLockOwnerName());
            }
        }
    }
}
```

### 5.4 死锁避免最佳实践

1. **统一加锁顺序**：所有线程按相同顺序获取锁
2. **缩小锁的范围**：减少锁的持有时间
3. **使用超时机制**：避免无限期等待
4. **避免嵌套锁**：尽量使用单一锁
5. **使用无锁数据结构**：如 ConcurrentHashMap

### Java 当中有哪几种锁

自旋锁: 自旋锁在 JDK1.6 之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在 jdk6 之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定

偏向锁: 在 JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。

轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在 Java SE1.6 里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁

### 简述 Java 偏向锁

JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。

其申请流程为：

-   首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；
-   判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤 4；
-   判断是否需要重偏向。如果不用的话，直接获得偏向锁；
-   利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。

### 简述轻量级锁

轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。

其申请流程为：

-   如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。
-   虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针
-   如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。
-   如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧
-   如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行
-   如果不是则说明锁对象已经被其他线程抢占。
-   如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时 Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。

### 简述锁优化策略

即自适应自旋、锁消除、锁粗化、锁升级等策略偏。

### 简述 Java 的自旋锁

线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。

### 简述自适应自旋锁

自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。

### 简述锁粗化

锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。

### 简述锁消除

锁消除是一种更为彻底的优化，在编译时，Java 编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。

### 简述 Lock 与 ReentrantLock

Lock 接口是 Java 并发包的顶层接口。

可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。

## 6. Java 锁的分类详解

### 6.1 按照实现机制分类

#### 自旋锁 (Spin Lock)

**核心原理**：线程获取锁失败时不立即阻塞，而是在 CPU 上空转等待。

**优势**：

-   避免线程切换开销
-   适用于锁持有时间很短的场景

**劣势**：

-   消耗 CPU 资源
-   长时间自旋可能导致性能下降

#### 偏向锁 (Biased Lock)

**适用场景**：锁总是被同一线程获取，无多线程竞争。

**工作机制**：

1. 首次获取时在对象头记录线程 ID
2. 后续获取只需检查线程 ID
3. 其他线程竞争时撤销偏向锁

#### 轻量级锁 (Lightweight Lock)

**适用场景**：多线程交替获取锁，但没有同时竞争。

**实现流程**：

1. 线程在栈帧中创建 Lock Record
2. 使用 CAS 操作更新对象头
3. 成功获取锁或升级为重量级锁

### 6.2 按照锁的特性分类

#### 可重入锁 vs 不可重入锁

**可重入锁示例**：

```java
public class ReentrantExample {
    private final ReentrantLock lock = new ReentrantLock();

    public void methodA() {
        lock.lock();
        try {
            System.out.println("Method A");
            methodB(); // 可以重入
        } finally {
            lock.unlock();
        }
    }

    public void methodB() {
        lock.lock();
        try {
            System.out.println("Method B");
        } finally {
            lock.unlock();
        }
    }
}
```

#### 公平锁 vs 非公平锁

**公平锁特点**：

-   按照请求顺序获取锁（FIFO）
-   避免饥饿问题
-   性能相对较低

**非公平锁特点**：

-   新线程可能直接获取锁
-   吞吐量更高
-   可能导致饥饿问题

### 6.3 按照共享性分类

#### 独占锁 (Exclusive Lock)

同一时刻只能被一个线程持有，如 synchronized、ReentrantLock。

#### 共享锁 (Shared Lock)

可以被多个线程同时持有，如 ReadWriteLock 的读锁。

```java
public class ReadWriteLockExample {
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private final Lock readLock = rwLock.readLock();
    private final Lock writeLock = rwLock.writeLock();
    private String data = "";

    public String read() {
        readLock.lock();
        try {
            return data; // 多个线程可以同时读
        } finally {
            readLock.unlock();
        }
    }

    public void write(String newData) {
        writeLock.lock();
        try {
            data = newData; // 只有一个线程能写
        } finally {
            writeLock.unlock();
        }
    }
}
```

### 6.4 锁优化策略

#### 锁粗化 (Lock Coarsening)

将多个连续的加锁解锁操作合并为一个更大范围的锁操作。

#### 锁消除 (Lock Elimination)

编译器检测到不可能存在共享资源竞争的锁，自动消除。

#### 锁分离 (Lock Separation)

将一个锁分解为多个锁，减少竞争。

## 7. 内存模型与线程安全

### 7.1 as-if-serial 原则

**定义**：编译器会对原始程序进行指令重排序和优化，但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致。

**适用范围**：单线程程序

### 7.2 happens-before 规则

**定义**：用于描述两个操作之间的内存可见性关系。

**八大规则**：

1. **程序次序规则**：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
2. **锁定规则**：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作
3. **volatile 变量规则**：对一个变量的写操作先行发生于后面对这个变量的读操作
4. **传递规则**：如果操作 A 先行发生于操作 B，而操作 B 又先行发生于操作 C，则可以得出操作 A 先行发生于操作 C
5. **线程启动规则**：Thread 对象的 start() 方法先行发生于此线程的每个一个动作
6. **线程中断规则**：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生
7. **线程终结规则**：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行
8. **对象终结规则**：一个对象的初始化完成先行发生于他的 finalize() 方法的开始

### 7.3 并发编程三大特性

#### 7.3.1 原子性 (Atomicity)

**定义**：一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

**保证方式**：

-   synchronized 关键字
-   Lock 接口
-   原子类（AtomicInteger、AtomicLong 等）

#### 7.3.2 可见性 (Visibility)

**定义**：当一个线程修改了共享变量时，其他线程能够立即得知修改。

**保证方式**：

-   volatile 关键字
-   synchronized 关键字
-   final 关键字

#### 7.3.3 有序性 (Ordering)

**定义**：虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。

**保证方式**：

-   volatile 关键字（禁止指令重排）
-   synchronized 关键字

### 7.4 volatile 关键字深入

#### 7.4.1 作用机制

1. **保证可见性**：修改后的值对其他线程立即可见
2. **禁止指令重排**：通过内存屏障实现

#### 7.4.2 使用场景

```java
public class VolatileExample {
    private volatile boolean flag = false;
    private int count = 0;

    public void writer() {
        count = 42;  // 1
        flag = true; // 2 - volatile 写
    }

    public void reader() {
        if (flag) {  // 3 - volatile 读
            // 此时一定能看到 count = 42
            System.out.println(count); // 4
        }
    }
}
```

#### 7.4.3 内存屏障

| 屏障类型   | 指令示例                   | 说明                                        |
| ---------- | -------------------------- | ------------------------------------------- |
| LoadLoad   | Load1; LoadLoad; Load2     | 确保 Load1 数据的装载先于 Load2             |
| StoreStore | Store1; StoreStore; Store2 | 确保 Store1 数据对其他处理器可见先于 Store2 |
| LoadStore  | Load1; LoadStore; Store2   | 确保 Load1 数据装载先于 Store2              |
| StoreLoad  | Store1; StoreLoad; Load2   | 确保 Store1 数据对其他处理器可见先于 Load2  |

### 7.5 变量的线程安全分析

#### 7.5.1 成员变量和静态变量

**线程安全情况**：

-   没有共享：线程安全
-   被共享且只读：线程安全
-   被共享且有写操作：需要考虑线程安全

#### 7.5.2 局部变量

**基本原则**：

-   局部变量本身是线程安全的（存储在栈中）
-   局部变量引用的对象不一定线程安全

**示例分析**：

```java
public class LocalVariableExample {
    // 线程安全：局部基本类型变量
    public static void safeMethod() {
        int i = 10;
        i++;
    }

    // 线程安全：对象仅在方法内使用
    public static String safeMethod2() {
        StringBuilder sb = new StringBuilder();
        sb.append("Hello");
        return sb.toString();
    }

    // 不安全：返回可变对象引用
    public static StringBuilder unsafeMethod() {
        StringBuilder sb = new StringBuilder();
        sb.append("Hello");
        return sb; // 其他线程可能修改返回的对象
    }
}
```

## 8. 并发工具类详解

### 8.1 CountDownLatch

**功能描述**：使一个线程等待其他线程各自执行完毕后再执行。

**实现原理**：通过一个计数器实现，计数器初始值为线程数量，每当一个线程执行完毕后调用 `countDown()` 方法，计数器值减 1，当计数器值为 0 时，所有等待的线程被唤醒。

**使用场景**：

1. 主线程等待多个工作线程完成
2. 多个线程等待某个初始化完成

**代码示例**：

```java
public class CountDownLatchExample {
    private static final int THREAD_COUNT = 3;
    private static final CountDownLatch latch = new CountDownLatch(THREAD_COUNT);

    public static void main(String[] args) throws InterruptedException {
        // 启动工作线程
        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(new Worker(i)).start();
        }

        // 主线程等待所有工作线程完成
        latch.await();
        System.out.println("所有工作线程已完成");
    }

    static class Worker implements Runnable {
        private final int id;

        Worker(int id) {
            this.id = id;
        }

        @Override
        public void run() {
            try {
                Thread.sleep(1000); // 模拟工作
                System.out.println("线程 " + id + " 完成工作");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                latch.countDown(); // 计数器减 1
            }
        }
    }
}
```

### 8.2 CyclicBarrier

**功能描述**：让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。

**与 CountDownLatch 的区别**：

-   CyclicBarrier 可以重复使用（reset）
-   CountDownLatch 只能使用一次
-   CyclicBarrier 强调的是多个线程互相等待

**代码示例**：

```java
public class CyclicBarrierExample {
    private static final int THREAD_COUNT = 3;
    private static final CyclicBarrier barrier = new CyclicBarrier(THREAD_COUNT, () -> {
        System.out.println("所有线程已到达屏障，开始下一阶段");
    });

    public static void main(String[] args) {
        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(new Worker(i)).start();
        }
    }

    static class Worker implements Runnable {
        private final int id;

        Worker(int id) {
            this.id = id;
        }

        @Override
        public void run() {
            try {
                System.out.println("线程 " + id + " 正在工作");
                Thread.sleep(1000); // 模拟工作
                System.out.println("线程 " + id + " 到达屏障");

                barrier.await(); // 等待其他线程

                System.out.println("线程 " + id + " 继续执行");
            } catch (InterruptedException | BrokenBarrierException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

### 8.3 Semaphore

**功能描述**：控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用公共资源。

**应用场景**：

-   数据库连接池
-   限流器
-   资源池管理

**代码示例**：

```java
public class SemaphoreExample {
    private static final int MAX_AVAILABLE = 2; // 最大可用资源数
    private static final Semaphore semaphore = new Semaphore(MAX_AVAILABLE);

    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            new Thread(new Worker(i)).start();
        }
    }

    static class Worker implements Runnable {
        private final int id;

        Worker(int id) {
            this.id = id;
        }

        @Override
        public void run() {
            try {
                semaphore.acquire(); // 获取许可
                System.out.println("线程 " + id + " 获得资源");
                Thread.sleep(2000); // 使用资源
                System.out.println("线程 " + id + " 释放资源");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            } finally {
                semaphore.release(); // 释放许可
            }
        }
    }
}
```

### 8.4 Exchanger

**功能描述**：用于两个线程之间交换数据的同步点。

**使用场景**：

-   数据校对
-   线程间数据交换

**代码示例**：

```java
public class ExchangerExample {
    private static final Exchanger<String> exchanger = new Exchanger<>();

    public static void main(String[] args) {
        new Thread(() -> {
            try {
                String data = "线程A的数据";
                System.out.println("线程A准备交换：" + data);
                String result = exchanger.exchange(data);
                System.out.println("线程A收到：" + result);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        new Thread(() -> {
            try {
                String data = "线程B的数据";
                System.out.println("线程B准备交换：" + data);
                String result = exchanger.exchange(data);
                System.out.println("线程B收到：" + result);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

## 9. CAS 与原子操作

### 9.1 CAS 基本概念

**CAS (Compare And Swap)**：比较并交换，是实现乐观锁的核心算法。

**工作原理**：

1. 包含三个参数：内存地址 V、预期原值 A、新值 B
2. 当且仅当内存地址 V 的值等于预期原值 A 时，将内存地址 V 的值修改为新值 B
3. 否则不执行任何操作

**特点**：

-   原子性操作，由硬件保证
-   无锁算法，避免线程阻塞
-   ABA 问题需要特殊处理

### 9.2 CAS 实现原理

```java
public class CASExample {
    private volatile int value = 0;

    // 模拟 CAS 操作
    public final boolean compareAndSet(int expect, int update) {
        // 原子操作：比较并交换
        // 实际由硬件指令实现，这里只是伪代码
        if (value == expect) {
            value = update;
            return true;
        }
        return false;
    }

    // 基于 CAS 的递增操作
    public final int incrementAndGet() {
        for (;;) {
            int current = value;
            int next = current + 1;
            if (compareAndSet(current, next)) {
                return next;
            }
            // CAS 失败，重试
        }
    }
}
```

### 9.3 CAS 的优缺点

**优点**：

-   避免线程阻塞，提高并发性能
-   无死锁风险
-   硬件级别支持，性能较高

**缺点**：

-   **CPU 开销大**：高并发下可能导致大量自旋
-   **ABA 问题**：值从 A 变为 B 再变回 A，CAS 无法检测
-   **只能保证一个共享变量的原子性**

### 9.4 ABA 问题与解决方案

#### 9.4.1 ABA 问题描述

```java
// 线程1执行过程中，线程2可能进行了 A -> B -> A 的修改
// 线程1无法感知到这种变化
public class ABAExample {
    private AtomicInteger atomicInt = new AtomicInteger(100);

    // 线程1：期望将100改为101
    public void thread1() {
        int value = atomicInt.get(); // 读取到100
        // ... 执行其他操作
        atomicInt.compareAndSet(value, 101); // 可能成功，但数据已被修改过
    }

    // 线程2：100 -> 200 -> 100
    public void thread2() {
        atomicInt.compareAndSet(100, 200);
        atomicInt.compareAndSet(200, 100);
    }
}
```

#### 9.4.2 解决方案：版本号机制

```java
public class AtomicStampedReferenceExample {
    private static AtomicStampedReference<Integer> atomicStampedRef =
        new AtomicStampedReference<>(100, 0);

    public static void main(String[] args) throws InterruptedException {
        Thread refT1 = new Thread(() -> {
            try {
                Thread.sleep(1000);
                // 获取当前版本号
                int stamp = atomicStampedRef.getStamp();
                System.out.println("线程1读取版本号：" + stamp);

                // 尝试修改，版本号必须匹配
                boolean success = atomicStampedRef.compareAndSet(100, 101, stamp, stamp + 1);
                System.out.println("线程1修改" + (success ? "成功" : "失败"));
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });

        Thread refT2 = new Thread(() -> {
            int stamp = atomicStampedRef.getStamp();
            System.out.println("线程2读取版本号：" + stamp);

            // 执行 ABA 操作
            atomicStampedRef.compareAndSet(100, 200, stamp, stamp + 1);
            stamp = atomicStampedRef.getStamp();
            atomicStampedRef.compareAndSet(200, 100, stamp, stamp + 1);

            System.out.println("线程2执行ABA操作完成");
        });

        refT1.start();
        refT2.start();

        refT1.join();
        refT2.join();
    }
}
```

### 9.5 原子类详解

#### 9.5.1 基本数据类型原子类

```java
public class AtomicTypesExample {
    private AtomicInteger atomicInt = new AtomicInteger(0);
    private AtomicLong atomicLong = new AtomicLong(0);
    private AtomicBoolean atomicBoolean = new AtomicBoolean(false);

    public void basicOperations() {
        // 原子递增
        int newValue = atomicInt.incrementAndGet();

        // 原子加法
        int result = atomicInt.addAndGet(5);

        // CAS 操作
        boolean success = atomicInt.compareAndSet(5, 10);

        // 获取并设置新值
        int oldValue = atomicInt.getAndSet(20);
    }
}
```

#### 9.5.2 数组类型原子类

```java
public class AtomicArrayExample {
    private AtomicIntegerArray atomicIntArray = new AtomicIntegerArray(10);

    public void arrayOperations() {
        // 原子更新数组索引2的值
        atomicIntArray.incrementAndGet(2);

        // CAS 更新
        atomicIntArray.compareAndSet(1, 0, 100);

        // 获取并增加
        int oldValue = atomicIntArray.getAndAdd(3, 50);
    }
}
```

#### 9.5.3 引用类型原子类

```java
public class AtomicReferenceExample {
    static class User {
        private String name;
        private int age;

        public User(String name, int age) {
            this.name = name;
            this.age = age;
        }

        // getters and setters
    }

    private AtomicReference<User> atomicUserRef = new AtomicReference<>();

    public void referenceOperations() {
        User user1 = new User("Alice", 20);
        User user2 = new User("Bob", 25);

        atomicUserRef.set(user1);

        // 原子性地更新引用
        boolean success = atomicUserRef.compareAndSet(user1, user2);
    }
}
```

### 9.6 乐观锁的实际应用

#### 9.6.1 无锁数据结构：无锁栈

```java
public class LockFreeStack<E> {
    private volatile Node<E> top;

    private static class Node<E> {
        final E data;
        volatile Node<E> next;

        Node(E data) {
            this.data = data;
        }
    }

    public void push(E item) {
        Node<E> newNode = new Node<>(item);
        Node<E> currentTop;

        do {
            currentTop = top;
            newNode.next = currentTop;
        } while (!compareAndSetTop(currentTop, newNode));
    }

    public E pop() {
        Node<E> currentTop;
        Node<E> newTop;

        do {
            currentTop = top;
            if (currentTop == null) {
                return null;
            }
            newTop = currentTop.next;
        } while (!compareAndSetTop(currentTop, newTop));

        return currentTop.data;
    }

    private boolean compareAndSetTop(Node<E> expect, Node<E> update) {
        // 使用 Unsafe 或 AtomicReference 实现
        // 这里简化为伪代码
        return true; // 实际需要原子CAS操作
    }
}
```

#### 9.6.2 高性能计数器

```java
public class HighPerformanceCounter {
    private final AtomicLong counter = new AtomicLong(0);

    public long increment() {
        return counter.incrementAndGet();
    }

    public long get() {
        return counter.get();
    }

    // 批量操作，减少CAS竞争
    public long addBatch(long delta) {
        return counter.addAndGet(delta);
    }
}

## 10. 高级并发组件

### 10.1 ConcurrentHashMap

#### 10.1.1 JDK 7 实现（分段锁）

**核心思想**：将数据分成多个 Segment，每个 Segment 相当于一个小的 HashTable，拥有自己的锁。

**优势**：
- 多个线程可以同时访问不同 Segment
- 大大提高了并发访问效率

**结构图**：
```

ConcurrentHashMap
├── Segment[0] (ReentrantLock)
│ ├── HashEntry[]
├── Segment[1] (ReentrantLock)
│ ├── HashEntry[]
└── ...

````

**操作过程**：
```java
// put 操作流程
public V put(K key, V value) {
    Segment<K,V> s;
    // 1. 计算 hash 值
    int hash = hash(key);
    // 2. 定位到具体的 Segment
    int j = (hash >>> segmentShift) & segmentMask;
    // 3. 在对应的 Segment 中进行操作（需要加锁）
    return segmentAt(segments, j).put(key, hash, value, false);
}

// get 操作流程
public V get(Object key) {
    Segment<K,V> s;
    // get 操作大部分情况下不需要加锁
    int h = hash(key);
    long u = (((h >>> segmentShift) & segmentMask) << SSHIFT) + SBASE;
    if ((s = (Segment<K,V>)UNSAFE.getObjectVolatile(segments, u)) != null &&
        (tab = s.table) != null) {
        // 在 Segment 内部查找
        // 利用 volatile 语义保证可见性
    }
    return null;
}
````

#### 10.1.2 JDK 8 实现（CAS + synchronized）

**重大改进**：

1. **取消分段锁**：直接对 Node 数组的元素进行同步
2. **引入红黑树**：链表长度超过 8 且数组长度大于 64 时转换为红黑树
3. **CAS + synchronized**：结合 CAS 和局部同步提高性能

**核心数据结构**：

```java
// Node 节点
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;           // volatile 保证可见性
    volatile Node<K,V> next;  // volatile 保证可见性
}

// 树节点
static final class TreeNode<K,V> extends Node<K,V> {
    TreeNode<K,V> parent;
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;
    boolean red;
}
```

**put 操作流程**：

```java
final V putVal(K key, V value, boolean onlyIfAbsent) {
    if (key == null || value == null) throw new NullPointerException();
    int hash = spread(key.hashCode());
    int binCount = 0;

    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f; int n, i, fh;

        // 1. 表为空，进行初始化
        if (tab == null || (n = tab.length) == 0)
            tab = initTable();
        // 2. 槽位为空，CAS 插入
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break;  // 成功插入，退出循环
        }
        // 3. 槽位正在扩容
        else if ((fh = f.hash) == MOVED)
            tab = helpTransfer(tab, f);
        // 4. 槽位有元素，需要同步
        else {
            V oldVal = null;
            synchronized (f) {  // 锁定槽位头节点
                if (tabAt(tab, i) == f) {
                    // 链表操作
                    if (fh >= 0) {
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                if (!onlyIfAbsent)
                                    e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                pred.next = new Node<K,V>(hash, key, value, null);
                                break;
                            }
                        }
                    }
                    // 红黑树操作
                    else if (f instanceof TreeBin) {
                        Node<K,V> p;
                        binCount = 2;
                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {
                            oldVal = p.val;
                            if (!onlyIfAbsent)
                                p.val = value;
                        }
                    }
                }
            }

            // 检查是否需要转换为红黑树
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i);
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
```

#### 10.1.3 性能对比

| 特性     | JDK 7               | JDK 8                |
| -------- | ------------------- | -------------------- |
| 锁粒度   | Segment 级别        | Node 级别            |
| 数据结构 | Segment + HashEntry | Node + TreeNode      |
| 并发度   | 固定（默认 16）     | 动态（基于数组大小） |
| 查询性能 | O(n)                | O(log n) 最坏情况    |
| 内存占用 | 较高                | 较低                 |

### 10.2 ThreadLocal

#### 10.2.1 基本原理

**核心思想**：为每个线程提供独立的变量副本，避免线程间的数据干扰。

**实现机制**：

```java
public class Thread {
    // 每个线程都有自己的 ThreadLocalMap
    ThreadLocal.ThreadLocalMap threadLocals = null;
}

public class ThreadLocal<T> {
    static class ThreadLocalMap {
        static class Entry extends WeakReference<ThreadLocal<?>> {
            Object value;
            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }
        private Entry[] table;
    }
}
```

#### 10.2.2 核心方法实现

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}
```

#### 10.2.3 内存泄漏问题与解决

**问题原因**：

-   ThreadLocal 作为 key 使用弱引用
-   value 使用强引用
-   当 ThreadLocal 被回收后，value 无法被回收

**解决方案**：

```java
public class ThreadLocalExample {
    private static final ThreadLocal<String> threadLocal = new ThreadLocal<>();

    public void useThreadLocal() {
        try {
            threadLocal.set("thread-specific-value");
            // 业务逻辑
            doSomething();
        } finally {
            // 必须手动清理，防止内存泄漏
            threadLocal.remove();
        }
    }

    // 使用 try-with-resources 模式
    public void safeUseThreadLocal() {
        try (ThreadLocalCleaner cleaner = new ThreadLocalCleaner(threadLocal)) {
            threadLocal.set("safe-value");
            doSomething();
        } // 自动清理
    }
}

class ThreadLocalCleaner implements AutoCloseable {
    private final ThreadLocal<?> threadLocal;

    public ThreadLocalCleaner(ThreadLocal<?> threadLocal) {
        this.threadLocal = threadLocal;
    }

    @Override
    public void close() {
        threadLocal.remove();
    }
}
```

### 10.3 AQS (AbstractQueuedSynchronizer)

#### 10.3.1 核心原理

**AQS** 是 Java 并发包的基础框架，用于构建锁和其他同步组件。

**核心思想**：

-   使用一个 volatile int state 表示同步状态
-   通过 FIFO 队列管理等待线程
-   提供模板方法，子类实现具体的获取/释放逻辑

#### 10.3.2 关键数据结构

```java
public abstract class AbstractQueuedSynchronizer {
    // 同步状态
    private volatile int state;

    // 等待队列的头节点
    private transient volatile Node head;

    // 等待队列的尾节点
    private transient volatile Node tail;

    // 队列节点
    static final class Node {
        static final Node SHARED = new Node();
        static final Node EXCLUSIVE = null;

        // 等待状态
        static final int CANCELLED =  1;
        static final int SIGNAL    = -1;
        static final int CONDITION = -2;
        static final int PROPAGATE = -3;

        volatile int waitStatus;
        volatile Node prev;
        volatile Node next;
        volatile Thread thread;
        Node nextWaiter;
    }
}
```

#### 10.3.3 独占锁实现

```java
// 获取独占锁
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&                    // 尝试获取锁
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  // 失败则入队等待
        selfInterrupt();
}

// 释放独占锁
public final boolean release(int arg) {
    if (tryRelease(arg)) {                     // 尝试释放锁
        Node h = head;
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);                // 唤醒后继节点
        return true;
    }
    return false;
}

// 自定义同步器示例
class Mutex implements Lock {
    private final Sync sync = new Sync();

    private static class Sync extends AbstractQueuedSynchronizer {
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        public boolean tryAcquire(int acquires) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        protected boolean tryRelease(int releases) {
            if (getState() == 0) throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
    }

    public void lock() { sync.acquire(1); }
    public void unlock() { sync.release(1); }
    // 其他方法实现...
}
```

## 11. 实际应用场景分析

### 11.1 线程池问题诊断

#### 11.1.1 线程池被瞬间占满的原因

**常见原因分析**：

1. **任务队列满载**

```java
// 问题代码：无界队列 + 长时间任务
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    2, 4, 60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(), // 无界队列
    new ThreadPoolExecutor.AbortPolicy()
);

// 大量长时间任务提交
for (int i = 0; i < 1000; i++) {
    executor.submit(() -> {
        try {
            Thread.sleep(10000); // 长时间任务
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    });
}
```

2. **线程池配置不当**

```java
// 解决方案：合理配置线程池参数
public class ThreadPoolConfig {
    public static ThreadPoolExecutor createOptimizedPool() {
        int corePoolSize = Runtime.getRuntime().availableProcessors();
        int maximumPoolSize = corePoolSize * 2;
        long keepAliveTime = 60L;
        TimeUnit unit = TimeUnit.SECONDS;

        // 有界队列，防止内存溢出
        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(100);

        // 自定义拒绝策略
        RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();

        return new ThreadPoolExecutor(
            corePoolSize, maximumPoolSize, keepAliveTime, unit,
            workQueue, handler
        );
    }
}
```

3. **资源竞争与阻塞**

```java
public class DeadlockDetectionExample {
    private static final Object lock1 = new Object();
    private static final Object lock2 = new Object();

    public static void detectDeadlock() {
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();

        // 定期检测死锁
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(() -> {
            long[] deadlockedThreads = threadMXBean.findDeadlockedThreads();
            if (deadlockedThreads != null) {
                ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(deadlockedThreads);
                System.err.println("检测到死锁：");
                for (ThreadInfo info : threadInfos) {
                    System.err.println("线程: " + info.getThreadName() +
                                     " 状态: " + info.getThreadState());
                }
            }
        }, 0, 5, TimeUnit.SECONDS);
    }
}
```

#### 11.1.2 监控与调优

```java
public class ThreadPoolMonitor {
    private final ThreadPoolExecutor executor;
    private final ScheduledExecutorService monitor;

    public ThreadPoolMonitor(ThreadPoolExecutor executor) {
        this.executor = executor;
        this.monitor = Executors.newScheduledThreadPool(1);
        startMonitoring();
    }

    private void startMonitoring() {
        monitor.scheduleAtFixedRate(() -> {
            System.out.println("=== 线程池状态 ===");
            System.out.println("核心线程数: " + executor.getCorePoolSize());
            System.out.println("活跃线程数: " + executor.getActiveCount());
            System.out.println("最大线程数: " + executor.getMaximumPoolSize());
            System.out.println("当前线程数: " + executor.getPoolSize());
            System.out.println("队列大小: " + executor.getQueue().size());
            System.out.println("已完成任务数: " + executor.getCompletedTaskCount());
            System.out.println("总任务数: " + executor.getTaskCount());

            // 告警逻辑
            if (executor.getActiveCount() == executor.getMaximumPoolSize()) {
                System.err.println("警告：线程池已满！");
            }

            if (executor.getQueue().size() > executor.getQueue().remainingCapacity() * 0.8) {
                System.err.println("警告：队列使用率过高！");
            }
        }, 0, 10, TimeUnit.SECONDS);
    }
}
```

### 11.2 Spring Boot Web 项目中的多线程问题

#### 11.2.1 Spring MVC 的线程安全性

**基本原则**：

-   Spring 容器中的 Bean 默认是单例的
-   Controller、Service、Repository 都是线程安全的（无状态）
-   需要避免在 Bean 中使用实例变量存储状态

```java
@RestController
public class ThreadSafeController {
    @Autowired
    private UserService userService; // 线程安全：无状态服务

    // 线程不安全：实例变量
    private int counter = 0;

    @GetMapping("/unsafe")
    public String unsafeMethod() {
        counter++; // 多线程下会有问题
        return "Counter: " + counter;
    }

    @GetMapping("/safe")
    public String safeMethod() {
        int localCounter = 0; // 线程安全：局部变量
        localCounter++;
        return "Counter: " + localCounter;
    }
}
```

#### 11.2.2 数据库连接与事务管理

```java
@Service
@Transactional
public class UserService {
    @Autowired
    private UserRepository userRepository;

    // Spring 事务管理是线程安全的
    public void transferMoney(Long fromId, Long toId, BigDecimal amount) {
        User fromUser = userRepository.findById(fromId).orElseThrow();
        User toUser = userRepository.findById(toId).orElseThrow();

        fromUser.setBalance(fromUser.getBalance().subtract(amount));
        toUser.setBalance(toUser.getBalance().add(amount));

        userRepository.save(fromUser);
        userRepository.save(toUser);
        // 事务会自动提交或回滚
    }

    // 异步处理需要特别注意
    @Async
    public CompletableFuture<Void> asyncProcess(Long userId) {
        // 异步方法中的事务是独立的
        processUser(userId);
        return CompletableFuture.completedFuture(null);
    }
}
```

#### 11.2.3 缓存并发控制

```java
@Service
public class CacheService {
    private final ConcurrentHashMap<String, Object> cache = new ConcurrentHashMap<>();
    private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();

    // 线程安全的缓存操作
    public Object get(String key) {
        return cache.get(key);
    }

    public void put(String key, Object value) {
        cache.put(key, value);
    }

    // 复杂缓存操作需要额外同步
    public Object getOrCompute(String key, Supplier<Object> supplier) {
        Object value = cache.get(key);
        if (value == null) {
            rwLock.writeLock().lock();
            try {
                // 双重检查锁定
                value = cache.get(key);
                if (value == null) {
                    value = supplier.get();
                    cache.put(key, value);
                }
            } finally {
                rwLock.writeLock().unlock();
            }
        }
        return value;
    }
}
```

### 11.3 高并发场景下的锁选择策略

#### 11.3.1 锁选择决策树

```
高并发场景锁选择
├── 读多写少
│   ├── ReadWriteLock
│   └── StampedLock (JDK 8+)
├── 写多读少
│   ├── 轻量级操作 → 自旋锁/CAS
│   └── 重量级操作 → ReentrantLock
├── 读写平衡
│   ├── 数据结构 → ConcurrentHashMap
│   └── 业务逻辑 → synchronized/ReentrantLock
└── 特殊需求
    ├── 可中断 → ReentrantLock
    ├── 超时获取 → ReentrantLock
    └── 公平性 → ReentrantLock(fair=true)
```

#### 11.3.2 性能测试对比

```java
public class LockPerformanceTest {
    private static final int THREAD_COUNT = 10;
    private static final int ITERATIONS = 100_000;

    private volatile int counter = 0;
    private final Object syncLock = new Object();
    private final ReentrantLock reentrantLock = new ReentrantLock();
    private final AtomicInteger atomicCounter = new AtomicInteger(0);

    public void testSynchronized() throws InterruptedException {
        long start = System.currentTimeMillis();
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);

        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(() -> {
                for (int j = 0; j < ITERATIONS; j++) {
                    synchronized (syncLock) {
                        counter++;
                    }
                }
                latch.countDown();
            }).start();
        }

        latch.await();
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("Synchronized: " + elapsed + "ms, result: " + counter);
    }

    public void testReentrantLock() throws InterruptedException {
        counter = 0;
        long start = System.currentTimeMillis();
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);

        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(() -> {
                for (int j = 0; j < ITERATIONS; j++) {
                    reentrantLock.lock();
                    try {
                        counter++;
                    } finally {
                        reentrantLock.unlock();
                    }
                }
                latch.countDown();
            }).start();
        }

        latch.await();
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("ReentrantLock: " + elapsed + "ms, result: " + counter);
    }

    public void testAtomic() throws InterruptedException {
        atomicCounter.set(0);
        long start = System.currentTimeMillis();
        CountDownLatch latch = new CountDownLatch(THREAD_COUNT);

        for (int i = 0; i < THREAD_COUNT; i++) {
            new Thread(() -> {
                for (int j = 0; j < ITERATIONS; j++) {
                    atomicCounter.incrementAndGet();
                }
                latch.countDown();
            }).start();
        }

        latch.await();
        long elapsed = System.currentTimeMillis() - start;
        System.out.println("AtomicInteger: " + elapsed + "ms, result: " + atomicCounter.get());
    }
}
```

## 12. 最佳实践与总结

### 12.1 锁使用的最佳实践

#### 12.1.1 基本原则

1. **最小化锁的范围**

```java
// 不好的做法
public synchronized void badMethod() {
    heavyComputation(); // 不需要同步的操作
    updateSharedResource(); // 需要同步的操作
    anotherHeavyComputation(); // 不需要同步的操作
}

// 好的做法
public void goodMethod() {
    heavyComputation();

    synchronized (this) {
        updateSharedResource(); // 只同步必要的部分
    }

    anotherHeavyComputation();
}
```

2. **避免嵌套锁**

```java
// 避免这样的代码
public void dangerousMethod() {
    synchronized (lock1) {
        synchronized (lock2) {
            // 可能导致死锁
        }
    }
}

// 推荐做法
public void saferMethod() {
    // 使用统一的锁顺序
    Object firstLock = System.identityHashCode(lock1) < System.identityHashCode(lock2) ? lock1 : lock2;
    Object secondLock = firstLock == lock1 ? lock2 : lock1;

    synchronized (firstLock) {
        synchronized (secondLock) {
            // 安全的操作
        }
    }
}
```

3. **正确释放资源**

```java
public void properResourceManagement() {
    Lock lock = new ReentrantLock();
    lock.lock();
    try {
        // 执行需要同步的操作
        doSomething();
    } finally {
        lock.unlock(); // 确保锁被释放
    }
}
```

### 12.2 性能优化建议

#### 12.2.1 锁优化策略

| 策略     | 适用场景             | 实现方式          |
| -------- | -------------------- | ----------------- |
| 锁消除   | 不存在竞争的同步代码 | JVM 自动优化      |
| 锁粗化   | 频繁的加锁解锁操作   | 合并同步块        |
| 读写分离 | 读多写少场景         | ReadWriteLock     |
| 分段锁   | 大数据结构           | ConcurrentHashMap |
| 无锁编程 | 简单操作             | CAS、原子类       |

#### 12.2.2 监控与诊断

```java
public class LockMonitoring {
    // 使用 JMX 监控锁状态
    public void monitorLocks() {
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();

        if (threadMXBean.isThreadContentionMonitoringEnabled()) {
            ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(true, true);

            for (ThreadInfo info : threadInfos) {
                if (info.getBlockedTime() > 1000) { // 阻塞超过1秒
                    System.out.println("长时间阻塞的线程: " + info.getThreadName());
                    System.out.println("阻塞时间: " + info.getBlockedTime() + "ms");
                    System.out.println("锁信息: " + info.getLockInfo());
                }
            }
        }
    }
}
```

### 12.3 总结

Java 锁机制是并发编程的核心，正确理解和使用锁对于编写高性能、线程安全的程序至关重要。本文从基础概念到高级应用，系统性地介绍了：

1. **锁的分类与特性**：乐观锁与悲观锁、公平锁与非公平锁等
2. **核心实现机制**：synchronized 锁升级、ReentrantLock 原理、AQS 框架
3. **并发工具类**：CountDownLatch、CyclicBarrier、Semaphore 等
4. **高级主题**：CAS 算法、内存模型、ThreadLocal 等
5. **实际应用**：死锁预防、性能优化、Spring 环境下的线程安全等

**关键要点回顾**：

-   选择合适的锁类型：根据业务场景选择 synchronized、ReentrantLock 或无锁方案
-   注意锁的粒度：最小化锁的持有时间和范围
-   防止死锁：统一加锁顺序、使用超时机制、避免嵌套锁
-   性能考虑：读写分离、分段锁、CAS 优化等
-   监控诊断：使用 JVM 工具检测锁竞争和死锁问题

掌握这些知识点，能够帮助开发者在实际项目中设计出更加健壮和高效的并发程序。
