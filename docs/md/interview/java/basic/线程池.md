1. ## 基础

    ### 什么是线程池

    在面向对象编程中，创建和销毁对象是很费时间的，创建一个对象要获取内存资源或者其它更多资源。Java 虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是“池化资源”技术产生的原因
    线程池，就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销
    Java 5+ 中的 Executor 接口定义一个执行线程的工具，它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池：

    - newSingleThreadExecutor
      创建一个单线程的线程池，这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行
    - newFixedThreadPool
      创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
    - newCachedThreadPool
      创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小
    - newScheduledThreadPool
      创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求

    ### 为什么要使用线程池

    避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。

    ### 线程池队列已满会发生什么

    - 使用的 LinkedBlockingQueue，也就是无界队列的话，继续添加任务到阻塞队列中等待执行，因为 LinkedBlockingQueue 可以近乎认为是一个无穷大的队列，可以无限存放任务
    - 使用的是有界队列，如 ArrayBlockingQueue，任务首先会被添加到 ArrayBlockingQueue 中，ArrayBlockingQueue 满了，则会使用拒绝策略 RejectedExecutionHandler 处理满了的任务，默认是 AbortPolicy

    ### 线程池有哪些参数？

    - corePoolSize：核心线程数，线程池中始终存活的线程数
    - maximumPoolSize：最大线程数，线程池中允许的最大线程数
    - keepAliveTime：存活时间，线程没有任务执行时最多保持多久时间会终止
    - unit：单位，参数 keepAliveTime 的时间单位，7 种可选
    - workQueue：一个阻塞队列，用来存储等待执行的任务，均为线程安全，7 种可选
    - threadFactory：线程工厂，主要用来创建线程，默及正常优先级、非守护线程
    - handler：拒绝策略，拒绝处理任务时的策略，4 种可选，默认为 AbortPolicy
        - AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
        - CallerRunsPolicy：只用调用者所在的线程来处理任务
        - DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
        - DiscardPolicy：直接丢弃任务，也不抛出异常

    ### 线程池的执行流程

    ![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687053962-02fe8165-06c9-41c1-8d4b-63f03628fa58.png#averageHue=%23faf8f6&clientId=u00400ee8-e274-4&from=paste&id=uf6eb3d33&name=image.png&originHeight=1054&originWidth=1154&originalType=url&ratio=1&rotation=0&showTitle=false&size=209121&status=done&style=none&taskId=u30ef56a3-c059-4c9f-9167-6432e1b4614&title=)

    - 判断线程池中的线程数是否大于设置的核心线程数
        - 如果小于，就创建一个核心线程来执行任务
        - 如果大于，就会判断缓冲队列是否满了
            - 如果没有满，则放入队列，等待线程空闲时执行任务
            - 如果队列已经满了，则判断是否达到了线程池设置的最大线程数
                - 如果没有达到，就创建新线程来执行任务
                - 如果已经达到了最大线程数，则执行指定的拒绝策略

    ### 线程池的拒绝策略有哪些

    - AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
    - CallerRunsPolicy：只用调用者所在的线程来处理任务
    - DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
    - DiscardPolicy：直接丢弃任务，也不抛出异常

    ### 讲讲线程池的实现原理

    使用线程池的好处

    - 线程是稀缺资源，不能频繁的创建。
    - 应当将其放入一个池子中，可以给其他任务进行复用。
    - 解耦作用，线程的创建于执行完全分开，方便维护。

    创建一个线程池

    ```java
    ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, RejectedExecutionHandler handler);
    ```

    为例：

    - corePoolSize 为线程池的基本大小。
    - maximumPoolSize 为线程池最大线程大小。
    - keepAliveTime 和 unit 则是线程空闲后的存活时间。
    - workQueue 用于存放任务的阻塞队列。
    - handler 当队列和最大线程池都满了之后的饱和策略。

    处理流程
    当提交一个任务到线程池时它的执行流程是怎样的呢？
    ![image.png](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687053872-c8d4bbec-3a1b-41bb-a7dc-96fabc906a8a.png#averageHue=%23fbfdfa&clientId=u00400ee8-e274-4&from=paste&id=u47de066c&name=image.png&originHeight=293&originWidth=500&originalType=url&ratio=1&rotation=0&showTitle=false&size=84049&status=done&style=none&taskId=ubd82d4b7-1812-4389-83c8-651f4b36fa8&title=)
    首先第一步会判断核心线程数有没有达到上限，如果没有则创建线程(会获取全局锁)，满了则会将任务丢进阻塞队列。
    如果队列也满了则需要判断最大线程数是否达到上限，如果没有则创建线程(获取全局锁)，如果最大线程数也满了则会根据饱和策略处理。
    常用的饱和策略有:

    - 直接丢弃任务。
    - 调用者线程处理。
    - 丢弃队列中的最近任务，执行当前任务。

    所以当线程池完成预热之后都是将任务放入队列，接着由工作线程一个个从队列里取出执行。
    合理配置线程池
    线程池并不是配置越大越好，而是要根据任务的熟悉来进行划分： 如果是 CPU 密集型任务应当分配较少的线程，比如 CPU 个数相当的大小。
    如果是 IO 密集型任务，由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 \* 2 。
    当是一个混合型任务，可以将其拆分为 CPU 密集型任务以及 IO 密集型任务，这样来分别配置。

# Java 线程池详解

> 全面介绍 Java 线程池的概念、原理、使用方法和最佳实践

## 目录

-   [1. 线程池基础](#1-线程池基础)
-   [2. 线程池核心参数](#2-线程池核心参数)
-   [3. 线程池工作原理](#3-线程池工作原理)
-   [4. 线程池类型](#4-线程池类型)
-   [5. 拒绝策略](#5-拒绝策略)
-   [6. 线程池配置](#6-线程池配置)
-   [7. 最佳实践](#7-最佳实践)

---

## 1. 线程池基础

### 1.1 什么是线程池

线程池是一种**池化资源技术**，预先创建一定数量的线程并放入池中，需要时从池中获取，使用完毕后归还到池中，从而避免频繁创建和销毁线程的开销。

**核心概念：**

-   **池化思想**：预创建资源，重复利用，减少创建销毁开销
-   **资源管理**：统一管理线程的生命周期
-   **任务解耦**：任务提交和线程执行分离

### 1.2 线程池的优势

| 优势         | 说明                 | 效果         |
| ------------ | -------------------- | ------------ |
| **资源复用** | 避免频繁创建销毁线程 | 减少系统开销 |
| **响应速度** | 任务无需等待线程创建 | 提高响应效率 |
| **可管理性** | 统一分配、调优和监控 | 便于资源控制 |
| **稳定性**   | 控制并发数量         | 避免资源耗尽 |

### 1.3 Java 线程池架构

```
Executor (接口)
    ↓
ExecutorService (接口)
    ↓
AbstractExecutorService (抽象类)
    ↓
ThreadPoolExecutor (实现类)
```

**Java 5+ 线程池体系：**

-   **Executor**：定义执行任务的方法
-   **ExecutorService**：扩展 Executor，提供管理方法
-   **ThreadPoolExecutor**：线程池的核心实现类
-   **Executors**：线程池工厂类，提供常用线程池线程池

    在面向对象编程中，创建和销毁对象是很费时间的，创建一个对象要获取内存资源或者其它更多资源。Java 虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是“池化资源”技术产生的原因
    线程池，就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销
    Java 5+ 中的 Executor 接口定义一个执行线程的工具，它的子类型即线程池接口是 ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类 Executors 面提供了一些静态工厂方法，生成一些常用的线程池：

    -   newSingleThreadExecutor
        创建一个单线程的线程池，这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行
    -   newFixedThreadPool
        创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程
    -   newCachedThreadPool
        创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小
    -   newScheduledThreadPool
        创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求

    ### 为什么要使用线程池

    避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。

---

## 2. 线程池核心参数

### 2.1 ThreadPoolExecutor 构造方法

```java
public ThreadPoolExecutor(int corePoolSize,
                         int maximumPoolSize,
                         long keepAliveTime,
                         TimeUnit unit,
                         BlockingQueue<Runnable> workQueue,
                         ThreadFactory threadFactory,
                         RejectedExecutionHandler handler)
```

### 2.2 核心参数详解

| 参数                | 类型                     | 说明                               | 推荐配置                                     |
| ------------------- | ------------------------ | ---------------------------------- | -------------------------------------------- |
| **corePoolSize**    | int                      | 核心线程数，始终存活的线程数       | CPU 密集型=CPU 核数<br>IO 密集型=CPU 核数 ×2 |
| **maximumPoolSize** | int                      | 最大线程数，线程池允许的最大线程数 | 根据系统负载能力设定                         |
| **keepAliveTime**   | long                     | 非核心线程空闲存活时间             | 30-60 秒                                     |
| **unit**            | TimeUnit                 | keepAliveTime 的时间单位           | TimeUnit.SECONDS                             |
| **workQueue**       | BlockingQueue            | 任务等待队列                       | 根据业务场景选择                             |
| **threadFactory**   | ThreadFactory            | 线程工厂，用于创建线程             | 自定义线程名称                               |
| **handler**         | RejectedExecutionHandler | 拒绝策略，队列满时的处理方式       | 根据业务需求选择                             |

### 2.3 工作队列类型

| 队列类型                  | 容量      | 特点                   | 适用场景                   |
| ------------------------- | --------- | ---------------------- | -------------------------- |
| **ArrayBlockingQueue**    | 有界      | 基于数组的 FIFO 队列   | 内存敏感，需要限制队列大小 |
| **LinkedBlockingQueue**   | 有界/无界 | 基于链表的 FIFO 队列   | 吞吐量优先，允许较大队列   |
| **SynchronousQueue**      | 0         | 不存储元素的同步队列   | 任务量不大，需要立即处理   |
| **PriorityBlockingQueue** | 无界      | 支持优先级的无界队列   | 需要按优先级处理任务       |
| **DelayQueue**            | 无界      | 支持延时获取的无界队列 | 延时任务、定时任务         |

### 2.4 队列选择对线程池行为的影响

**队列已满时的处理：**

-   **无界队列** (如 LinkedBlockingQueue)

    ```
    任务继续添加到队列 → 等待执行 → 可能导致内存溢出
    ```

-   **有界队列** (如 ArrayBlockingQueue)
    ```
    任务队列满了 → 创建新线程(直到最大线程数) → 触发拒绝策略
    ```

---

## 3. 线程池工作原理

### 3.1 任务执行流程

![线程池执行流程](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687053962-02fe8165-06c9-41c1-8d4b-63f03628fa58.png)

**执行步骤详解：**

1. **提交任务** → 检查核心线程数

    ```
    当前线程数 < corePoolSize？
    ├─ 是：创建核心线程执行任务
    └─ 否：进入步骤2
    ```

2. **核心线程已满** → 检查工作队列

    ```
    工作队列未满？
    ├─ 是：任务加入队列等待
    └─ 否：进入步骤3
    ```

3. **队列已满** → 检查最大线程数

    ```
    当前线程数 < maximumPoolSize？
    ├─ 是：创建非核心线程执行任务
    └─ 否：进入步骤4
    ```

4. **达到最大线程数** → 执行拒绝策略
    ```
    触发RejectedExecutionHandler处理任务
    ```

### 3.2 线程生命周期管理

**核心线程：**

-   始终保持存活（除非设置 allowCoreThreadTimeOut=true）
-   从队列中获取任务执行
-   空闲时等待新任务

**非核心线程：**

-   队列满时临时创建
-   空闲超过 keepAliveTime 后销毁
-   优先级低于核心线程

### 3.3 线程池状态转换

| 状态           | 说明     | 特点                       |
| -------------- | -------- | -------------------------- |
| **RUNNING**    | 运行状态 | 接受新任务，处理队列任务   |
| **SHUTDOWN**   | 关闭状态 | 不接受新任务，处理现有任务 |
| **STOP**       | 停止状态 | 不接受新任务，中断现有任务 |
| **TIDYING**    | 整理状态 | 所有任务终止，线程数为 0   |
| **TERMINATED** | 终止状态 | terminated()方法执行完成   |

**状态转换流程：**

```
RUNNING → shutdown() → SHUTDOWN → 队列为空且线程为0 → TIDYING → terminated() → TERMINATED
    ↓
shutdownNow() → STOP → 线程中断完成 → TIDYING → terminated() → TERMINATED
```

---

## 4. 线程池类型

### 4.1 Executors 工厂方法

Java 提供了`Executors`工厂类来创建常用的线程池类型：

| 方法                        | 线程池类型 | 核心特点             | 适用场景             |
| --------------------------- | ---------- | -------------------- | -------------------- |
| `newFixedThreadPool(n)`     | 固定线程池 | 固定线程数，无界队列 | 负载较重的服务器     |
| `newSingleThreadExecutor()` | 单线程池   | 单线程，无界队列     | 需要顺序执行的任务   |
| `newCachedThreadPool()`     | 缓存线程池 | 无核心线程，60s 超时 | 执行大量短期异步任务 |
| `newScheduledThreadPool(n)` | 定时线程池 | 支持定时和周期性任务 | 定时任务调度         |

### 4.2 各类型线程池详解

#### 4.2.1 FixedThreadPool - 固定线程池

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                 0L, TimeUnit.MILLISECONDS,
                                 new LinkedBlockingQueue<Runnable>());
}
```

**特点：**

-   核心线程数 = 最大线程数
-   使用无界 LinkedBlockingQueue
-   线程不会超时销毁

**适用场景：**

-   负载比较重的服务器
-   需要控制并发数的场景

#### 4.2.2 SingleThreadExecutor - 单线程池

```java
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                               0L, TimeUnit.MILLISECONDS,
                               new LinkedBlockingQueue<Runnable>()));
}
```

**特点：**

-   只有一个线程执行任务
-   保证任务按提交顺序执行
-   线程异常终止会创建新线程替代

**适用场景：**

-   需要顺序执行的任务
-   单线程串行处理

#### 4.2.3 CachedThreadPool - 缓存线程池

```java
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                 60L, TimeUnit.SECONDS,
                                 new SynchronousQueue<Runnable>());
}
```

**特点：**

-   无核心线程，最大线程数无限制
-   使用 SynchronousQueue（容量为 0）
-   线程空闲 60 秒后销毁

**适用场景：**

-   执行大量短期异步任务
-   任务执行时间短

#### 4.2.4 ScheduledThreadPool - 定时线程池

```java
public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {
    return new ScheduledThreadPoolExecutor(corePoolSize);
}
```

**特点：**

-   支持定时和周期性任务执行
-   使用 DelayedWorkQueue
-   核心线程不超时

**使用示例：**

```java
ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

// 延时执行
scheduler.schedule(() -> System.out.println("延时5秒执行"), 5, TimeUnit.SECONDS);

// 周期性执行
scheduler.scheduleAtFixedRate(() -> System.out.println("每10秒执行一次"),
                             0, 10, TimeUnit.SECONDS);
```

### 4.3 为什么不推荐使用 Executors

**阿里巴巴 Java 开发手册明确规定：**

> 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式。

**原因分析：**

| 线程池类型               | 潜在问题                          | 风险                     |
| ------------------------ | --------------------------------- | ------------------------ |
| **FixedThreadPool**      | LinkedBlockingQueue 无界          | 可能导致 OOM             |
| **SingleThreadExecutor** | LinkedBlockingQueue 无界          | 可能导致 OOM             |
| **CachedThreadPool**     | maximumPoolSize=Integer.MAX_VALUE | 可能创建大量线程导致 OOM |
| **ScheduledThreadPool**  | maximumPoolSize=Integer.MAX_VALUE | 可能创建大量线程导致 OOM |

**推荐做法：**

```java
// 推荐：手动创建ThreadPoolExecutor
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    10,                                    // 核心线程数
    20,                                    // 最大线程数
    60L,                                   // 空闲线程存活时间
    TimeUnit.SECONDS,                      // 时间单位
    new ArrayBlockingQueue<>(1000),        // 有界队列
    new ThreadFactoryBuilder()             // 自定义线程工厂
        .setNameFormat("business-pool-%d")
        .build(),
    new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
);
```

---

## 5. 拒绝策略

### 5.1 拒绝策略概述

当线程池达到最大线程数且工作队列已满时，会触发拒绝策略来处理新提交的任务。

### 5.2 内置拒绝策略

| 策略                    | 行为                     | 异常                       | 适用场景                   |
| ----------------------- | ------------------------ | -------------------------- | -------------------------- |
| **AbortPolicy**         | 直接丢弃任务并抛出异常   | RejectedExecutionException | 默认策略，需要感知任务失败 |
| **CallerRunsPolicy**    | 调用者线程执行任务       | 无                         | 任务重要，可以降低提交速度 |
| **DiscardPolicy**       | 静默丢弃任务             | 无                         | 任务不重要，允许丢失       |
| **DiscardOldestPolicy** | 丢弃最老任务，执行新任务 | 无                         | 优先处理最新任务           |

### 5.3 拒绝策略详解

#### 5.3.1 AbortPolicy - 中止策略（默认）

```java
public static class AbortPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException("Task " + r.toString() +
                                           " rejected from " + e.toString());
    }
}
```

**特点：**

-   抛出 RejectedExecutionException 异常
-   任务丢失，但能及时感知到拒绝
-   需要调用方处理异常

**使用场景：**

-   任务执行失败需要立即感知
-   对任务丢失敏感的场景

#### 5.3.2 CallerRunsPolicy - 调用者运行策略

```java
public static class CallerRunsPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run(); // 在调用者线程中执行
        }
    }
}
```

**特点：**

-   由提交任务的线程执行被拒绝的任务
-   降低任务提交速度，形成负反馈
-   不会丢失任务

**使用场景：**

-   任务不能丢失
-   可以接受性能降低

#### 5.3.3 DiscardPolicy - 丢弃策略

```java
public static class DiscardPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // 什么都不做，静默丢弃
    }
}
```

**特点：**

-   静默丢弃任务，不抛异常
-   无任何通知机制
-   性能最好

**使用场景：**

-   任务可以丢失
-   对性能要求极高

#### 5.3.4 DiscardOldestPolicy - 丢弃最老策略

```java
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll(); // 移除最老的任务
            e.execute(r);        // 重新提交当前任务
        }
    }
}
```

**特点：**

-   丢弃队列中最老的任务
-   腾出空间给新任务
-   优先保证最新任务的执行

**使用场景：**

-   最新的任务优先级更高
-   老任务可以被丢弃

### 5.4 自定义拒绝策略

```java
public class CustomRejectedExecutionHandler implements RejectedExecutionHandler {

    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        // 1. 记录日志
        log.warn("Task {} rejected from {}", r.toString(), executor.toString());

        // 2. 保存到数据库或消息队列
        saveToDatabase(r);

        // 3. 发送告警
        sendAlert("Thread pool rejection occurred");

        // 4. 根据业务需求处理
        if (isImportantTask(r)) {
            // 重要任务重新提交到其他线程池
            fallbackExecutor.execute(r);
        } else {
            // 非重要任务丢弃
            log.info("Non-important task discarded: {}", r.toString());
        }
    }

    private void saveToDatabase(Runnable task) {
        // 实现保存逻辑
    }

    private void sendAlert(String message) {
        // 实现告警逻辑
    }

    private boolean isImportantTask(Runnable task) {
        // 实现重要性判断逻辑
        return task instanceof ImportantTask;
    }
}
```

### 5.5 拒绝策略选择建议

| 业务场景         | 推荐策略               | 理由                       |
| ---------------- | ---------------------- | -------------------------- |
| **金融交易**     | AbortPolicy + 重试机制 | 不能丢失任务，需要异常处理 |
| **日志记录**     | DiscardOldestPolicy    | 优先记录最新日志           |
| **监控数据采集** | DiscardPolicy          | 可以丢失部分数据点         |
| **用户请求处理** | CallerRunsPolicy       | 降低请求频率，保证处理     |
| **批量数据处理** | 自定义策略             | 保存到队列稍后重试         |

---

## 6. 线程池配置

### 6.1 线程数量配置原则

合理的线程池配置需要根据任务特性来确定，不是越大越好。

#### 6.1.1 任务类型分析

| 任务类型       | 特征                     | 线程配置策略           | 推荐公式                                    |
| -------------- | ------------------------ | ---------------------- | ------------------------------------------- |
| **CPU 密集型** | 大量计算，很少等待       | 线程数 ≈ CPU 核数      | `CPU核数 + 1`                               |
| **IO 密集型**  | 频繁 IO 操作，线程常等待 | 线程数 > CPU 核数      | `CPU核数 × 2` 或 `CPU核数 ÷ (1 - 阻塞系数)` |
| **混合型**     | 既有计算又有 IO          | 拆分为不同类型分别处理 | 分别配置不同线程池                          |

#### 6.1.2 精确配置公式

**线程数 = CPU 核数 × 目标 CPU 使用率 × (1 + 平均等待时间/平均工作时间)**

**参数获取方法：**

```java
// 获取CPU核数
int cpuCount = Runtime.getRuntime().availableProcessors();

// 通过性能测试获取平均等待时间和工作时间
// 等待时间：线程等待IO、数据库等操作的时间
// 工作时间：线程实际执行计算的时间
```

#### 6.1.3 配置示例

**场景 1：CPU 密集型任务**

```java
// 图像处理、数学计算等
int corePoolSize = Runtime.getRuntime().availableProcessors();
int maximumPoolSize = corePoolSize;
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize, maximumPoolSize,
    60L, TimeUnit.SECONDS,
    new ArrayBlockingQueue<>(100),
    new ThreadFactoryBuilder().setNameFormat("cpu-task-%d").build(),
    new ThreadPoolExecutor.AbortPolicy()
);
```

**场景 2：IO 密集型任务**

```java
// 文件读写、网络请求、数据库操作等
int cpuCount = Runtime.getRuntime().availableProcessors();
int corePoolSize = cpuCount * 2;
int maximumPoolSize = cpuCount * 4;
ThreadPoolExecutor executor = new ThreadPoolExecutor(
    corePoolSize, maximumPoolSize,
    60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(1000),
    new ThreadFactoryBuilder().setNameFormat("io-task-%d").build(),
    new ThreadPoolExecutor.CallerRunsPolicy()
);
```

### 6.2 线程池大小动态调整

#### 6.2.1 动态调整 API

```java
ThreadPoolExecutor executor = new ThreadPoolExecutor(...);

// 动态调整核心线程数
executor.setCorePoolSize(20);

// 动态调整最大线程数
executor.setMaximumPoolSize(50);

// 动态调整空闲时间
executor.setKeepAliveTime(120, TimeUnit.SECONDS);

// 允许核心线程超时
executor.allowCoreThreadTimeOut(true);
```

#### 6.2.2 自适应线程池实现

```java
public class AdaptiveThreadPoolExecutor extends ThreadPoolExecutor {

    private final AtomicInteger submittedTaskCount = new AtomicInteger(0);
    private volatile long lastAdjustTime = System.currentTimeMillis();

    public AdaptiveThreadPoolExecutor(int corePoolSize, int maximumPoolSize,
                                    long keepAliveTime, TimeUnit unit,
                                    BlockingQueue<Runnable> workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    @Override
    public void execute(Runnable command) {
        submittedTaskCount.incrementAndGet();
        try {
            super.execute(command);
        } finally {
            submittedTaskCount.decrementAndGet();
        }

        // 每30秒调整一次
        if (System.currentTimeMillis() - lastAdjustTime > 30000) {
            adjustPoolSize();
            lastAdjustTime = System.currentTimeMillis();
        }
    }

    private void adjustPoolSize() {
        int queueSize = getQueue().size();
        int activeThreads = getActiveCount();
        int coreSize = getCorePoolSize();

        // 队列积压严重，增加核心线程数
        if (queueSize > coreSize * 2 && coreSize < getMaximumPoolSize()) {
            setCorePoolSize(Math.min(coreSize + 2, getMaximumPoolSize()));
            System.out.println("Increased core pool size to: " + getCorePoolSize());
        }
        // 线程空闲较多，减少核心线程数
        else if (activeThreads < coreSize / 2 && coreSize > 2) {
            setCorePoolSize(Math.max(coreSize - 1, 2));
            System.out.println("Decreased core pool size to: " + getCorePoolSize());
        }
    }
}
```

### 6.3 线程池监控

#### 6.3.1 关键监控指标

```java
public class ThreadPoolMonitor {

    public void printThreadPoolStatus(ThreadPoolExecutor executor) {
        System.out.println("=== 线程池状态监控 ===");
        System.out.println("核心线程数: " + executor.getCorePoolSize());
        System.out.println("最大线程数: " + executor.getMaximumPoolSize());
        System.out.println("当前线程数: " + executor.getPoolSize());
        System.out.println("活跃线程数: " + executor.getActiveCount());
        System.out.println("队列任务数: " + executor.getQueue().size());
        System.out.println("已完成任务数: " + executor.getCompletedTaskCount());
        System.out.println("总任务数: " + executor.getTaskCount());
        System.out.println("队列类型: " + executor.getQueue().getClass().getSimpleName());
        System.out.println("拒绝策略: " + executor.getRejectedExecutionHandler().getClass().getSimpleName());
    }
}
```

#### 6.3.2 告警机制

```java
@Component
public class ThreadPoolAlarmMonitor {

    @Scheduled(fixedRate = 30000) // 30秒检查一次
    public void monitorThreadPool() {
        ThreadPoolExecutor executor = getBusinessThreadPool();

        // 队列使用率告警
        double queueUsageRate = (double) executor.getQueue().size() / getQueueCapacity();
        if (queueUsageRate > 0.8) {
            sendAlert("线程池队列使用率过高: " + String.format("%.2f%%", queueUsageRate * 100));
        }

        // 线程使用率告警
        double threadUsageRate = (double) executor.getActiveCount() / executor.getMaximumPoolSize();
        if (threadUsageRate > 0.8) {
            sendAlert("线程池线程使用率过高: " + String.format("%.2f%%", threadUsageRate * 100));
        }

        // 任务执行速度告警
        long completedTasks = executor.getCompletedTaskCount();
        if (isTaskExecutionTooSlow(completedTasks)) {
            sendAlert("线程池任务执行速度过慢");
        }
    }

    private void sendAlert(String message) {
        // 发送告警通知
        System.err.println("ALERT: " + message);
    }
}
```

---

## 7. 最佳实践

### 7.1 线程池创建最佳实践

#### 7.1.1 推荐创建方式

```java
/**
 * 推荐的线程池创建方式
 */
@Configuration
public class ThreadPoolConfig {

    @Bean("businessThreadPool")
    public ThreadPoolExecutor businessThreadPool() {
        return new ThreadPoolExecutor(
            10,                                      // 核心线程数
            20,                                      // 最大线程数
            60L,                                     // 空闲线程存活时间
            TimeUnit.SECONDS,                        // 时间单位
            new ArrayBlockingQueue<>(1000),          // 有界队列
            new ThreadFactoryBuilder()               // 自定义线程工厂
                .setNameFormat("business-thread-%d")
                .setDaemon(false)
                .setPriority(Thread.NORM_PRIORITY)
                .setUncaughtExceptionHandler((t, e) -> {
                    log.error("Thread {} threw exception", t.getName(), e);
                })
                .build(),
            new RejectedExecutionHandler() {         // 自定义拒绝策略
                @Override
                public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                    log.warn("Task rejected: {}", r.toString());
                    // 可以保存到数据库或重新提交到备用线程池
                    try {
                        executor.getQueue().offer(r, 3, TimeUnit.SECONDS);
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        throw new RejectedExecutionException("Task " + r + " rejected", e);
                    }
                }
            }
        );
    }
}
```

#### 7.1.2 线程池命名规范

```java
/**
 * 线程池命名最佳实践
 */
public class ThreadPoolNamingExample {

    // 业务线程池命名
    private final ThreadPoolExecutor orderProcessPool = new ThreadPoolExecutor(
        // ... 其他参数
        new ThreadFactoryBuilder()
            .setNameFormat("order-process-pool-%d")  // 订单处理线程池
            .build(),
        // ... 其他参数
    );

    private final ThreadPoolExecutor emailSendPool = new ThreadPoolExecutor(
        // ... 其他参数
        new ThreadFactoryBuilder()
            .setNameFormat("email-send-pool-%d")     // 邮件发送线程池
            .build(),
        // ... 其他参数
    );

    private final ThreadPoolExecutor fileUploadPool = new ThreadPoolExecutor(
        // ... 其他参数
        new ThreadFactoryBuilder()
            .setNameFormat("file-upload-pool-%d")    // 文件上传线程池
            .build(),
        // ... 其他参数
    );
}
```

### 7.2 线程池使用最佳实践

#### 7.2.1 合理的任务提交方式

```java
public class ThreadPoolUsageExample {

    @Autowired
    private ThreadPoolExecutor businessThreadPool;

    /**
     * 异步执行无返回值任务
     */
    public void executeAsyncTask() {
        businessThreadPool.execute(() -> {
            try {
                // 执行业务逻辑
                processBusinessLogic();
            } catch (Exception e) {
                log.error("Task execution failed", e);
                // 异常处理逻辑
            }
        });
    }

    /**
     * 异步执行有返回值任务
     */
    public Future<String> submitTask() {
        return businessThreadPool.submit(() -> {
            try {
                // 执行业务逻辑并返回结果
                return processBusinessLogicWithResult();
            } catch (Exception e) {
                log.error("Task execution failed", e);
                throw new RuntimeException("Task failed", e);
            }
        });
    }

    /**
     * 批量任务执行
     */
    public List<Future<String>> executeBatchTasks(List<String> taskParams) {
        List<Future<String>> futures = new ArrayList<>();

        for (String param : taskParams) {
            Future<String> future = businessThreadPool.submit(() -> {
                return processTask(param);
            });
            futures.add(future);
        }

        return futures;
    }
}
```

#### 7.2.2 优雅关闭线程池

```java
public class ThreadPoolShutdownExample {

    private final ThreadPoolExecutor executor;

    /**
     * 优雅关闭线程池
     */
    public void shutdownGracefully() {
        try {
            // 1. 停止接收新任务
            executor.shutdown();

            // 2. 等待已提交任务完成（最多等待60秒）
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                // 3. 如果等待超时，强制关闭
                List<Runnable> droppedTasks = executor.shutdownNow();
                log.warn("Dropped {} tasks", droppedTasks.size());

                // 4. 再次等待一段时间
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    log.error("Thread pool did not terminate gracefully");
                }
            }
        } catch (InterruptedException e) {
            // 5. 当前线程被中断，强制关闭线程池
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    /**
     * Spring容器关闭时自动执行
     */
    @PreDestroy
    public void destroy() {
        shutdownGracefully();
    }
}
```

### 7.3 性能优化建议

#### 7.3.1 避免常见错误

| 错误做法                  | 问题           | 正确做法                    |
| ------------------------- | -------------- | --------------------------- |
| 使用 Executors 创建线程池 | 可能 OOM       | 手动创建 ThreadPoolExecutor |
| 核心线程数设置过大        | 浪费资源       | 根据任务类型合理配置        |
| 队列设置过大              | 内存占用高     | 使用有界队列                |
| 忽略拒绝策略              | 任务丢失不可控 | 自定义拒绝策略              |
| 不设置线程名称            | 难以调试       | 使用有意义的线程名          |
| 不处理异常                | 线程异常终止   | 设置异常处理器              |

#### 7.3.2 性能调优技巧

```java
public class ThreadPoolPerformanceTips {

    /**
     * 预热线程池
     */
    public void warmUpThreadPool(ThreadPoolExecutor executor) {
        int corePoolSize = executor.getCorePoolSize();
        for (int i = 0; i < corePoolSize; i++) {
            executor.prestartCoreThread(); // 预启动核心线程
        }
        // 或者预启动所有核心线程
        // executor.prestartAllCoreThreads();
    }

    /**
     * 任务分解：将大任务分解为小任务
     */
    public void submitLargeTaskOptimized(List<String> largeDataSet) {
        int batchSize = 100;
        for (int i = 0; i < largeDataSet.size(); i += batchSize) {
            int end = Math.min(i + batchSize, largeDataSet.size());
            List<String> batch = largeDataSet.subList(i, end);

            executor.submit(() -> processBatch(batch));
        }
    }

    /**
     * 使用CompletableFuture进行异步编排
     */
    public CompletableFuture<String> asyncProcessWithDependency() {
        return CompletableFuture
            .supplyAsync(this::fetchUserInfo, executor)
            .thenCompose(user ->
                CompletableFuture.supplyAsync(() -> processUser(user), executor))
            .thenApply(this::formatResult)
            .exceptionally(throwable -> {
                log.error("Processing failed", throwable);
                return "Default result";
            });
    }
}
```

---

## 总结

线程池是 Java 并发编程的核心工具，合理使用线程池可以显著提升应用性能：

1. **理解核心参数**：正确配置 corePoolSize、maximumPoolSize、workQueue 等参数
2. **选择合适类型**：根据任务特性选择合适的线程池类型
3. **配置拒绝策略**：根据业务需求选择或自定义拒绝策略
4. **动态调优**：监控线程池状态，动态调整参数
5. **最佳实践**：遵循命名规范、优雅关闭、异常处理等最佳实践

通过深入理解线程池的工作原理和合理配置，可以在保证系统稳定性的同时，最大化发挥多核 CPU 的性能优势。
