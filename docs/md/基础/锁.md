## 锁相关

### 什么是乐观锁和悲观锁

乐观锁：乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。

悲观锁：悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。

### 聊聊 ReentrantLock 吧

ReentrantLock 意为可重入锁，说起 ReentrantLock 就不得不说 AQS ，因为其底层就是使用 AQS 去实现的。

ReentrantLock有两种模式，一种是公平锁，一种是非公平锁。

- 公平模式下等待线程入队列后会严格按照队列顺序去执行
- 非公平模式下等待线程入队列后有可能会出现插队情况

公平锁

![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687052025-2bf96a70-b543-496a-9fbc-2a6a8fbab5dc.png)

- 第一步：获取状态的 state 的值

- - 如果 state=0 即代表锁没有被其它线程占用，执行第二步。
  - 如果 state!=0 则代表锁正在被其它线程占用，执行第三步。

- 第二步：判断队列中是否有线程在排队等待

- - 如果不存在则直接将锁的所有者设置成当前线程，且更新状态 state 。
  - 如果存在就入队。

- 第三步：判断锁的所有者是不是当前线程

- - 如果是则更新状态 state 的值。
  - 如果不是，线程进入队列排队等待。

非公平锁

![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051916-02b67ed2-b1b3-4391-9200-9f9f7d1c5836.png)

- 获取状态的 state 的值

- - 如果 state=0 即代表锁没有被其它线程占用，则设置当前锁的持有者为当前线程，该操作用 CAS 完成。
  - 如果不为0或者设置失败，代表锁被占用进行下一步。

- 此时获取 state 的值

- - 如果是，则给state+1，获取锁
  - 如果不是，则进入队列等待
  - 如果是0，代表刚好线程释放了锁，此时将锁的持有者设为自己
  - 如果不是0，则查看线程持有者是不是自己

### 24.synchronized 锁升级的过程

在 Java1.6 之前的版本中，synchronized 属于重量级锁，效率低下，锁是 cpu 一个总量级的资源，每次获取锁都要和 cpu 申请，非常消耗性能。

在 jdk1.6 之后 Java 官方对从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了，Jdk1.6 之后，为了减少获得锁和释放锁所带来的性能消耗，引入了偏向锁和轻量级锁，增加了锁升级的过程，由无锁->偏向锁->自旋锁->重量级锁 ![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687052049-ef2ad665-a5b2-4845-9565-4e19613f7568.png)

增加锁升级的过程主要是减少用户态到核心态的切换，提高锁的效率，从 jvm 层面优化锁

### synchronized关键字的用法？

synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。

### 简述synchronized 和java.util.concurrent.locks.Lock的异同？

Lock是Java 5以后引入的新的API，和关键字synchronized相比主要相同点：Lock 能完成synchronized所实现的所有功能；主要不同点：Lock有比synchronized更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且最好在finally 块中释放（这是释放外部资源的最好的地方）。

### 当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？

不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。

### synchronized和ReentrantLock的区别

synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：

1. ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁
2. ReentrantLock可以获取各种锁的信息
3. ReentrantLock可以灵活地实现多路通知

另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word.

### synchronized关键字加在静态方法和实例方法的区别? 

修饰静态方法，是对类进行加锁，如果该类中有methodA 和methodB都是被synchronized修饰的静态 方法，此时有两个线程T1、T2分别调用methodA()和methodB()，则T2会阻塞等待直到T1执行完成之后 才能执行。 修饰实例方法时，是对实例进行加锁，锁的是实例对象的对象头，如果调用同一个对象的两个不同的被 synchronized修饰的实例方法时，看到的效果和上面的一样，如果调用不同对象的两个不同的被 synchronized修饰的实例方法时，则不会阻塞。 

### 18.countdownlatch的用法？ 

两种用法： 1、让主线程await，业务线程进行业务处理，处理完成时调用countdownLatch.countDown()， CountDownLatch实例化的时候需要根据业务去选择CountDownLatch的count; 2、让业务线程await，主线程处理完数据之后进行countdownLatch.countDown()，此时业务线程被唤 醒，然后去主线程拿数据，或者执行自己的业务逻辑。 

### synchronize 实现原理

[以下资源来源](https://github.com/crossoverJie/Java-Interview/blob/master/MD/Synchronize.md)

众所周知 Synchronize 关键字是解决并发问题常用解决方案，有以下三种使用方式:

- 同步普通方法，锁的是当前对象。
- 同步静态方法，锁的是当前 Class 对象。
- 同步块，锁的是 {} 中的对象。

实现原理： JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。

具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。

其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。

而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。

流程图如下:

![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1675687051874-faa73eb9-9a6a-4678-bbea-e0b517629b14.png)

synchronize 很多都称之为重量锁，JDK1.6 中对 synchronize 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁。

轻量锁

当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(Lock Record)区域，同时将锁对象的对象头中 Mark Word 拷贝到锁记录中，再尝试使用 CAS 将 Mark Word 更新为指向锁记录的指针。

如果更新成功，当前线程就获得了锁。

如果更新失败 JVM 会先检查锁对象的 Mark Word 是否指向当前线程的锁记录。

如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。

不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，轻量锁就会膨胀为重量锁。

解锁

轻量锁的解锁过程也是利用 CAS 来实现的，会尝试锁记录替换回锁对象的 Mark Word 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为重量锁)

轻量锁能提升性能的原因是：

认为大多数锁在整个同步周期都不存在竞争，所以使用 CAS 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，甚至比重量锁更慢。

偏向锁

为了进一步的降低获取锁的代价，JDK1.6 之后还引入了偏向锁。

偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。

当线程访问同步块时，会使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。

释放锁

当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 Mark Word 设置为无锁或者是轻量锁状态。

偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 -XX:-userBiasedLocking=false 来关闭偏向锁，并默认进入轻量锁。

### 23.Sychornized是否是公平锁？

不是公平锁 

26.描述一下锁的四种状态及升级过程？ 

以下是32位的对象头描述 public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } public void remove() { ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this); } synchronized锁的膨胀过程： 当线程访问同步代码块。首先查看当前锁状态是否是偏向锁(可偏向状态) 1、如果是偏向锁： 1.1、检查当前mark word中记录是否是当前线程id，如果是当前线程id，则获得偏向锁执行同步代码 块。 1.2、如果不是当前线程id，cas操作替换线程id，替换成功获得偏向锁(线程复用)，替换失败锁撤销升 级轻量锁(同一类对象多次撤销升级达到阈值20，则批量重偏向,这个点可以稍微提一下,详见下面的注意) 2、升级轻量锁 

### 如何预防死锁

1. 首先需要将死锁发生的是个必要条件讲出来：

1. 1. 互斥条件：同一时间只能有一个线程获取资源
   2. 不可剥夺条件：一个线程已经占有的资源，在释放之前不会被其它线程抢占
   3. 请求和保持条件：线程等待过程中不会释放已占有的资源
   4. 循环等待条件：多个线程互相等待对方释放资源

1. 预防死锁，就是需要破坏这四个必要条件

1. 1. 由于资源互斥是资源使用的固有特性，无法改变，不讨论
   2. 破坏不可剥夺条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将 被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进 程只有重新获得自己原有的资源以及新申请的资源才可以重新启动，执行
   3. 破坏请求与保持条件：

1. 1. 1. 第一种方法是，静态分配即每个进程在开始执行时就申请他所需要的全部资源
      2. 第二种是，动态分配即每个进程在申请所需要的资源时，他本身不占用系统资源

1. 1. 破坏循环等待条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的 采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小 编号的进程才能申请较大编号的进程

### 产生死锁的条件

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### Java当中有哪几种锁

自旋锁: 自旋锁在JDK1.6之后就默认开启了。基于之前的观察，共享数据的锁定状态只会持续很短的时间，为了这一小段时间而去挂起和恢复线程有点浪费，所以这里就做了一个处理，让后面请求锁的那个线程在稍等一会，但是不放弃处理器的执行时间，看看持有锁的线程能否快速释放。为了让线程等待，所以需要让线程执行一个忙循环也就是自旋操作。在jdk6之后，引入了自适应的自旋锁，也就是等待的时间不再固定了，而是由上一次在同一个锁上的自旋时间及锁的拥有者状态来决定

偏向锁: 在JDK1.之后引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语。进一步提升程序的运行性能。 偏向锁就是偏心的偏，意思是这个锁会偏向第一个获得他的线程，如果接下来的执行过程中，改锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。偏向锁可以提高带有同步但无竞争的程序性能，也就是说他并不一定总是对程序运行有利，如果程序中大多数的锁都是被多个不同的线程访问，那偏向模式就是多余的，在具体问题具体分析的前提下，可以考虑是否使用偏向锁。

轻量级锁: 为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁



### 简述Java偏向锁

JDK 1.6 中提出了偏向锁的概念。该锁提出的原因是，开发者发现多数情况下锁并不存在竞争，一把锁往往是由同一个线程获得的。偏向锁并不会主动释放，这样每次偏向锁进入的时候都会判断该资源是否是偏向自己的，如果是偏向自己的则不需要进行额外的操作，直接可以进入同步操作。

其申请流程为：

- 首先需要判断对象的 Mark Word 是否属于偏向模式，如果不属于，那就进入轻量级锁判断逻辑。否则继续下一步判断；
- 判断目前请求锁的线程 ID 是否和偏向锁本身记录的线程 ID 一致。如果一致，继续下一步的判断，如果不一致，跳转到步骤4；
- 判断是否需要重偏向。如果不用的话，直接获得偏向锁；
- 利用 CAS 算法将对象的 Mark Word 进行更改，使线程 ID 部分换成本线程 ID。如果更换成功，则重偏向完成，获得偏向锁。如果失败，则说明有多线程竞争，升级为轻量级锁。

### 简述轻量级锁

轻量级锁是为了在没有竞争的前提下减少重量级锁出现并导致的性能消耗。

其申请流程为：

- 如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。
- 虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针
- 如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。
- 如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧
- 如果指向当前线程的栈帧，说明当前线程已经拥有了锁，直接进入同步块继续执行
- 如果不是则说明锁对象已经被其他线程抢占。
- 如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。

### 简述锁优化策略

即自适应自旋、锁消除、锁粗化、锁升级等策略偏。

### 简述Java的自旋锁

线程获取锁失败后，可以采用这样的策略，可以不放弃 CPU ，不停的重试内重试，这种操作也称为自旋锁。

### 简述自适应自旋锁

自适应自旋锁自旋次数不再人为设定，通常由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。

### 简述锁粗化

锁粗化的思想就是扩大加锁范围，避免反复的加锁和解锁。

### 简述锁消除

锁消除是一种更为彻底的优化，在编译时，Java编译器对运行上下文进行扫描，去除不可能存在共享资源竞争的锁。

### 简述Lock与ReentrantLock

Lock接口是 Java并发包的顶层接口。

可重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入。ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会下降。



# 变量的线程安全问题



## 成员变量和静态变量



- 没有共享，线程安全
- 被共享，分两种情况： 

- - 只读，线程安全
  - 有写操作，该变量是临界区，则需要考虑线程安全



## 局部变量



-  局部变量本身是线程安全的 
-  局部变量引用的对象不一定是线程安全的 

- -  如果该引用的对象只存在于该函数的作用域中，则是线程安全 

```java
public static void test1() {
    int i = 10;
    i++;
}
```

 

- -  如果使用`return 语句`返回该引用对象，则需要考虑线程安全问题 



### 简述as-if-serial

编译器会对原始的程序进行指令重排序和优化。但不管怎么重排序，其结果都必须和用户原始程序输出的预定结果保持一致

### 简述happens-before八大规则

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
- 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

### as-if-serial 和 happens-before 的区别

as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。

### 简述原子性操作

一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行，这就是原子性操作。

### 简述线程的可见性

可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。volatile、synchronized、final 关键字都能保证可见性。

### 简述有序性

虽然多线程存在并发和指令优化等操作，但在本线程内观察该线程的所有执行操作是有序的。

### 简述Java中volatile关键字作用

- 保证变量对所有线程的可见性。当一个线程修改了变量值，新值对于其他线程来说是立即可以得知的。
- 禁止指令重排。使用 volatile 变量进行写操作，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器进行重排序。

### Java线程的实现方式

- 实现Runnable接口
- 继承Thread类
- 实现Callable接口

### 简述Java线程的状态

线程状态有 NEW、RUNNABLE、BLOCK、WAITING、TIMED_WAITING、THERMINATED

- NEW：新建状态，线程被创建且未启动，此时还未调用 start 方法。
- RUNNABLE：运行状态。表示线程正在JVM中执行，但是这个执行，不一定真的在跑，也可能在排队等CPU。
- BLOCKED：阻塞状态。线程等待获取锁，锁还没获得。
- WAITING：等待状态。线程内run方法执行完Object.wait()/Thread.join()进入该状态。
- TIMED_WAITING：限期等待。在一定时间之后跳出状态。调用Thread.sleep(long) Object.wait(long) Thread.join(long)进入状态。其中这些参数代表等待的时间。
- TERMINATED：结束状态。线程调用完run方法进入该状态。

### 简述线程通信的方式

- volatile 关键词修饰变量，保证所有线程对变量访问的可见性。
- synchronized关键词。确保多个线程在同一时刻只能有一个处于方法或同步块中。
- wait/notify方法
- IO通信

### 简述线程池

没有线程池的情况下，多次创建，销毁线程开销比较大。如果在开辟的线程执行完当前任务后复用已创建的线程，可以降低开销、控制最大并发数。

线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。

将任务派发给线程池时，会出现以下几种情况

- 核心线程池未满，创建一个新的线程执行任务。
- 如果核心线程池已满，工作队列未满，将线程存储在工作队列。
- 如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务。
- 如果超过大小线程数，按照拒绝策略来处理任务。

线程池参数：

- corePoolSize：常驻核心线程数。超过该值后如果线程空闲会被销毁。
- maximumPoolSize：线程池能够容纳同时执行的线程最大数。
- keepAliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。
- workQueue：工作队列。
- threadFactory：线程工厂，用来生产一组相同任务的线程。
- handler：拒绝策略。

拒绝策略有以下几种：

- AbortPolicy：丢弃任务并抛出异常
- CallerRunsPolicy：重新尝试提交该任务
- DiscardOldestPolicy 抛弃队列里等待最久的任务并把当前任务加入队列
- DiscardPolicy 表示直接抛弃当前任务但不抛出异常。

### 简述Executor框架

Executor框架目的是将任务提交和任务如何运行分离开来的机制。用户不再需要从代码层考虑设计任务的提交运行，只需要调用Executor框架实现类的Execute方法就可以提交任务。

### 简述Executor的继承关系

- Executor：一个接口，其定义了一个接收Runnable对象的方法executor，该方法接收一个Runable实例执行这个任务。
- ExecutorService：Executor的子类接口，其定义了一个接收Callable对象的方法，返回 Future 对象，同时提供execute方法。
- ScheduledExecutorService：ExecutorService的子类接口，支持定期执行任务。
- AbstractExecutorService：抽象类，提供 ExecutorService 执行方法的默认实现。
- Executors：实现ExecutorService接口的静态工厂类，提供了一系列工厂方法用于创建线程池。
- ThreadPoolExecutor：继承AbstractExecutorService，用于创建线程池。
- ForkJoinPool: 继承AbstractExecutorService，Fork 将大任务分叉为多个小任务，然后让小任务执行，Join 是获得小任务的结果，类似于map reduce。
- ThreadPoolExecutor：继承ThreadPoolExecutor，实现ScheduledExecutorService，用于创建带定时任务的线程池。

### 简述线程池的状态

- Running：能接受新提交的任务，也可以处理阻塞队列的任务。
- Shutdown：不再接受新提交的任务，但可以处理存量任务，线程池处于running时调用shutdown方法，会进入该状态。
- Stop：不接受新任务，不处理存量任务，调用shutdownnow进入该状态。
- Tidying：所有任务已经终止了，worker_count（有效线程数）为0。
- Terminated：线程池彻底终止。在tidying模式下调用terminated方法会进入该状态。

### 简述线程池类型

- newCachedThreadPool 可缓存线程池，可设置最小线程数和最大线程数，线程空闲1分钟后自动销毁。
- newFixedThreadPool 指定工作线程数量线程池。
- newSingleThreadExecutor 单线程Executor。
- newScheduleThreadPool 支持定时任务的指定工作线程数量线程池。
- newSingleThreadScheduledExecutor 支持定时任务的单线程Executor。

### 简述阻塞队列

阻塞队列是生产者消费者的实现具体组件之一。当阻塞队列为空时，从队列中获取元素的操作将会被阻塞，当阻塞队列满了，往队列添加元素的操作将会被阻塞。具体实现有：

- ArrayBlockingQueue：底层是由数组组成的有界阻塞队列。
- LinkedBlockingQueue：底层是由链表组成的有界阻塞队列。
- PriorityBlockingQueue：阻塞优先队列。
- DelayQueue：创建元素时可以指定多久才能从队列中获取当前元素
- SynchronousQueue：不存储元素的阻塞队列，每一个存储必须等待一个取出操作
- LinkedTransferQueue：与LinkedBlockingQueue相比多一个transfer方法，即如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者。
- LinkedBlockingDeque：双向阻塞队列。

### 谈一谈ThreadLocal

ThreadLocal 是线程共享变量。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，ThreadLocalMap是每个线程私有的。

- set 给ThreadLocalMap设置值。
- get 获取ThreadLocalMap。
- remove 删除ThreadLocalMap类型的对象。

存在的问题：对于线程池，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用，造成一系列问题。

比如说内存泄漏。由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放，产生内存泄漏。

### 聊聊你对Java并发包下unsafe类的理解

对于 Java 语言，没有直接的指针组件，一般也不能使用偏移量对某块内存进行操作。这些操作相对来讲是安全（safe）的。

Java 有个类叫 Unsafe 类，这个类使 Java 拥有了像 C 语言的指针一样操作内存空间的能力，同时也带来了指针的问题。这个类可以说是 Java 并发开发的基础。

### Java中的乐观锁与CAS算法

乐观锁认为数据发送时发生并发冲突的概率不大，所以读操作前不上锁。

到了写操作时才会进行判断，数据在此期间是否被其他线程修改。如果发生修改，那就返回写入失败；如果没有被修改，那就执行修改操作，返回修改成功。

乐观锁一般都采用 Compare And Swap（CAS）算法进行实现。顾名思义，该算法涉及到了两个操作，比较（Compare）和交换（Swap）。

CAS 算法的思路如下：

- 该算法认为不同线程对变量的操作时产生竞争的情况比较少。
- 该算法的核心是对当前读取变量值 E 和内存中的变量旧值 V 进行比较。
- 如果相等，就代表其他线程没有对该变量进行修改，就将变量值更新为新值 N。
- 如果不等，就认为在读取值 E 到比较阶段，有其他线程对变量进行过修改，不进行任何操作。

### ABA问题及解决方法简述

CAS 算法是基于值来做比较的，如果当前有两个线程，一个线程将变量值从 A 改为 B ，再由 B 改回为 A ，当前线程开始执行 CAS 算法时，就很容易认为值没有变化，误认为读取数据到执行 CAS 算法的期间，没有线程修改过数据。

juc 包提供了一个 AtomicStampedReference，即在原始的版本下加入版本号戳，解决 ABA 问题。

### 简述常见的Atomic类

在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的++或者--方案，使用synchronized关键字和lock固然可以实现，但代价比较大，此时用原子类更加方便。基本数据类型的原子类有：

- AtomicInteger 原子更新整型
- AtomicLong 原子更新长整型
- AtomicBoolean 原子更新布尔类型

Atomic数组类型有：

- AtomicIntegerArray 原子更新整型数组里的元素
- AtomicLongArray 原子更新长整型数组里的元素
- AtomicReferenceArray 原子更新引用类型数组里的元素。

Atomic引用类型有：

- AtomicReference 原子更新引用类型
- AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记
- AtomicStampedReference 原子更新带有版本号的引用类型

FieldUpdater类型：

- AtomicIntegerFieldUpdater 原子更新整型字段的更新器
- AtomicLongFieldUpdater 原子更新长整型字段的更新器
- AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器

### 简述Atomic类基本实现原理

以AtomicIntger 为例。

方法getAndIncrement，以原子方式将当前的值加1，具体实现为：

- 在 for 死循环中取得 AtomicInteger 里存储的数值
- 对 AtomicInteger 当前的值加 1
- 调用 compareAndSet 方法进行原子更新
- 先检查当前数值是否等于 expect
- 如果等于则说明当前值没有被其他线程修改，则将值更新为 next，
- 如果不是会更新失败返回 false，程序会进入 for 循环重新进行 compareAndSet 操作。

### 简述CountDownLatch

CountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，调用countDown方法，计数器的值就减1，当计数器的值为0时，表示所有线程都执行完毕，然后在等待的线程就可以恢复工作了。只能一次性使用，不能reset。

### 简述CyclicBarrier

CyclicBarrier 主要功能和CountDownLatch类似，也是通过一个计数器，使一个线程等待其他线程各自执行完毕后再执行。但是其可以重复使用（reset）。

### 简述Semaphore

Semaphore即信号量。Semaphore 的构造方法参数接收一个 int 值，设置一个计数器，表示可用的许可数量即最大并发数。使用 acquire 方法获得一个许可证，计数器减一，使用 release 方法归还许可，计数器加一。如果此时计数器值为0，线程进入休眠。

### 简述Exchanger

Exchanger类可用于两个线程之间交换信息。可简单地将Exchanger对象理解为一个包含两个格子的容器，通过exchanger方法可以向两个格子中填充信息。线程通过exchange 方法交换数据，第一个线程执行 exchange 方法后会阻塞等待第二个线程执行该方法。当两个线程都到达同步点时这两个线程就可以交换数据当两个格子中的均被填充时，该对象会自动将两个格子的信息交换，然后返回给线程，从而实现两个线程的信息交换。

### 简述ConcurrentHashMap

JDK7采用锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。

get 除读到空值不需要加锁。该方法先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列算法定位到元素。put 须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。

JDK8的改进

- 取消分段锁机制，采用CAS算法进行值的设置，如果CAS失败再使用 synchronized 加锁添加元素
- 引入红黑树结构，当某个槽内的元素个数超过8且 Node数组 容量大于 64 时，链表转为红黑树。
- 使用了更加优化的方式统计集合内的元素数量。

### synchronized底层实现原理

Java 对象底层都会关联一个 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。

synchronized在JVM编译后会产生monitorenter 和 monitorexit 这两个字节码指令，获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。

执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。

### synchronized关键词使用方法

- 直接修饰某个实例方法
- 直接修饰某个静态方法
- 修饰代码块

### 

### 简述AQS

AQS（AbstractQuenedSynchronizer）抽象的队列式同步器。AQS是将每一条请求共享资源的线程封装成一个锁队列的一个结点（Node），来实现锁的分配。AQS是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。

子类通过继承同步器并实现它的抽象方法getState、setState 和 compareAndSetState对同步状态进行更改。

AQS获取独占锁/释放独占锁原理：

获取：（acquire）

- 调用 tryAcquire 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 addWaiter 方法加入到同步队列的尾部，在队列中自旋。
- 调用 acquireQueued 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞。

释放：（release）

- 调用 tryRelease 方法释放同步状态
- 调用 unparkSuccessor 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。

AQS获取共享锁/释放共享锁原理

获取锁（acquireShared）

- 调用 tryAcquireShared 方法尝试获取同步状态，返回值不小于 0 表示能获取同步状态。
- 释放（releaseShared），并唤醒后续处于等待状态的节点。

### 导致Java的线程池被瞬间占满的原因是什么

导致Java线程池被瞬间占满的原因有很多，以下是一些常见的原因：

1.任务队列满了：当任务队列中的任务数量超过了线程池的最大容量，新提交的任务将会被拒绝执行。这时如果不进行适当的处理，就会导致线程池被瞬间占满。

2.任务执行时间过长：当某个任务执行的时间过长时，该任务会一直占用一个线程，这会导致该线程无法执行其他任务，从而使线程池中的其他线程都处于等待状态，最终导致线程池被占满。

3.线程池配置不当：如果线程池的核心线程数和最大线程数都设置得过小，当有大量任务提交时，线程池就会被瞬间占满。

4.线程阻塞：当线程在执行任务时被阻塞，例如等待I/O操作或者等待某个锁时，该线程会一直占用一个线程资源，如果这种情况发生在多个线程上，就会导致线程池被占满。

5.资源不足：如果系统中的资源不足，例如内存不足或者文件句柄数达到了上限，就可能导致线程池被占满。

为了避免线程池被瞬间占满，可以通过合理的线程池配置、任务队列大小的调整、任务执行时间的优化等方式进行处理。同时，应该对任务的性质和系统资源的状况进行充分的了解和评估，以便对线程池的配置进行合理的调整。





### 在Spring Boot的Web项目中，通过controller调用service操作数据库，需要考虑多线程问题吗

在Spring Boot的Web项目中，如果在controller中调用service操作数据库，一般不需要考虑多线程问题，因为Spring框架本身就是线程安全的。

Spring框架使用了一种称为"Dependency Injection（依赖注入）"的技术，这种技术可以确保在同一时间只有一个线程访问每个Bean实例，避免了多线程并发访问时可能会出现的数据不一致或线程安全问题。

当然，如果在service层中有共享变量或全局变量等需要被多个线程访问的情况下，就需要考虑线程安全问题了，可以使用synchronized关键字或Lock接口来保证线程安全。

总之，在Spring Boot的Web项目中，如果使用了Spring框架的依赖注入功能，通常不需要过多考虑多线程问题，但是对于一些需要跨线程共享变量或全局状态的场景，需要考虑线程安全问题。





## cas 是什么

cas 叫做 CompareAndSwap，比较并交换，很多地方使用到了它，比如锁升级中自旋锁就有用到，主要是通过处理器的指令来保证操作的原子性，它主要包含三个变量：

- 1.变量内存地址
- 2.旧的预期值 A
- 3.准备设置的新值 B

当一个线程需要修改一个共享变量的值，完成这个操作需要先取出共享变量的值，赋给 A，基于 A 进行计算，得到新值 B，在用预期原值 A 和内存中的共享变量值进行比较，如果相同就认为其他线程没有进行修改，而将新值写入内存

![img](https://cdn.nlark.com/yuque/0/2023/png/29236088/1677824948632-47e0c41c-3cb4-4408-8ff8-3ae459bbe756.png)



CAS的缺点



- CPU开销比较大：在并发量比较高的情况下，如果许多线程反复尝试更新某一个变量，却又一直更新不成功，又因为自旋的时候会一直占用CPU，如果CAS一直更新不成功就会一直占用，造成CPU的浪费。
- ABA 问题：比如线程 A 去修改 1 这个值，修改成功了，但是中间 线程 B 也修改了这个值，但是修改后的结果还是 1，所以不影响 A 的操作，这就会有问题。可以用版本号来解决这个问题。
- 只能保证一个共享变量的原子性