## 性能监控与故障处理工具
### 命令行工具
#### jps
#### jinfo
#### jstack
#### jmap
#### jstat
#### jstatd
#### jcmd
### 图形化工具
#### jconsole
#### jmc
#### visualvm
### 远程连接
#### jmx
#### jstatd
## JVM调优
### JVM如何调优、调什么、目标
#### 内存方面

- JVM 需要的内存总大小
- 各块内存分配，新生代，老年代，存活区
- 选择合适的垃圾回收算法，控制 GC 停顿次数和时间
- 解决内存泄漏的问题，辅助代码优化
- 内存热点，检查那些对象在系统中数量最大，辅助代码优化
- 死锁检查，辅助代码优化
- Dump 线程详细信息：查看线程内部运行情况，查找竞争线程，辅助代码优化
- CPU 热点，检查系统那些方法占用了大量 CPU 时间，辅助代码优化
#### 线程方面
### 调优步骤

- 监控 JVM 的状态，主要是内存、线程、代码、I/O 等
- 分析结果，判断是否需要优化
- 调整垃圾回收算法和内存分配，优化代码
- 不断重复监控、分析和调整，直到找到优化平衡点
### 调优目标

- GC 的时间要足够小
- GC 的次数要足够少
- 将转移到老年代的对象数量降低到最小
- 减少 Full GC 的执行时间
- 发生 Full GC 的间隔足够的长
### JVM调优策略

- 减少创建对象的数量
- 减少使用全局变量和大对象
- 调整新生代、老年代的大小到最合适
- 选择合适的 GC 收集器，并设置合理的参数
### JVM调优冷思考

- 多少的 Java 应用不需要在服务器上进行 GC 优化
- 多数导致 GC 问题的 Java 应用，都不是因为参数设置错误导致的，而是代码问题
- 在应用上线之前，先考虑将机器的 JVM 参数设置到最优
- JVM 优化是最后不得已才采用的手段，优先是优化代码
- 在实际情况中，分析 JVM 情况优化代码比优化 JVM 本身要多得多
- 如下情况通常不用优化
   - Minor GC 执行时间不到 50 ms
   - Minor GC 执行不频繁，约 10 秒一次
   - Full GC 执行时间不到 1 秒
   - Full GC 执行不频繁，约 10 分钟一次
### JVM调优经验

- 要注意 32 位和 64 位的区别，通常 32 位的仅支持 2 - 3 g 左右的内存
- 要注意 client 模式和 server 模式的选择
- 要想 GC 时间小必须要一个更小的堆，而要保证 GC 次数足够少，又必须保证一个更大的堆，这两个是冲突的，只能取其平衡
- 针对 JVM 堆的设置，一般通过 -Xms -Xmx 限定其最小最大值，防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间开销，通常把最大、最小设置为相同的值
- 新生代和老年代将根据默认的比例（1 : 2）来分配堆内存，可以通过 NewRadio 来调整比例，也可以通过 -XX:newSize -XX:MaxNewSize 来设置其绝对大小，同样，为了防止新生的堆收缩，通常会把 -XX:newSize -XX:MaxNewSize 设置为相同大小
- 合理规划新生代和老年代的大小
- 如果应用存在大量的临时对象，应该选择更大的新生代；如果存在相对较多的持久对象，应该适当的增大老年代。在抉择时应该本着 Full GC 尽量少的原则，让老年代尽量缓存常用对象，JVM 的默认比例 1 : 2 也是这个道理
- 通过观察应用一段时间，看其在峰值时老年代会占用多少内存，在不影响 Full GC 的前提下，根据实际情况加大新生代，但应该给老年代至少预留 1/3 的增长空间
- 线程堆栈的设置：每个线程默认会开启 1 M 的堆栈，用于存放栈帧、调用参数、局部变量等，对于大多数应用而言这个默认值太大，一般 256 K 够用，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程
#### 内存泄漏

- 内存泄漏导致系统崩溃前的一些现象，如：
   - 每次垃圾回收的时间越来越长，FullGC 时间也延长到好几秒
   - FullGC 的次数越来越多，最频繁时间间隔不到 1 分钟，内存泄漏后是不会释放内存的
   - 老年代的内存越来越大，并且每次 FullGC 后老年代没有内存被释放
   - 老年代堆空间被占满
- 解决方案：一般根据垃圾回收前后情况对比，同时根据对象引用情况分析，辅助去查找泄漏点
- 堆栈溢出的情况：
   - 通常抛出 StackOverflowError
   - 一般是递归调用没退出，或者循环调用造成
