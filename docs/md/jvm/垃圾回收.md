## 垃圾回收基础
### 什么是垃圾
内存中已经不再被使用到的内存空间就是垃圾
### 如何判断垃圾
判断方法有：引用计数法、根搜索算法

- 引用计数法：给对象添加一个引用计数器，有访问就加 1，引用失效就减 1
   - 优点：实现简单、效率高
   - 缺点：不能解决对象之间循环引用的问题，商用虚拟机都不采用该方法
- 根搜索算法：从根（GC Roots）节点向下搜索对象节点，搜索走过的路径称为引用链，当一个对象到根之间没有连通的话，则该对象不可用
   - 可作为 GC Roots 的对象包括：虚拟机栈（栈帧局部变量）中引用的对象、方法区类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中 JNI 引用的对象、被同步锁持有的对象等
   - 在大型应用程序中，对象的引用特别复杂，引用链特别长，每一个对象都使用根搜索算法将导致性能下降
   - HotSpot 使用一组叫 OopMap 的数据结构（用于描述对象间引用关系的数据结构）达到准确 GC 的目的，就不用每次都使用根搜索算法，极大的提高了 GC 效率
   - 使用 OopMap，JVM 可以很快的做完 GC Roots 枚举，但 JVM 并没有为每一条指令生成一个 OopMap
   - 记录 OopMap 的“特定位置”被称为安全点，即当前线程执行到安全点后才允许暂停进行 GC
   - 如果一段代码中，对象引用关系不会发生变化，这个区域中任何地方开始 GC 都是安全的，那么这个区域称为安全区域
### 判断垃圾的步骤

1. 根搜索算法判断不可用，不可用时成为垃圾的几率非常高
2. 看是否有必要执行 finalize() 方法，对象第一次回收时调用 finalize() 方法
   1. 如果对象没有覆盖 finalize() 方法或 finalize() 方法已经被虚拟机调用过，就属于没有必要执行 finalize() 方法的情况
   2. 如果对象覆盖了 finalize() 方法，在方法中重新使用本对象，即对象自救，该对象还不能被垃圾回收
3. 前两个步骤走完后，对象仍然没有被使用，那该对象就属于垃圾
### 判断类无用的条件

- JVM 中该类的所有实例都已经被回收
- 加载该类的 ClassLoader 被回收
- 没有任何地方引用该类的 Class 对象
- 无法在任何地方通过反射访问这个类
### 引用分类

- 强引用：通过 new 创建的对象，不能被回收
- 软引用：还有用但并不必须的对象，用 SoftReference 来实现
- 弱引用：非必须的对象，垃圾回收时会回收掉，用 WeakReference 来实现
- 虚引用：最弱的引用，垃圾回收时会回收掉，用 PhantomReference 来实现
### 跨代引用

- 一个代中的对象引用另一个代中的对象
- 跨代引用假说：跨代引用相对于同代引用来说只是极少数
- 隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或同时消亡的
### 记忆集（Remembered Set）

- 一种用于记录从非收集区域指向收集区域的指针集合（跨代引用的指针集合）的抽象数据结构
- 精度
   - 字长精度：每个记录精确到一个机器字长，该字包含跨代指针
   - 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针
   - 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针
   - 卡表（Card Table）：是记忆集的一种具体实现，定义了记忆集的记录精度和与堆内存的映射关系等
   - 卡页（Card Page）：卡表的每个元素都对应其标识的内存区域中一块特定大小的内存块，这个内存块被称为卡页
### 写屏障

- 写屏障，可以看成 JVM 对“引用类型字段赋值”这个动作的 AOP
- 通过写屏障来实现当对象状态改变后，维护卡表状态
### GC 类型

- MinorGC/YoungGC：发生在新生代的收集动作
- MajorGC/OldGC：发生在老年代的 GC，目前只有 CMS 收集器会单独收集老年代
- MixedGC：收集整个新生代以及部分老年代，目前只有 G1 收集器会有这种行为
- FullGC：收集整个 Java 堆和方法区的 GC
### Stop-The-World

- STW 是 Java 中一种全局暂停的现象，多半是由于 GC 引起的
- 全局暂停就是所有 Java 代码停止运行，native 代码可以执行，但不能和 JVM 交互
- 长时间服务停止，没有响应
- 对应 HA 系统来说，可能引起主备切换，严重危害生产环境
### 垃圾收集类型

- 串行收集：GC 单线程内存回收，会暂停所有的用户线程，如：Serial
- 并行收集：多个 GC 线程并发工作，会暂停所有的用户线程，如：Parallel
- 并发收集：用户线程和 GC 线程同时执行，不需要停顿用户线程，如：CMS
## 垃圾收集算法
### 标记清除法

- 标记清除法（Mark-Sweep）算法分成标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象
- 优点是简单
- 缺点
   - 标记和清除的效率都不高
   - 标记清除后会产生大量不连续的内存碎片，从而导致在分配大对象时触发 GC
### 复制算法

- 复制算法（Copying）：把内存分成两块完全相同的区域，每次使用其中一块区域，当一块使用完后就将该区域中存活的对象拷贝到另一块中，然后将该区域的内存全部清除

### 标记整理法

### 分配担保（分代）

## 垃圾收集器
### HotSpot中的收集器
### 串行收集器
### 并行收集器
### 新生代 Parallel Scavenge 收集器
### CMS 收集器
### G1 收集器
#### 新生代回收过程
#### 老年代回收过程
### ZGC 收集器
### GC 性能指标
### JVM内存配置原则

