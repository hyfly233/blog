## Flowable是什么

* Flowable是一个使用Java编写的轻量级业务流程引擎。Flowable流程引擎可用于部署BPMN 2.0流程定义（用于定义流程的行业XML标准）， 创建这些流程定义的流程实例，进行查询，访问运行中或历史的流程实例与相关数据，等等。这个章节将用一个可以在你自己的开发环境中使用的例子，逐步介绍各种概念与API。
* Flowable可以十分灵活地加入你的应用/服务/构架。可以将JAR形式发布的Flowable库加入应用或服务，来嵌入引擎。 以JAR形式发布使Flowable可以轻易加入任何Java环境：Java SE；Tomcat、Jetty或Spring之类的servlet容器；JBoss或WebSphere之类的Java EE服务器等等。

* 中文文档：[https://tkjohn.github.io/flowable-userguide/](https://tkjohn.github.io/flowable-userguide/)
* 英文文档：[https://www.flowable.org/docs/userguide/index.html](https://www.flowable.org/docs/userguide/index.html)



Flowable是Activiti的fork



## 依赖

```xml
<dependencies>
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-engine</artifactId>
        <version>6.3.0</version>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <version>1.3.176</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-api</artifactId>
        <version>1.7.21</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-log4j12</artifactId>
        <version>1.7.21</version>
    </dependency>
</dependencies>
```

- Flowable流程引擎。使可以创建一个ProcessEngine流程引擎对象，并访问Flowable API
- 一个数据库



首先要做的是初始化**ProcessEngine**流程引擎实例。这是一个线程安全的对象，因此通常只需要在一个应用中初始化一次。 *ProcessEngine*由**ProcessEngineConfiguration**实例创建。该实例可以配置与调整流程引擎的设置。 通常使用一个配置XML文件创建*ProcessEngineConfiguration*，但是也可以编程方式创建它。 *ProcessEngineConfiguration*所需的最小配置，是数据库JDBC连接：

```java
public class HolidayRequest {
    public static void main(String[] args) {
        ProcessEngineConfiguration cfg = new StandaloneProcessEngineConfiguration()
            .setJdbcUrl("jdbc:h2:mem:flowable;DB_CLOSE_DELAY=-1")
            .setJdbcUsername("root")
            .setJdbcPassword("")
            .setJdbcDriver("org.h2.Driver")
            .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);

        ProcessEngine processEngine = cfg.buildProcessEngine();
    }

}
```

创建了一个*独立(standalone)*配置对象。这里的*'独立'*指的是引擎是完全独立创建及使用的（而不是在Spring环境中使用，这时需要使用*SpringProcessEngineConfiguration*类代替） 



然后使用这个配置创建**ProcessEngine**对象



在*src/main/resources*文件夹下添加*log4j.properties*文件，并写入下列内容

```properties
log4j.rootLogger=DEBUG, CA

log4j.appender.CA=org.apache.log4j.ConsoleAppender
log4j.appender.CA.layout=org.apache.log4j.PatternLayout
log4j.appender.CA.layout.ConversionPattern= %d{hh:mm:ss,SSS} [%t] %-5p %c %x - %m%n
```



## 部署流程定义

Flowable引擎需要流程定义为BPMN 2.0格式，这是一个业界广泛接受的XML标准。 在Flowable术语中，将其称为一个**流程定义(process definition)**。一个*流程定义*可以启动多个**流程实例(process instance)**。*流程定义*可以看做是重复执行流程的蓝图。 



BPMN 2.0存储为XML，并包含可视化的部分：使用标准方式定义了每个步骤类型（人工任务，自动服务调用，等等）如何呈现，以及如何互相连接。这样BPMN 2.0标准使技术人员与业务人员能用双方都能理解的方式交流业务流程



一般来说，流程定义*使用可视化建模工具建立

在*src/main/resources*文件夹下名为*holiday-request.bpmn20.xml*的文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns:flowable="http://flowable.org/bpmn"
             typeLanguage="http://www.w3.org/2001/XMLSchema"
             expressionLanguage="http://www.w3.org/1999/XPath"
             targetNamespace="http://www.flowable.org/processdef">

    <process id="holidayRequest" name="Holiday Request" isExecutable="true">

        <startEvent id="startEvent"/>
        <sequenceFlow sourceRef="startEvent" targetRef="approveTask"/>

        <userTask id="approveTask" name="Approve or reject request"/>
        <sequenceFlow sourceRef="approveTask" targetRef="decision"/>

        <exclusiveGateway id="decision"/>
        <sequenceFlow sourceRef="decision" targetRef="externalSystemCall">
            <conditionExpression xsi:type="tFormalExpression">
                <![CDATA[
          ${approved}
        ]]>
            </conditionExpression>
        </sequenceFlow>
        <sequenceFlow sourceRef="decision" targetRef="sendRejectionMail">
            <conditionExpression xsi:type="tFormalExpression">
                <![CDATA[
          ${!approved}
        ]]>
            </conditionExpression>
        </sequenceFlow>

        <serviceTask id="externalSystemCall" name="Enter holidays in external system"
                     flowable:class="org.flowable.CallExternalSystemDelegate"/>
        <sequenceFlow sourceRef="externalSystemCall" targetRef="holidayApprovedTask"/>

        <userTask id="holidayApprovedTask" name="Holiday approved"/>
        <sequenceFlow sourceRef="holidayApprovedTask" targetRef="approveEnd"/>

        <serviceTask id="sendRejectionMail" name="Send out rejection email"
                     flowable:class="org.flowable.SendRejectionMail"/>
        <sequenceFlow sourceRef="sendRejectionMail" targetRef="rejectEnd"/>

        <endEvent id="approveEnd"/>

        <endEvent id="rejectEnd"/>

    </process>

</definitions>
```



已经有了流程BPMN 2.0 XML文件，下来需要将它***部署(deploy)\***到引擎中。*部署*一个流程定义意味着：

- 流程引擎会将XML文件存储在数据库中，这样可以在需要的时候获取它。
- 流程定义转换为内部的、可执行的对象模型，这样使用它就可以启动*流程实例*。

将流程定义*部署*至Flowable引擎，需要使用*RepositoryService*，其可以从*ProcessEngine*对象获取。使用*RepositoryService*，可以通过XML文件的路径创建一个新的*部署(Deployment)*，并调用*deploy()*方法实际执行：

```java
RepositoryService repositoryService = processEngine.getRepositoryService();
Deployment deployment = repositoryService.createDeployment()
    .addClasspathResource("holiday-request.bpmn20.xml")
    .deploy();
```



可以通过API查询验证流程定义已经部署在引擎中。通过*RepositoryService*创建的*ProcessDefinitionQuery*对象实现

```java
ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()
    .deploymentId(deployment.getId())
    .singleResult();
System.out.println("Found process definition : " + processDefinition.getName());
```





## 启动流程实例

在流程引擎中*部署*了流程定义，因此可以使用这个*流程定义*作为“蓝图”启动*流程实例* 

要启动流程实例，需要提供一些初始化*流程变量*。一般来说，可以通过呈现给用户的表单，或者在流程由其他系统自动触发时通过REST API，来获取这些变量



简化为使用java.util.Scanner类在命令行输入一些数据

```java
Scanner scanner= new Scanner(System.in);

System.out.println("Who are you?");
String employee = scanner.nextLine();

System.out.println("How many holidays do you want to request?");
Integer nrOfHolidays = Integer.valueOf(scanner.nextLine());

System.out.println("Why do you need them?");
String description = scanner.nextLine();
```





使用*RuntimeService*启动一个*流程实例*。收集的数据作为一个*java.util.Map*实例传递，其中的键就是之后用于获取变量的标识符。这个流程实例使用*key*启动。这个*key*就是BPMN 2.0 XML文件中设置的*id*属性，在这个例子里是*holidayRequest*

```xml
<process id="holidayRequest" name="Holiday Request" isExecutable="true">
```

或

```java
RuntimeService runtimeService = processEngine.getRuntimeService();

Map<String, Object> variables = new HashMap<String, Object>();
variables.put("employee", employee);
variables.put("nrOfHolidays", nrOfHolidays);
variables.put("description", description);
ProcessInstance processInstance =
    runtimeService.startProcessInstanceByKey("holidayRequest", variables);
```



在流程实例启动后，会创建一个**执行(execution)**，并将其放在启动事件上。从这里开始，这个*执行*沿着顺序流移动到经理审批的用户任务，并执行用户任务行为。这个行为将在数据库中创建一个任务，该任务可以之后使用查询找到。用户任务是一个*等待状态(wait state)*，引擎会停止执行，返回API调用处



## 查询与完成任务

将第一个任务指派给"经理(managers)"组，而第二个用户任务指派给请假申请的提交人。因此需要为第一个任务添加*candidateGroups*属性

```xml
<userTask id="approveTask" name="Approve or reject request" flowable:candidateGroups="managers"/>
```



为第二个任务添加*assignee*属性。请注意我们没有像上面的’managers’一样使用静态值，而是使用一个流程变量动态指派。这个流程变量是在流程实例启动时传递的

```xml
<userTask id="holidayApprovedTask" name="Holiday approved" flowable:assignee="${employee}"/>
```



要获得实际的任务列表，需要通过*TaskService*创建一个*TaskQuery*

```java
TaskService taskService = processEngine.getTaskService();
List<Task> tasks = taskService.createTaskQuery().taskCandidateGroup("managers").list();
System.out.println("You have " + tasks.size() + " tasks:");
for (int i=0; i<tasks.size(); i++) {
    System.out.println((i+1) + ") " + tasks.get(i).getName());
}
```



可以使用任务Id获取特定流程实例的变量，并在屏幕上显示实际的申请

```java
System.out.println("Which task would you like to complete?");
int taskIndex = Integer.valueOf(scanner.nextLine());
Task task = tasks.get(taskIndex - 1);
Map<String, Object> processVariables = taskService.getVariables(task.getId());
System.out.println(processVariables.get("employee") + " wants " +
                   processVariables.get("nrOfHolidays") + " of holidays. Do you approve this?");
```



再运行

经理现在就可以**完成任务**了。在现实中，这通常意味着由用户提交一个表单。表单中的数据作为*流程变量*传递。在这里，我们在完成任务时传递带有’approved’变量

```java
boolean approved = scanner.nextLine().toLowerCase().equals("y");
variables = new HashMap<String, Object>();
variables.put("approved", approved);
taskService.complete(task.getId(), variables);
```

现在任务完成，并会在离开排他网关的两条路径中，基于’approved’流程变量选择一条



## 实现JavaDelegate

实现申请通过后执行的自动逻辑。在BPMN 2.0 XML中，这是一个**服务任务(service task)**

```java
<serviceTask id="externalSystemCall" name="Enter holidays in external system"
    flowable:class="org.flowable.CallExternalSystemDelegate"/>
```



 在现实中，这个逻辑可以做任何事情：向某个系统发起一个HTTP REST服务调用，或调用某个使用了好几十年的系统中的遗留代码。我们不会在这里实现实际的逻辑，而只是简单的日志记录*流程*。 

```java
package org.flowable;

import org.flowable.engine.delegate.DelegateExecution;
import org.flowable.engine.delegate.JavaDelegate;

public class CallExternalSystemDelegate implements JavaDelegate {

    public void execute(DelegateExecution execution) {
        System.out.println("Calling the external system for employee "
            + execution.getVariable("employee"));
    }

}
```





## 使用历史数据

使用Flowable这样的流程引擎的原因之一，是它可以自动存储所有流程实例的**审计数据**或**历史数据**。这些数据可以用于创建报告，深入展现组织运行的情况，瓶颈在哪里，等等



如果希望显示流程实例已经执行的时间，就可以从*ProcessEngine*获取*HistoryService*，并创建*历史活动(historical activities)*的查询

```java
HistoryService historyService = processEngine.getHistoryService();
List<HistoricActivityInstance> activities =
    historyService.createHistoricActivityInstanceQuery()
    .processInstanceId(processInstance.getId())
    .finished()
    .orderByHistoricActivityInstanceEndTime().asc()
    .list();

for (HistoricActivityInstance activity : activities) {
    System.out.println(activity.getActivityId() + " took "
                       + activity.getDurationInMillis() + " milliseconds");
}
```











## 配置

### 创建ProcessEngine

Flowable流程引擎通过名为`flowable.cfg.xml`的XML文件进行配置

获取`ProcessEngine`，最简单的方式是使用`org.flowable.engine.ProcessEngines`类

```java
ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine()
```

这样会从classpath寻找`flowable.cfg.xml`，并用这个文件中的配置构造引擎

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="processEngineConfiguration" class="org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration">

        <property name="jdbcUrl" value="jdbc:h2:mem:flowable;DB_CLOSE_DELAY=1000" />
        <property name="jdbcDriver" value="org.h2.Driver" />
        <property name="jdbcUsername" value="sa" />
        <property name="jdbcPassword" value="" />

        <property name="databaseSchemaUpdate" value="true" />

        <property name="asyncExecutorActivate" value="false" />

        <property name="mailServerHost" value="mail.my-corp.com" />
        <property name="mailServerPort" value="5025" />
    </bean>

</beans>
```



这个配置XML文件实际上是一个Spring配置文件。**但这并不意味着Flowable只能用于Spring环境！**我们只是利用Spring内部的解析与依赖注入功能来简化引擎的构建过程

也可以通过编程方式使用配置文件，来构造ProcessEngineConfiguration对象

```java
ProcessEngineConfiguration.
    createProcessEngineConfigurationFromResourceDefault();
createProcessEngineConfigurationFromResource(String resource);
createProcessEngineConfigurationFromResource(String resource, String beanName);
createProcessEngineConfigurationFromInputStream(InputStream inputStream);
createProcessEngineConfigurationFromInputStream(InputStream inputStream, String beanName);
```

也可以不使用配置文件，使用默认配置

```java
ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();
ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration();
```



所有的`ProcessEngineConfiguration.createXXX()`方法都返回`ProcessEngineConfiguration`，并可以继续按需调整。调用`buildProcessEngine()`后，生成一个`ProcessEngine`

```java
ProcessEngine processEngine = ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration()
    .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_FALSE)
    .setJdbcUrl("jdbc:h2:mem:my-own-db;DB_CLOSE_DELAY=1000")
    .setAsyncExecutorActivate(false)
    .buildProcessEngine();
```



### ProcessEngineConfiguration bean

 `flowable.cfg.xml`文件中必须包含一个id为'processEngineConfiguration'的bean 

```java
<bean id="processEngineConfiguration" class="org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration">
```



这个bean用于构建`ProcessEngine`。有多个类可以用于定义`processEngineConfiguration`。这些类用于不同的环境，并各自设置一些默认值。最佳实践是选择最匹配你环境的类，以便减少配置引擎需要的参数。目前可以使用的类为：

- **org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration**：流程引擎独立运行。Flowable自行处理事务。在默认情况下，数据库检查只在引擎启动时进行（如果Flowable表结构不存在或表结构版本不对，会抛出异常）。
- **org.flowable.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration**：这是一个便于使用单元测试的类。Flowable自行处理事务。默认使用H2内存数据库。数据库会在引擎启动时创建，并在引擎关闭时删除。使用这个类时，很可能不需要更多的配置（除了使用任务执行器或邮件等功能时）。
- **org.flowable.spring.SpringProcessEngineConfiguration**：在流程引擎处于Spring环境时使用。
- **org.flowable.engine.impl.cfg.JtaProcessEngineConfiguration**：用于引擎独立运行，并使用JTA事务的情况。



### 配置数据库

有两种方式配置Flowable引擎使用的数据库。第一种方式是定义数据库的JDBC参数：

- **jdbcUrl**: 数据库的JDBC URL。
- **jdbcDriver**: 对应数据库类型的驱动。
- **jdbcUsername**: 用于连接数据库的用户名。
- **jdbcPassword**: 用于连接数据库的密码



通过提供的JDBC参数构造的数据源，使用默认的[MyBatis](http://www.mybatis.org/)连接池设置。可用下列属性调整这个连接池（来自MyBatis文档）：

- **jdbcMaxActiveConnections**: 连接池能够容纳的最大活动连接数量。默认值为10.
- **jdbcMaxIdleConnections**: 连接池能够容纳的最大空闲连接数量。
- **jdbcMaxCheckoutTime**: 连接从连接池“取出”后，被强制返回前的最大时间间隔，单位为毫秒。默认值为20000（20秒）。
- **jdbcMaxWaitTime**: 这是一个底层设置，在连接池获取连接的时间异常长时，打印日志并尝试重新获取连接（避免连接池配置错误，导致没有异常提示）。默认值为20000（20秒）。



数据库配置示例

```xml
<property name="jdbcUrl" value="jdbc:h2:mem:flowable;DB_CLOSE_DELAY=1000" />
<property name="jdbcDriver" value="org.h2.Driver" />
<property name="jdbcUsername" value="sa" />
<property name="jdbcPassword" value="" />
```



MyBatis连接池在处理大量并发请求时，并不是最经济或最具弹性的。因此，建议使用`javax.sql.DataSource`的实现，并将其注入到流程引擎配置中（如Hikari、Tomcat JDBC连接池，等等）

```xml
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" >
    <property name="driverClassName" value="com.mysql.jdbc.Driver" />
    <property name="url" value="jdbc:mysql://localhost:3306/flowable" />
    <property name="username" value="flowable" />
    <property name="password" value="flowable" />
    <property name="defaultAutoCommit" value="false" />
</bean>

<bean id="processEngineConfiguration" class="org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration">

    <property name="dataSource" ref="dataSource" />
    ...
```



请注意Flowable发布时不包括用于定义数据源的库。需要自行把库放在classpath中。

无论使用JDBC还是数据源方式配置，都可以使用下列参数：

- **databaseType**: 通常不需要专门设置这个参数，因为它可以从数据库连接信息中自动检测得出。只有在自动检测失败时才需要设置。可用值：{h2, mysql, oracle, postgres, mssql, db2}。这个选项会决定创建、删除与查询时使用的脚本。查看[“支持的数据库”](https://tkjohn.github.io/flowable-userguide/#supporteddatabases)章节了解我们支持哪些类型的数据库。
- **databaseSchemaUpdate**: 用于设置流程引擎启动关闭时使用的数据库表结构控制策略。
  - `false` (默认): 当引擎启动时，检查数据库表结构的版本是否匹配库文件版本。版本不匹配时抛出异常。
  - `true`: 构建引擎时，检查并在需要时更新表结构。表结构不存在则会创建。
  - `create-drop`: 引擎创建时创建表结构，并在引擎关闭时删除表结构。



### 配置JNDI数据源

默认情况下，Flowable的数据库配置保存在每个web应用WEB-INF/classes文件夹下的db.properties文件中。有时这样并不合适，因为这需要用户修改Flowable源码中的db.properties文件并重新编译war包，或者在部署后解开war包并修改db.properties文件。

通过使用JNDI（Java Naming and Directory Interface，Java命名和目录接口）获取数据库连接，连接就完全交由Servlet容器管理，并可以在WAR部署之外管理配置。同时也提供了比db.properties中更多的控制连接的参数



### 数据库表名说明

Flowable的所有数据库表都以**ACT_**开头。第二部分是说明表用途的两字符标示符。服务API的命名也大略符合这个规则。

- **ACT_RE_***: 'RE’代表`repository`。带有这个前缀的表包含“静态”信息，例如流程定义与流程资源（图片、规则等）。
- **ACT_RU_***: 'RU’代表`runtime`。这些表存储运行时信息，例如流程实例（process instance）、用户任务（user task）、变量（variable）、作业（job）等。Flowable只在流程实例运行中保存运行时数据，并在流程实例结束时删除记录。这样保证运行时表小和快。
- **ACT_HI_***: 'HI’代表`history`。这些表存储历史数据，例如已完成的流程实例、变量、任务等。
- **ACT_GE_***: 通用数据。在多处使用。



### 事件处理器

Flowable引擎中的事件机制可以让你在引擎中发生多种事件的时候得到通知。查看[所有支持的事件类型](https://tkjohn.github.io/flowable-userguide/#eventDispatcherEventTypes)了解可用的事件。

可以只为特定种类的事件注册监听器，而不是在任何类型的事件发送时都被通知。可以[通过配置](https://tkjohn.github.io/flowable-userguide/#eventDispatcherConfiguration)添加引擎全局的事件监听器，[在运行时通过API](https://tkjohn.github.io/flowable-userguide/#eventDispatcherConfigurationRuntime)添加引擎全局的事件监听器，也可以[在BPMN XML文件为个别流程定义](https://tkjohn.github.io/flowable-userguide/#eventDispatcherConfigurationProcessDefinition)添加事件监听器。

所有被分发的事件都是`org.flowable.engine.common.api.delegate.event.FlowableEvent`的子类。事件（在可用时）提供`type`, `executionId`, `processInstanceId`与`processDefinitionId`。部分事件含有关于发生事件的上下文信息。关于事件包含的附加信息，请参阅[所有支持的事件类型](https://tkjohn.github.io/flowable-userguide/#eventDispatcherEventTypes)。



#### 实现事件监听器

对事件监听器的唯一要求，是要实现`org.flowable.engine.delegate.event.FlowableEventListener`接口，例子，它将接收的所有事件打印至标准输出，并对作业执行相关的事件特别处理

```java
public class MyEventListener implements FlowableEventListener {

    @Override
    public void onEvent(FlowableEvent event) {
        switch (event.getType()) {

            case JOB_EXECUTION_SUCCESS:
                System.out.println("A job well done!");
                break;

            case JOB_EXECUTION_FAILURE:
                System.out.println("A job has failed...");
                break;

            default:
                System.out.println("Event received: " + event.getType());
        }
    }

    @Override
    public boolean isFailOnException() {
        // onEvent方法中的逻辑并不重要，可以忽略日志失败异常……

        return false;
    }
}
```



 `isFailOnException()`方法决定了当事件分发后，`onEvent(..)`方法抛出异常时的行为 

 若返回`false`，忽略异常；若返回`true`，异常不会被忽略而会被上抛，使当前执行的命令失败。如果事件是API调用（或其他事务操作，例如作业执行）的一部分，事务将被回滚。如果事件监听器中并不是重要的业务操作，建议返回`false`。 



Flowable提供了少量基础实现，以简化常用的事件监听器使用场景。它们可以被用作监听器的示例或基类：

- **org.flowable.engine.delegate.event.BaseEntityEventListener**: 事件监听器基类，可用来监听实体（entity）相关事件，特定或所有实体的事件都可以。它隐藏了类型检测，提供了4个需要覆盖的方法：`onCreate(..)`, `onUpdate(..)`与`onDelete(..)`在实体创建、更新及删除时调用；对所有其他实体相关事件，`onEntityEvent(..)`会被调用。



#### 配置与使用

 在流程引擎中配置的事件监听器会在流程引擎启动时生效，引擎重启后也会保持有效。 

 `eventListeners`参数为`org.flowable.engine.delegate.event.FlowableEventListener`类实例的列表(list)。与其他地方一样，你可以声明内联bean定义，也可以用`ref`指向已有的bean。下面的代码片段在配置中添加了一个事件监听器，无论任何类型的事件分发时，都会得到通知： 

```xml
<bean id="processEngineConfiguration"
      class="org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration">
    ...
    <property name="eventListeners">
        <list>
            <bean class="org.flowable.engine.example.MyEventListener" />
        </list>
    </property>
</bean>
```



 要在特定类型的事件分发时得到通知，使用`typedEventListeners`参数，值为map。map的key为逗号分隔的事件名字列表（或者一个事件的名字），取值为`org.flowable.engine.delegate.event.FlowableEventListener`实例的列表。下面的代码片段在配置中添加了一个事件监听器，它会在作业执行成功或失败时得到通知： 

```xml
<bean id="processEngineConfiguration"
      class="org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration">
    ...
    <property name="typedEventListeners">
        <map>
            <entry key="JOB_EXECUTION_SUCCESS,JOB_EXECUTION_FAILURE" >
                <list>
                    <bean class="org.flowable.engine.example.MyJobEventListener" />
                </list>
            </entry>
        </map>
    </property>
</bean>
```











## Flowable API

引擎API是与Flowable交互的最常用手段。总入口点是`ProcessEngine`

```java
ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();

RuntimeService runtimeService = processEngine.getRuntimeService();
RepositoryService repositoryService = processEngine.getRepositoryService();
TaskService taskService = processEngine.getTaskService();
ManagementService managementService = processEngine.getManagementService();
IdentityService identityService = processEngine.getIdentityService();
HistoryService historyService = processEngine.getHistoryService();
FormService formService = processEngine.getFormService();
DynamicBpmnService dynamicBpmnService = processEngine.getDynamicBpmnService();
```



 在`ProcessEngines.getDefaultProcessEngine()`第一次被调用时，将初始化并构建流程引擎，之后的重复调用都会返回同一个流程引擎。可以通过`ProcessEngines.init()`创建流程引擎，并由`ProcessEngines.destroy()`关闭流程引擎。 



 ProcessEngines会扫描`flowable.cfg.xml`与`flowable-context.xml`文件。对于`flowable.cfg.xml`文件，流程引擎会以标准Flowable方式构建引擎：`ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()`。对于`flowable-context.xml`文件，流程引擎会以Spring的方式构建：首先构建Spring应用上下文，然后从该上下文中获取流程引擎。 



 **RepositoryService**很可能是使用Flowable引擎要用的第一个服务。这个服务提供了管理与控制`部署(deployments)`与`流程定义(process definitions)`的操作。 

这个服务还可以：

- 查询引擎现有的部署与流程定义。
- 暂停或激活部署中的某些流程，或整个部署。暂停意味着不能再对它进行操作，激活刚好相反，重新使它可以操作。
- 获取各种资源，比如部署中保存的文件，或者引擎自动生成的流程图。
- 获取POJO版本的流程定义。它可以用Java而不是XML的方式查看流程。



 与提供静态信息（也就是不会改变，至少不会经常改变的信息）的`RepositoryService`相反，**RuntimeService**用于启动流程定义的新流程实例。 



对于像Flowable这样的BPM引擎来说，核心是需要人类用户操作的任务。所有任务相关的东西都组织在**TaskService**中，例如：

- 查询分派给用户或组的任务
- 创建*独立运行(standalone)*任务。这是一种没有关联到流程实例的任务。
- 决定任务的执行用户(assignee)，或者将用户通过某种方式与任务关联。
- 认领(claim)与完成(complete)任务。认领是指某人决定成为任务的执行用户，也即他将会完成这个任务。完成任务是指“做这个任务要求的工作”，通常是填写某个表单。

**IdentityService**很简单。它用于管理（创建，更新，删除，查询……）组与用户。请注意，Flowable实际上在运行时并不做任何用户检查。例如任务可以分派给任何用户，而引擎并不会验证系统中是否存在该用户。这是因为Flowable有时要与LDAP、Active Directory等服务结合使用。

**FormService**是可选服务。也就是说Flowable没有它也能很好地运行，而不必牺牲任何功能。这个服务引入了*开始表单(start form)*与*任务表单(task form)*的概念。 *开始表单*是在流程实例启动前显示的表单，而*任务表单*是用户完成任务时显示的表单。Flowable可以在BPMN 2.0流程定义中定义这些表单。表单服务通过简单的方式暴露这些数据。再次重申，表单不一定要嵌入流程定义，因此这个服务是可选的。

**HistoryService**暴露Flowable引擎收集的所有历史数据。当执行流程时，引擎会保存许多数据（可配置），例如流程实例启动时间、谁在执行哪个任务、完成任务花费的事件、每个流程实例的执行路径，等等。这个服务主要提供查询这些数据的能力。

**ManagementService**通常在用Flowable编写用户应用时不需要使用。它可以读取数据库表与表原始数据的信息，也提供了对作业(job)的查询与管理操作。Flowable中很多地方都使用作业，例如定时器(timer)，异步操作(asynchronous continuation)，延时暂停/激活(delayed suspension/activation)等等。后续会详细介绍这些内容。

**DynamicBpmnService**可用于修改流程定义中的部分内容，而不需要重新部署它。例如可以修改流程定义中一个用户任务的办理人设置，或者修改一个服务任务中的类名。





### 异常策略

 Flowable的异常基类是`org.flowable.engine.FlowableException`，这是一个非受检异常(unchecked exception)。在任何API操作时都可能会抛出这个异常 

- `FlowableWrongDbException`: 当Flowable引擎检测到数据库表结构版本与引擎版本不匹配时抛出。
- `FlowableOptimisticLockingException`: 当对同一数据实体的并发访问导致数据存储发生乐观锁异常时抛出。
- `FlowableClassLoadingException`: 当需要载入的类（如JavaDelegate, TaskListener, …）无法找到，或载入发生错误时抛出。
- `FlowableObjectNotFoundException`: 当请求或要操作的对象不存在时抛出。
- `FlowableIllegalArgumentException`: 当调用Flowable API时使用了不合法的参数时抛出。可能是引擎配置中的不合法值，或者是API调用传递的不合法参数，也可能是流程定义中的不合法值。
- `FlowableTaskAlreadyClaimedException`: 当对已被认领的任务调用`taskService.claim(…)`时抛出。





### 查询API

 从引擎中查询数据有两种方式：查询API与原生(native)查询。查询API可以使用链式API，通过编程方式进行类型安全的查询 

```java
List<Task> tasks = taskService.createTaskQuery()
    .taskAssignee("kermit")
    .processVariableValueEquals("orderId", "0815")
    .orderByDueDate()
    .asc()
    .list();
```



有时需要更复杂的查询，例如使用OR操作符查询，或者使用查询API不能满足查询条件要求。为这种需求提供了可以自己写SQL查询的原生查询。 

```java
List<Task> tasks = taskService.createNativeTaskQuery()
    .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) +
         " T WHERE T.NAME_ = #{taskName}")
    .parameter("taskName", "gonzoTask")
    .list();

long count = taskService.createNativeTaskQuery()
    .sql("SELECT count(*) FROM " + managementService.getTableName(Task.class) + " T1, " +
         managementService.getTableName(VariableInstanceEntity.class) + " V1 WHERE V1.TASK_ID_ = T1.ID_")
    .count();
```



### 变量

 流程实例按步骤执行时，需要使用一些数据。在Flowable中，这些数据称作*变量(variable)*，并会存储在数据库中 

 变量可以用在表达式中（例如在排他网关中用于选择正确的出口路径），也可以在Java服务任务(service task)中用于调用外部服务（例如为服务调用提供输入或结果存储），等等 



流程实例可以持有变量（称作*流程变量 process variables*）；用户任务以及*执行(executions)*——流程当前活动节点的指针——也可以持有变量。流程实例可以持有任意数量的变量，每个变量存储为*ACT_RU_VARIABLE*数据库表的一行



 所有的*startProcessInstanceXXX*方法都有一个可选参数，用于在流程实例创建及启动时设置变量 

```java
ProcessInstance startProcessInstanceByKey(String processDefinitionKey, Map<String, Object> variables);
```



 也可以在流程执行中加入变量。例如，(*RuntimeService*): 

```java
void setVariable(String executionId, String variableName, Object value);
void setVariableLocal(String executionId, String variableName, Object value);
void setVariables(String executionId, Map<String, ? extends Object> variables);
void setVariablesLocal(String executionId, Map<String, ? extends Object> variables);
```



请注意可以为给定执行（请记住，流程实例由一颗执行的树(tree of executions)组成）设置*局部(local)*变量。局部变量将只在该执行中可见，对执行树的上层则不可见。这可以用于 数据不应该暴露给流程实例的其他执行，或者变量在流程实例的不同路径中有不同的值（例如使用并行路径时）的情况。

可以用下列方法读取变量。

```java
Map<String, Object> getVariables(String executionId);
Map<String, Object> getVariablesLocal(String executionId);
Map<String, Object> getVariables(String executionId, Collection<String> variableNames);
Map<String, Object> getVariablesLocal(String executionId, Collection<String> variableNames);
Object getVariable(String executionId, String variableName);
<T> T getVariable(String executionId, String variableName, Class<T> variableClass);
```



变量通常用于[Java代理（Java delegates）](https://tkjohn.github.io/flowable-userguide/#bpmnJavaServiceTask)、[表达式（expressions）](https://tkjohn.github.io/flowable-userguide/#apiExpressions)、执行（execution）、任务监听器（tasklisteners）、脚本（scripts）等等。在这些结构中，提供了当前的*execution*或*task*对象，可用于变量的设置、读取

```java
execution.getVariables();
execution.getVariables(Collection<String> variableNames);
execution.getVariable(String variableName);

execution.setVariables(Map<String, object> variables);
execution.setVariable(String variableName, Object value);
```



引擎是否需要读取并缓存所有变量 

```java
Map<String, Object> getVariables(Collection<String> variableNames, boolean fetchAllVariables);
Object getVariable(String variableName, boolean fetchAllVariables);
void setVariable(String variableName, Object value, boolean fetchAllVariables);
```

当*fetchAllVariables*参数为*true*时，行为与上面描述的完全一样：读取或设置一个变量时，所有的变量都将被读取并缓存。

而当参数值为*false*时，会使用明确的查询，其他变量不会被读取或缓存。只有指定的变量的值会被缓存并用于后续使用。







## 集成Spring

### ProcessEngineFactoryBean

可以将`ProcessEngine`配置为普通的Spring bean。入口是`org.flowable.spring.ProcessEngineFactoryBean`类。这个bean处理流程引擎配置，并创建流程引擎。Spring集成所用的配置与引擎bean为：

```xml
<bean id="processEngineConfiguration" class="org.flowable.spring.SpringProcessEngineConfiguration">
    ...
</bean>

<bean id="processEngine" class="org.flowable.spring.ProcessEngineFactoryBean">
    <property name="processEngineConfiguration" ref="processEngineConfiguration" />
</bean>
```



### 事务

将DataSource传递给`SpringProcessEngineConfiguration`（使用“dataSource”参数）时，Flowable会在内部使用`org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy`对得到的数据源进行包装

为了保证从数据源获取的SQL连接与Spring的事务可以协同工作。这样也就不需要在Spring配置中对数据源进行代理（proxy）。但仍然可以将代理`TransactionAwareDataSourceProxy`传递给`SpringProcessEngineConfiguration`——在这种情况下，不会再进行包装

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context-2.5.xsd
                           http://www.springframework.org/schema/tx
                           http://www.springframework.org/schema/tx/spring-tx-3.0.xsd">

    <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
        <property name="driverClass" value="org.h2.Driver" />
        <property name="url" value="jdbc:h2:mem:flowable;DB_CLOSE_DELAY=1000" />
        <property name="username" value="sa" />
        <property name="password" value="" />
    </bean>

    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>

    <bean id="processEngineConfiguration" class="org.flowable.spring.SpringProcessEngineConfiguration">
        <property name="dataSource" ref="dataSource" />
        <property name="transactionManager" ref="transactionManager" />
        <property name="databaseSchemaUpdate" value="true" />
        <property name="asyncExecutorActivate" value="false" />
    </bean>

    <bean id="processEngine" class="org.flowable.spring.ProcessEngineFactoryBean">
        <property name="processEngineConfiguration" ref="processEngineConfiguration" />
    </bean>

    <bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" />
    <bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" />
    <bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" />
    <bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" />
    <bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" />

    ...
```



```xml
<beans>
    ...
    <tx:annotation-driven transaction-manager="transactionManager"/>

    <bean id="userBean" class="org.flowable.spring.test.UserBean">
        <property name="runtimeService" ref="runtimeService" />
    </bean>

    <bean id="printer" class="org.flowable.spring.test.Printer" />

</beans>
```



 创建Spring应用上下文 

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(
	"SpringTransactionIntegrationTest-context.xml");
```



然后就可以获取服务bean，并调用它们的方法。ProcessEngineFactoryBean会为服务加上额外的拦截器(interceptor)，并为Flowable服务方法设置Propagation.REQUIRED事务级别

```java
RepositoryService repositoryService =
    (RepositoryService) applicationContext.getBean("repositoryService");

String deploymentId = repositoryService
    .createDeployment()
    .addClasspathResource("org/flowable/spring/test/hello.bpmn20.xml")
    .deploy()
    .getId();
```



 另一种方法也可以使用。如果userBean.hello()方法在Spring事务中，Flowable服务方法调用就会加入这个事务 

```java
UserBean userBean = (UserBean) applicationContext.getBean("userBean");
userBean.hello();

public class UserBean {

    /** 已经由Spring注入 */
    private RuntimeService runtimeService;

    @Transactional
    public void hello() {
        // 可以在你的领域模型（domain model）中进行事务操作，
        // 它会与Flowable RuntimeService的startProcessInstanceByKey
        // 合并在同一个事务里
        runtimeService.startProcessInstanceByKey("helloProcess");
    }

    public void setRuntimeService(RuntimeService runtimeService) {
        this.runtimeService = runtimeService;
    }
}
```



### 表达式

当使用ProcessEngineFactoryBean时，默认BPMN流程中所有的[表达式](https://tkjohn.github.io/flowable-userguide/#apiExpressions)都可以“看见”所有的Spring bean。可以通过配置的map，限制表达式能使用的bean，甚至可以完全禁止表达式使用bean。下面的例子只暴露了一个bean（printer），可以使用“printer”作为key访问。**要完全禁止表达式使用bean，可以将SpringProcessEngineConfiguration的‘beans’参数设为空list。如果不设置‘beans’参数，则上下文中的所有bean都将可以使用**

```xml
<bean id="processEngineConfiguration" class="org.flowable.spring.SpringProcessEngineConfiguration">
    ...
    <property name="beans">
        <map>
            <entry key="printer" value-ref="printer" />
        </map>
    </property>
</bean>

<bean id="printer" class="org.flowable.examples.spring.Printer" />
```



 通过UEL方法表达式(method expression)调用Spring bean 

```xml
<definitions id="definitions">

    <process id="helloProcess">

        <startEvent id="start" />
        <sequenceFlow id="flow1" sourceRef="start" targetRef="print" />

        <serviceTask id="print" flowable:expression="#{printer.printMessage()}" />
        <sequenceFlow id="flow2" sourceRef="print" targetRef="end" />

        <endEvent id="end" />

    </process>

</definitions>
```



 `Printer`为 

```java
public class Printer {
    public void printMessage() {
        System.out.println("hello world");
    }
}
```



### 自动部署资源

 集成Spring也提供了部署资源的特殊方式。在流程引擎配置中，可以指定一组资源。当创建流程引擎时，会扫描并部署这些资源。可以用过滤器阻止重复部署：只有当资源确实发生变化时，才会重新部署至Flowable数据库。 

```xml
<bean id="processEngineConfiguration" class="org.flowable.spring.SpringProcessEngineConfiguration">
    ...
    <property name="deploymentResources"
              value="classpath*:/org/flowable/spring/test/autodeployment/autodeploy.*.bpmn20.xml" />
</bean>

<bean id="processEngine" class="org.flowable.spring.ProcessEngineFactoryBean">
    <property name="processEngineConfiguration" ref="processEngineConfiguration" />
</bean>
```

 默认情况下，上面的配置方式会将符合这个过滤器的所有资源组织在一起，作为Flowable引擎的一个部署。重复检测过滤器将作用于整个部署，避免重复地部署未改变资源。 



可以使用`SpringProcessEngineConfiguration`中的额外参数+deploymentMode+，定制部署的方式。这个参数定义了对于一组符合过滤器的资源，组织部署的方式。默认这个参数有3个可用值：

- `default`: 将所有资源组织在一个部署中，整体用于重复检测过滤。这是默认值，在未设置这个参数时也会用这个值。
- `single-resource`: 为每个资源创建一个单独的部署，并用于重复检测过滤。如果希望单独部署每一个流程定义，并且只有在它发生变化时才创建新的流程定义版本，就应该使用这个值。
- `resource-parent-folder`: 为同一个目录下的资源创建一个单独的部署，并用于重复检测过滤。这个参数值可以为大多数资源创建独立的部署。同时仍可以通过将部分资源放在同一个目录下，将它们组织在一起。这里有一个将`deploymentMode`设置为`single-resource`的例子：

```xml
<bean id="processEngineConfiguration"
      class="org.flowable.spring.SpringProcessEngineConfiguration">
    ...
    <property name="deploymentResources" value="classpath*:/flowable/*.bpmn" />
    <property name="deploymentMode" value="single-resource" />
</bean>
```



### Spring Boot

 依赖 

```xml
<dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-spring-boot-starter</artifactId>
    <version>${flowable.version}</version>
</dependency>

<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>1.4.197</version>
</dependency>
```



只是在classpath中添加依赖，并使用*@SpringBootAplication*注解，就会在幕后发生很多事情：

- 自动创建了内存数据库（因为classpath中有H2驱动），并传递给Flowable流程引擎配置
- 创建并暴露了Flowable的ProcessEngine、CmmnEngine、DmnEngine、FormEngine、ContentEngine及IdmEngine bean
- 所有的Flowable服务都暴露为Spring bean
- 创建了Spring Job Executor

并且：

- *processes*目录下的任何BPMN 2.0流程定义都会被自动部署。创建*processes*目录，并在其中创建示例流程定义（命名为*one-task-process.bpmn20.xml*）。
- *cases*目录下的任何CMMN 1.1事例都会被自动部署。
- *forms*目录下的任何Form定义都会被自动部署。



```xml
<?xml version="1.0" encoding="UTF-8"?>
<definitions
             xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
             xmlns:flowable="http://flowable.org/bpmn"
             targetNamespace="Examples">

    <process id="oneTaskProcess" name="The One Task Process">
        <startEvent id="theStart" />
        <sequenceFlow id="flow1" sourceRef="theStart" targetRef="theTask" />
        <userTask id="theTask" name="my task" />
        <sequenceFlow id="flow2" sourceRef="theTask" targetRef="theEnd" />
        <endEvent id="theEnd" />
    </process>

</definitions>
```



*CommandLineRunner*是一个特殊的Spring bean，在应用启动时执行 

```java
@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }

    @Bean
    public CommandLineRunner init(final RepositoryService repositoryService,
                                  final RuntimeService runtimeService,
                                  final TaskService taskService) {

        return new CommandLineRunner() {
            @Override
            public void run(String... strings) throws Exception {
                System.out.println("Number of process definitions : "
                                   + repositoryService.createProcessDefinitionQuery().count());
                System.out.println("Number of tasks : " + taskService.createTaskQuery().count());
                runtimeService.startProcessInstanceByKey("oneTaskProcess");
                System.out.println("Number of tasks after process start: "
                                   + taskService.createTaskQuery().count());
            }
        };
    }
}
```



#### REST 支持

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <version>${spring.boot.version}</version>
</dependency>
```



 创建一个新的Spring服务类，并创建两个方法：一个用于启动流程，另一个用于获得给定任务办理人的任务列表 

```java
@Service
public class MyService {

    @Autowired
    private RuntimeService runtimeService;

    @Autowired
    private TaskService taskService;

    @Transactional
    public void startProcess() {
        runtimeService.startProcessInstanceByKey("oneTaskProcess");
    }

    @Transactional
    public List<Task> getTasks(String assignee) {
        return taskService.createTaskQuery().taskAssignee(assignee).list();
    }

}
```



 用*@RestController*来注解类，以创建REST endpoint 

```java
@RestController
public class MyRestController {

    @Autowired
    private MyService myService;

    @RequestMapping(value="/process", method= RequestMethod.POST)
    public void startProcessInstance() {
        myService.startProcess();
    }

    @RequestMapping(value="/tasks", method= RequestMethod.GET, produces=MediaType.APPLICATION_JSON_VALUE)
    public List<TaskRepresentation> getTasks(@RequestParam String assignee) {
        List<Task> tasks = myService.getTasks(assignee);
        List<TaskRepresentation> dtos = new ArrayList<TaskRepresentation>();
        for (Task task : tasks) {
            dtos.add(new TaskRepresentation(task.getId(), task.getName()));
        }
        return dtos;
    }

    static class TaskRepresentation {

        private String id;
        private String name;

        public TaskRepresentation(String id, String name) {
            this.id = id;
            this.name = name;
        }

        public String getId() {
            return id;
        }
        public void setId(String id) {
            this.id = id;
        }
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }

    }
}
```



#### Liquibase

 Flowable引擎使用Liquibase管理数据库版本。 因此Spring Boot的 `LiquibaseAutoConfiguration` 会自动启用。 然而，如果你并未使用Liquibase，则应用将无法启动，并抛出异常。 因此Flowable将 `spring.liquibase.enabled` 设置为 `false` ，也即如果需要使用Liquibase，则需手动启用它。 



#### 高级配置

##### 自定义引擎配置

实现*org.flowable.spring.boot.EngineConfigurationConfigurer*接口，可以获取引擎配置对象。其中*T*是具体引擎配置的Spring类型。 这样可以在参数尚未公开时，进行高级配置，或简化配置。

```java
public class MyConfigurer implements EngineConfigurationConfigurer<SpringProcessEngineConfiguration> {

    public void configure(SpringProcessEngineConfiguration processEngineConfiguration) {
        // advanced configuration
    }

}
```

 在Spring Boot配置中使用*@Bean*发布该类的实例，这样配置类会在流程引擎创建前调用 



##### 整合starter

 如果需要一组引擎，则只能依次添加依赖。 比如要使用流程、CMMN、Form与IDM引擎，并使用LDAP，则需要添加这些依赖 

```xml
<dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-spring-boot-starter-process</artifactId>
    <version>${flowable.version}</version>
</dependency>
<dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-spring-boot-starter-cmmn</artifactId>
    <version>${flowable.version}</version>
</dependency>
<dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-content-spring-configurator</artifactId>
    <version>${flowable.version}</version>
</dependency>
<dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-ldap</artifactId>
    <version>${flowable.version}</version>
</dependency>
```



##### 配置异步执行器

流程及CMMN引擎使用专门的 `AsyncExecutor` ，并可使用 `flowable.{engine}.async.executor` 参数组进行配置。 其中 `engine` 代表 `process` 或 `cmmn` 。

默认情况下， `AsyncExecutor` 共享同一个Spring `TaskExecutor` 及 `SpringRejectedJobsHandler` 。 如果需要为引擎提供专门的执行器，则需要使用 `@Process` 及 `@Cmmn` 定义的bean。

可以使用如下方法配置自定义的执行器：

```java
@Configuration
public class MyConfiguration {

    @Process  // 流程引擎将使用 SimpleAsyncTaskExecutor 作为异步执行器
    @Bean
    public TaskExecutor processTaskExecutor() {
        return new SimpleAsyncTaskExecutor();
    }

    @Cmmn  // CMMN引擎将使用 SyncTaskExecutor 作为异步执行器
    @Bean
    public TaskExecutor cmmnTaskExecutor() {
        return new SyncTaskExecutor();
    }
}
```



如果使用了自定义的 `TaskExecutor` bean，则Flowable将不会再创建自己的bean。 也就是说如果使用 `@Process` 定义了bean，也需要使用 `@Cmmn` 或 `@Primary` 再定义一个bean。否则Cmmn异步执行器将使用流程引擎所用的bean 











## UserTask

包含属性：

​	集合（多实例）、元素变量（多实例）、完成条件（多实例）、是否补偿、分配用户、表单key、表单引用、到期时间、优先级、表单属性、任务监听器、Skip expression



