# 数据库索引

## 基础

### 索引的优缺点

- 优点：
  - 大大加快数据的检索速度，这也是创建索引的最主要的原因；
  - 加速表和表之间的连接；
  - 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；
  - 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；

- 缺点：
  - 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度；
  - 空间方面：索引需要占物理空间。


### 索引的数据结构

- 二分查找树

- - 缺点：

- - - 二分查找树进行二分查找时可能变成线性的链表结构，导致时间复杂度从 O(logN) 变为 O(N)

- B- Tree结构

- - 根节点至少包括两个子节点
  - 树中每个节点最多包含m个子节点（m >= 2）
  - 除根节点和叶子节点外，其他每个节点至少有 ceil(m/2) 个子节点（ceil 向上取整）
  - 所有叶子节点都位于同一层
  - 每个非终端节点中包含 n 个关键字信息，关键字按升序排序

- B+ Tree结构

- - B+ Tree 是 B-Tree 的变体
  - 非叶子节点的子树指针与关键字个数相同
  - 非叶子节点仅用来做索引，数据全保存在叶子节点中

- Hash结构

- - 缺点：

- - - 仅仅满足“=”、“IN”不能使用范围查询
    - 无法被用来避免数据的排序操作
    - 不能利用组合索引的部分索引键查询
    - 不能避免全表扫描
    - 遇到大量Hash值相同的情况后性能并不一定就会比B-Tree索引高

- BitMap索引

- - 只有Oracle支持

### 索引的分类

- 索引列的值的唯一性

- - 普通索引
  - 唯一性索引

- 索引列所包含的列数

- - 单个索引
  - 复合索引

- 根据叶子节点的内容

- - 主键索引：主键索引的叶子节点存的整行数据，在InnoDB里也被称为聚簇索引
  - 非主键索引：非主键索引叶子节点存的主键的值，在InnoDB里也被称为二级索引

- 引按照数据的物理存储进行划分

- - 聚簇索引：对于一堆记录来说，使用聚集索引就是对这堆记录进行堆划分，即主要描述的是物理上的存储。正是因为这种划分方法，导致聚簇索引必须是唯一的。聚集索引可以帮助把很大的范围，迅速减小范围。但是查找该记录，就要从这个小范围中Scan了
  - 非聚簇索引：非聚集索引是把一个很大的范围，转换成一个小的地图，然后需要在这个小地图中寻找的信息的位置，最后通过这个位置，再去找你所需要的记录

- 密集索引、稀疏索引

- - 密集索引文件中的每个搜索码值都对应一个索引值
  - 稀疏索引文件只为索引码的某些值建立索引项

### 什么样的字段适合创建索引

- 经常作查询选择的字段
- 经常作表连接的字段
- 经常出现在 order by、group by、distinct 后面的字段

### MyISAM 和 InnoDB 实现 B 树索引方式的区别是什么？

- InnoDB 存储引擎：B+ 树索引的叶子节点保存数据本身，其数据文件本身就是索引文件
- MyISAM 存储引擎：B+ 树索引的叶子节点保存数据的物理地址，叶节点的 data 域存放的是数据记录的地址，索引文件和数据文件是分离的

### InnoDB 为什么设计 B+ 树索引？

- 两个考虑因素：

- - InnoDB 需要执行的场景和功能需要在特定查询上拥有较强的性能
  - CPU 将磁盘上的数据加载到内存中需要花费大量时间

- 为什么选择 B+ 树：

- - 哈希索引虽然能提供O（1）复杂度查询，但对范围查询和排序却无法很好的支持，最终会导致全表扫描
  - B 树能够在非叶子节点存储数据，但会导致在查询连续数据可能带来更多的随机 IO
  - 而 B+ 树的所有叶节点可以通过指针来相互连接，减少顺序遍历带来的随机 IO

### 普通索引还是唯一索引？

由于唯一索引用不上 change buffer 的优化机制，因此如果业务可以接受，从性能角度出发建议你优先考虑非唯一索引

### 联合索引最左匹配原则的成因

- 最左前缀匹配原则

- - mysql会一直从左向右匹配直到遇到范围查询（>、<、between、like）就停止匹配，比如`a = 3 and b = 4 and c > 5 and d = 6`，如过建立的索引顺序为`a、b、c、d`，则 d 用不到索引，若索引顺序为`a、b、d、c`则可以用到索引
  - = 和 in 可以乱序，索引列写的顺序可以任意

- mysql会对复合索引的第一个索引进行排序，然后再根据第一个索引列对第二个索引列进行排序，所以这个第二列是无序的，因此在直接对第二个索引列进行条件判断的时候，是不会使用到复合索引的

### 什么是覆盖索引和索引下推？

- 覆盖索引

- - 在某个查询里面，索引 k 已经“覆盖了”我们的查询需求，称为覆盖索引
  - 覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段

- 索引下推

- - MySQL 5.6 引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

### 哪些操作会导致索引失效？

- 对索引列使用左或者左右模糊匹配：也就是 **like %xx** 或者 **like %xx%** 这两种方式都会造成索引失效。原因在于查询的结果可能是多个，不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。
- 对索引列进行函数或表达式计算：因为索引保持的是索引字段的原始值，而不是经过函数计算的值，自然就没办法走索引。
- 对索引列进行隐式转换：如varchar不加单引号的话可能会自动转换为int型，相当于使用了新函数
- WHERE子句的OR语句中，只要有条件列不是索引列，就会进行全表扫描
- 多列索引没有满足最左匹配原则

### 字符串加索引问题

- 直接创建完整索引，这样可能会比较占用空间
- 创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引
- 倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题
- 创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描

### 创建索引时需要注意什么？

- 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替空值；
- 取值离散大的字段：变量各个取值之间的差异程度大的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
- 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。

### 主键、自增主键、主键索引与唯一索引概念区别

- 主键：指字段唯一、不为空值的列；
- 主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；
- 自增主键：字段类型为数字、自增、并且是主键；
- 唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，但唯一索引不是主键，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。

### 主键就是聚集索引吗？主键和索引有什么区别？

主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。

在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。

InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。

### 文件索引和数据库索引为什么使用B+树？

文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。

数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。